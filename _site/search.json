[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Curso Epidemiología - Nivel Avanzado",
    "section": "",
    "text": "¡Les damos la bienvenida al curso de Epidemiología Nivel Avanzado!\n\nEs un gusto recibirles en esta nueva edición del curso, diseñado para profundizar en el análisis de datos provenientes de distintos diseños de estudio mediante el uso de modelos estadísticos.\nA lo largo del curso, abordaremos herramientas analíticas avanzadas que nos permitirán modelar adecuadamente la relación entre exposiciones y desenlaces en estudios transversales, de casos y controles, de cohortes y experimentales. Nos enfocaremos en la aplicación práctica de estos modelos, en la interpretación de resultados y en los supuestos que los sustentan, promoviendo una mirada crítica sobre su uso en la investigación epidemiológica.\nEsperamos que este espacio sea una experiencia formativa enriquecedora y un nuevo impulso en su desarrollo como investigadoras e investigadores en salud.\n\nEl equipo docente\n\n\n\n\n Volver arribaReutilizaciónCC BY-NC 4.0"
  },
  {
    "objectID": "unidad_1/primeros_pasos.html",
    "href": "unidad_1/primeros_pasos.html",
    "title": "Primeros pasos y generalidades",
    "section": "",
    "text": "Artwork por @allison_horst",
    "crumbs": [
      "Unidad 1",
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "unidad_1/primeros_pasos.html#introducción-a-rstudio",
    "href": "unidad_1/primeros_pasos.html#introducción-a-rstudio",
    "title": "Primeros pasos y generalidades",
    "section": "Introducción a RStudio",
    "text": "Introducción a RStudio\nRStudio Desktop (2025, Posit Software) es un entorno de desarrollo integrado (IDE, por sus siglas en inglés) diseñado específicamente para trabajar con el lenguaje R.\nEs una herramienta multiplataforma y de código abierto que facilita la programación, el análisis de datos y la elaboración de informes científicos. Ofrece una integración fluida con otros componentes del ecosistema de R, como R Markdown, Quarto, control de versiones (por ejemplo, Git) y la gestión de proyectos.\nRStudio presenta una interfaz unificada compuesta por distintos paneles, lo que permite organizar el trabajo de forma clara y eficiente:\n\n\n\n\n\nEditor de scripts (Source): permite crear y editar scripts de R, así como documentos R Markdown o Quarto.\nConsola de R (Console): muestra la salida del código ejecutado y ejecuta código de R de forma inmediata.\nEntorno (Environment): muestra los objetos creados durante la sesión, como vectores, dataframes o funciones.\nPanel de resultados (Output): presenta los gráficos, tablas, visualizaciones en HTML y también incluye un explorador de archivos, visor de paquetes instalados y panel de ayuda.\n\nPara garantizar la reproducibilidad de los resultados, es recomendable evitar el guardado automático del historial de objetos entre sesiones, ya que puede generar confusión. Para desactivar esta opción, ir a Tools &gt; Global Options y desmarcar las casillas de las opciones Workspace y History como se muestra en la siguiente imagen:",
    "crumbs": [
      "Unidad 1",
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "unidad_1/primeros_pasos.html#proyectos-de-rstudio",
    "href": "unidad_1/primeros_pasos.html#proyectos-de-rstudio",
    "title": "Primeros pasos y generalidades",
    "section": "Proyectos de RStudio",
    "text": "Proyectos de RStudio\nLos proyectos de RStudio permiten organizar de forma estructurada todo el material asociado a un análisis: scripts, informes, bases de datos, imágenes, etc. Cada proyecto se vincula a una carpeta específica del sistema de archivos, y RStudio la utiliza como directorio de trabajo por defecto. Esta carpeta puede estar ubicada en cualquier parte del sistema de almacenamiento que deseemos (disco rígido, pendrive, disco externo, etc).\nTrabajar con proyectos facilita la importación de datos y evita errores relacionados con rutas relativas o absolutas.\nCrear un proyecto\nPara crear un nuevo proyecto, se puede utilizar el menú File &gt; New Project.... También accedemos a generar un proyecto nuevo a partir de pulsar el acceso directo New Project... ubicado en la esquina superior derecha de la interfaz:\n\n\n\n\nEn cualquiera de los dos casos aparecerá un cuadro de diálogo que presenta tres opciones para crear el nuevo proyecto de RStudio:\n\n\n\n\n\nNew Directory: crea una nueva carpeta para el proyecto a la que deberemos asignarle un nombre, es la opción más habitual. Todos los archivos de configuración aparecerán asociados a esta nueva carpeta.\nExisting Directory: vincula el proyecto a una carpeta ya existente que contenga archivos previos con los que deseamos trabajar.\nVersion Control: permite clonar un repositorio (Git o SVN). Esta opción no se utilizará durante el curso.\n\nUna vez que creamos un nuevo proyecto con la opción New Directory, aparecerá una pantalla con una lista de tipos de proyectos que se pueden crear en RStudio:\n\n\n\n\nDurante este curso utilizaremos siempre la primera opción (New Project). Las demás opciones están pensadas para usos más específicos, como el desarrollo de paquetes de R, sitios web o documentos con Quarto o R Markdown.\nAl seleccionar New Project, se abrirá una nueva ventana con los siguientes campos:\n\nDirectory name: aquí debemos escribir el nombre del nuevo directorio (carpeta) que también será el nombre del proyecto. Por ejemplo, podemos llamarlo Practicas_R.\nCreate project as subdirectory of: este campo permite definir en qué ubicación del sistema de archivos se guardará el proyecto. Podemos hacer clic en el botón Browse… para abrir el explorador de archivos y seleccionar la carpeta contenedora. En nuestro ejemplo, lo ubicaremos dentro de Mis Documentos.\n\n\n\n\n\nUna vez completados estos campos, hacemos clic en Create Project.\nLos proyectos en RStudio tienen entornos independientes, lo que significa que si cerramos un proyecto o cambiamos a otro, la configuración de cada uno se mantendrá inalterable sin interferir con los demás.\nEsto incluye los scripts abiertos, el directorio de trabajo, las pestañas que dejamos activas y otros elementos del entorno que puedan ser necesarios para continuar con un análisis. Este sistema permite mantener organizados los distintos trabajos que llevamos adelante.\nEchemos un vistazo a lo que RStudio realizó:\n\nEn primer lugar el panel Files (pantalla inferior derecha) apunta a la nueva carpeta Practicas_R y dentro de ella vemos un nuevo archivo el nombre del proyecto y la extensión .Rproj. Este archivo contiene todas las configuraciones para su proyecto.\nEl otro cambio se observa en la parte superior derecha, que muestra el nombre del proyecto. Si hacemos click en él, se desplegará el menú de proyectos. Desde aquí se puede abrir y cerrar proyectos, navegar rápidamente a proyectos que se han abierto recientemente y configurar las opciones de RStudio para cada uno de ellos.\n\n\n\n\n\nAbrir un proyecto existente\nCuando el proyecto ya existe, sea porque lo creamos nosotros o porque alguien nos pasó una carpeta con un proyecto de RStudio creado vamos a visualizar dentro de esa carpeta un archivo con extensión .Rproj.\nLa forma más veloz para abrir el proyecto es ejecutar este archivo (debería abrir una sesión de RStudio con el proyecto activo). La otra forma es desde el menú superior derecho de RStudio en la opción Open project… y luego buscando en nuestro directorio el mismo archivo .Rproj.\n\n\n\n\n\n\nNota\n\n\n\nEl menú de proyectos del área superior derecha va guardando como elementos recientes los proyectos que se van abriendo y también es una forma rápida de acceder a ellos pulsando sobre estos atajos.",
    "crumbs": [
      "Unidad 1",
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "unidad_1/primeros_pasos.html#scripts-en-rstudio",
    "href": "unidad_1/primeros_pasos.html#scripts-en-rstudio",
    "title": "Primeros pasos y generalidades",
    "section": "Scripts en RStudio",
    "text": "Scripts en RStudio\nComo vimos anteriormente, un script es un archivo de código que contiene una secuencia de instrucciones escritas en R. Estos scripts pueden ser reutilizados, modificados y compartidos, lo que los convierte en una herramienta fundamental para garantizar la reproducibilidad del trabajo.\nCrear un nuevo script\nTenemos varias formas de crear un script nuevo:\n\nDesde el menú superior: File &gt; New File &gt; R Script\nCon el atajo de teclado: Ctrl + Shift + N\nDesde la barra de herramientas: presionando el ícono \nEjecutar scripts\nLa forma habitual de ejecutar el contenido de un script es línea por línea, usando alguna de las siguientes opciones:\n\nPresionando el botón  del editor de código de RStudio\nMediante el atajo de teclado Ctrl + Enter\n\nPara ejecutar una línea, simplemente ubicamos el cursor en cualquier parte de ella y presionamos el comando correspondiente. Luego de ejecutarse, el cursor avanzará automáticamente a la siguiente línea de código.\nMientras ejecutamos cada línea debemos ir observando la salida en la consola (panel inferior izquierdo) y también los cambios que se dan en el panel Environment (panel superior derecho) donde aparecerán los objetos que vayamos creando y manipulando.\nEdición de scripts\nModificar o agregar líneas al script puede hacerse directamente en el editor. Cada vez que realizamos un cambio, es necesario volver a ejecutar la línea o bloque modificado para que los cambios se reflejen en el entorno de trabajo.\nPodemos probar y modificar tantas veces como sea necesario. Sin embargo, debemos tener presente que cada manipulación en los objetos se mantiene hasta que se vuelvan a cambiar y a veces, cuando los objetos están vinculados con otras líneas de código posteriores tenemos que tener cuidado que se mantenga la consistencia del script.\nPor ejemplo: si definimos un vector numérico para realizar cálculos matemáticos, pero luego lo sobrescribimos con un valor de tipo caracter, los cálculos posteriores producirán un error y RStudio nos informará de esto en la consola.\nPor eso, es clave observar el contenido de los objetos en el panel Environment, lo que nos ayuda a evitar errores y operaciones incoherentes.\nGuardado de scripts\nCualquier agregado o modificación que hayamos realizado al script y nos interese mantener nos obligará a guardar el archivo de código editado.\nExisten distintas formas de guardar un script:\n\nDesde el menú superior: File &gt; Save\nCon el atajo de teclado: Ctrl + S\nPresionando el ícono del disquete azul 💾\n\nSi en cambio quisiera guardarlo como otro archivo para mantener el script original, podemos guardarlo con diferente nombre o en otra ubicación mediante File &gt; Save As...\nAbrir scripts existentes\nLos scripts que construyamos o nos compartan siempre tendrán extensión .R y, por lo general, se encontrarán dentro de un proyecto.\nPara abrir estos archivos .R podemos:\n\nDesde el menú superior: File &gt; Open file...\nCon el atajo de teclado: Ctrl + O\nHaciendo click sobre el archivo desde el panel Files\nPresionando el botón de la carpeta amarilla 📂\n\nEsto abrirá el script en una nueva pestaña dentro del editor de código.\n¿Cómo trabajaremos en este curso?\nEn general, utilizaremos scripts dentro de proyectos de RStudio. La secuencia recomendada será:\n\nDescargar desde el Aula Virtual un archivo comprimido conteniendo la carpeta, el proyecto, los scripts y archivos de datos.\nDescomprimir el archivo en la ubicación que deseamos (recomendamos crear una carpeta destinada al curso).\nAbrir la carpeta y ejecutar el archivo de proyecto .Rproj.\nUna vez abierto RStudio con el proyecto activo, ubicamos los scripts desde el panel Files.\nEjecutar cada línea del script, leyendo la documentación del código y observando la salida en la consola y los cambios en el entorno",
    "crumbs": [
      "Unidad 1",
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "unidad_1/primeros_pasos.html#herramientas-de-rstudio",
    "href": "unidad_1/primeros_pasos.html#herramientas-de-rstudio",
    "title": "Primeros pasos y generalidades",
    "section": "Herramientas de RStudio",
    "text": "Herramientas de RStudio\nAlgunas de las herramientas fundamentales de RStudio son el asistente de código, la ayuda en línea y el historial de comandos.\nAsistente de código\nAl escribir en el editor o la consola, la tecla Tab activa el autocompletado de funciones, nombres de objetos y argumentos, agilizando la escritura y reduciendo errores de sintaxis. En versiones recientes, el asistente también permite la previsualización de colores en los gráficos, resaltar los paréntesis de cierre en funciones anidadas con distintos colores y gestionar automáticamente la indentación del código.\n\n\n\n\nMuchas de estas opciones se pueden configurar desde el menú Code y desde Tools &gt; Global Options &gt; Code(pestañas Editing y Format).\nAyuda en línea\nAl posicionar el cursor sobre el nombre de una función en el editor y presionar F1, se accede directamente a la documentación correspondiente en el panel Help (habitualmente ubicado en la esquina inferior derecha).\n\n\n\n\nHistorial de comandos\nEn la consola, al usar las teclas de flecha arriba/abajo, se puede navegar por los comandos ejecutados durante la sesión actual. Además, el panel History (parte superior derecha) almacena los comandos de todas las sesiones previas, permitiendo reutilizarlos con un clic en To Console (Enter) o To Source (Shift + Enter), según se desee insertarlos en la consola o en el script activo.",
    "crumbs": [
      "Unidad 1",
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "unidad_1/primeros_pasos.html#atajos-de-teclado-windows",
    "href": "unidad_1/primeros_pasos.html#atajos-de-teclado-windows",
    "title": "Primeros pasos y generalidades",
    "section": "Atajos de teclado (Windows)",
    "text": "Atajos de teclado (Windows)\n\n\n\n\nMenú\nDescripción\n\n\n\nArchivo (File)\n\n\n\nCtrl + Shift + N\nCrea un nuevo script\n\n\nCtrl + O\nAbre un script guardado\n\n\nCtrl + S\nGuarda el script activo\n\n\nCtrl + W\nCierra el script activo\n\n\nCtrl + Q\nSale del programa RStudio\n\n\nEdición (Edit)\n\n\n\nCtrl + F\nAbre la ventana de búsqueda (para buscar palabras dentro de un script)\n\n\nCtrl + L\nLimpia la consola\n\n\nCódigo (Code)\n\n\n\nCtrl + Enter\nEjecuta la línea de código donde está situado el cursor\n\n\nCtrl + Alt + R\nEjecuta todo el código del script activo\n\n\nCtrl + Shift + N\nInserta nueva sección de código\n\n\nCtrl + Shift + R\nInserta nueva sección de comentarios de texto\n\n\nSesión (Session)\n\n\n\nCtrl + Shift + H\nAbre la ventana para establecer directorio de trabajo\n\n\nCtrl + Shift + F10\nReinicia la sesión de R\n\n\nHerramientas (Tools)\n\n\n\nAlt + Shift + K\nAbre la lista de ayuda de atajos de teclado",
    "crumbs": [
      "Unidad 1",
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "unidad_1/primeros_pasos.html#paquetes",
    "href": "unidad_1/primeros_pasos.html#paquetes",
    "title": "Primeros pasos y generalidades",
    "section": "Paquetes",
    "text": "Paquetes\nExisten dos formas principales de descargar paquetes: directamente desde RStudio o desde el sitio web de CRAN, descargándolos como archivos comprimidos. Si el equipo cuenta con conexión a Internet, lo más práctico es realizar la descarga directamente desde RStudio. En cambio, si no se dispone de acceso permanente a la red, es posible descargar los paquetes desde otro equipo y luego transferirlos como archivos .zip o .tar.gz al equipo donde se encuentra instalado R.\nCuando accedemos al sitio web de CRAN y buscamos un paquete específico, encontraremos información útil como una breve descripción del paquete, el número de versión, la fecha de publicación, el nombre del autor, documentación asociada y enlaces de descarga específicos para cada sistema operativo.\nDado que la mayoría de las computadoras hoy en día cuentan con acceso a Internet, en este curso nos enfocaremos en la instalación y activación de paquetes directamente desde RStudio.\nDentro del entorno de RStudio, la gestión de paquetes se realiza desde la pestaña Packages, ubicada en el panel inferior derecho. Esta interfaz facilita tareas como la instalación, actualización y activación de paquetes, y cada acción que realizamos desde la interfaz gráfica se traduce internamente en la ejecución de funciones del lenguaje R que pueden observarse en la consola.\nPara instalar un paquete nuevo, simplemente pulsamos el botón Install dentro de la pestaña Packages, lo cual abrirá una ventana emergente.\n\n\n\n\nAllí podemos escribir el nombre del paquete que deseamos instalar. Para asegurarnos de que también se descarguen e instalen automáticamente los paquetes de los que depende, es importante tildar la opción Install dependencies.\n\n\n\n\nComo alternativa, también podemos realizar la instalación desde el editor de scripts mediante el siguiente comando:\n\ninstall.packages(\"nombre_del_paquete\", \n                 dependencies = TRUE)\n\n\n\n\n\n\n\nPara facilitar la instalación de los paquetes requeridos durante el curso, recomendamos descargar el archivo “Paquetes de R necesarios”, descomprimirlo y ejecutar el script que se encuentra en su interior.",
    "crumbs": [
      "Unidad 1",
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "unidad_1/primeros_pasos.html#lectura-de-archivos-de-datos",
    "href": "unidad_1/primeros_pasos.html#lectura-de-archivos-de-datos",
    "title": "Primeros pasos y generalidades",
    "section": "Lectura de archivos de datos",
    "text": "Lectura de archivos de datos\nR permite importar tablas de datos desde diversos formatos, tanto utilizando funciones de R base como funciones provistas por paquetes específicos.\nEl formato más común es el texto plano (ASCII), donde los valores están organizados en columnas separadas por caracteres delimitadores. Los separadores más habituales incluyen:\n\nComa (,)\nPunto y coma (;)\nTabulación (\\t)\nBarra vertical (|)\n\nEstos archivos suelen tener una cabecera (header) en la primera fila con los nombres de las variables, y cada columna debe contener datos del mismo tipo (números, texto, lógicos, etc.).\nPara importar correctamente un archivo es importante conocer su estructura:\n\nSi incluye o no cabecera.\nQué carácter se usa como separador.\nEl tipo de codificación (UTF-8, Latin1, etc.).\n\nDado que son archivos de texto, pueden visualizarse con editores simples como el Bloc de Notas o desde RStudio, lo que facilita su inspección previa.\nPara cargar los datos desde un archivo de texto plano usamos el código:\n\ndatos &lt;- read.xxx(\"mis_datos.xxx\")\n\n(Se debe reemplazar read.xxx() por la función correspondiente: read.table(), read.csv(), read_delim(), read_excel(), etc., según la extensión del archivo).\nR también permite cargar bases de datos incluidas en paquetes instalados mediante:\n\ndata(nombre_datos)\n\ndatos &lt;- nombre_datos",
    "crumbs": [
      "Unidad 1",
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "unidad_1/primeros_pasos.html#buenas-prácticas",
    "href": "unidad_1/primeros_pasos.html#buenas-prácticas",
    "title": "Primeros pasos y generalidades",
    "section": "Buenas prácticas",
    "text": "Buenas prácticas\nAdoptar buenas prácticas desde el inicio mejora la reproducibilidad, facilita el trabajo colaborativo y reduce errores. Algunas recomendaciones clave son:\n\nTrabajar siempre dentro de un proyecto de RStudio (.Rproj). Esto permite organizar los archivos, mantener rutas relativas consistentes y acceder a funcionalidades específicas como control de versiones o panel de archivos integrados.\nIncluir al comienzo de cada script las líneas de activación de paquetes necesarios, utilizando la función library().\nCargar los datos una vez activados los paquetes, para garantizar que todas las funciones requeridas estén disponibles.\nDocumentar el código mediante comentarios iniciados con #. Esto permite entender qué hace cada bloque de código, facilitando futuras modificaciones o revisiones.\nUsar espacios e indentación adecuada para mejorar la legibilidad. Esto es especialmente importante en estructuras anidadas (como condicionales, bucles o funciones).\n\nUna guía de estilo ampliamente recomendada —aunque no oficial— es la de tidyverse. Incluye ejemplos concretos de buenas y malas prácticas para nombrar variables, manejar líneas largas, usar sangrías, entre otros aspectos. Al final de la unidad incluimos una versión resumida de la misma, pero puede consultarse completa en:\n➡️ https://style.tidyverse.org/",
    "crumbs": [
      "Unidad 1",
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html",
    "href": "unidad_1/intro_R.html",
    "title": "Introducción a R",
    "section": "",
    "text": "Artwork por @allison_horst",
    "crumbs": [
      "Unidad 1",
      "Introducción a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#qué-es-r",
    "href": "unidad_1/intro_R.html#qué-es-r",
    "title": "Introducción a R",
    "section": "¿Qué es R?",
    "text": "¿Qué es R?\nEl sitio oficial r-project.org define a R como “un entorno de software libre para gráficos y computación estadística. Se compila y se ejecuta en una amplia variedad de plataformas UNIX, Windows y MacOS.”\nProfundizando en su descripción, podemos decir que R es un lenguaje de programación interpretado, orientado a objetos, multiplataforma y de código abierto (open source) aplicado al manejo y análisis de datos estadísticos.\nA continuación, detallamos cada una de sus características:\nR es un lenguaje de programación estadístico\nSi bien posee un entorno y se puede utilizar como calculadora avanzada o para simulaciones, R es fundamentalmente un lenguaje de programación. Presenta una estructura y reglas de sintaxis propias, así como gran variedad de funciones desarrolladas con fines estadísticos.\nR es un lenguaje orientado a objetos\nR implementa conceptos de la programación orientada a objetos, lo cual le permite ofrecer simpleza y flexibilidad en el manejo de datos. En R, todo con lo que trabajamos —variables, funciones, datos, resultados— son objetos que pueden ser modificados o combinados con otros objetos.\nR es un lenguaje interpretado\nR no requiere compilación previa. Los scripts se ejecutan directamente mediante el intérprete del lenguaje, que devuelve resultados de forma inmediata.\nR es un lenguaje multiplataforma\nR puede instalarse y utilizarse en sistemas operativos Linux, Windows y MacOS. En todos ellos funciona de la misma manera, lo que garantiza que los scripts pueden correr en cualquier plataforma sin necesidad de modificaciones.\nR es software libre y de código abierto\nR se distribuye gratuitamente bajo licencia GNU - GPL (General Public License), lo que otorga a los usuarios la libertad de usar, estudiar, compartir y modificar el software. Esto ha favorecido el crecimiento de una comunidad global activa y colaborativa.",
    "crumbs": [
      "Unidad 1",
      "Introducción a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#breve-historia-del-lenguaje",
    "href": "unidad_1/intro_R.html#breve-historia-del-lenguaje",
    "title": "Introducción a R",
    "section": "Breve historia del lenguaje",
    "text": "Breve historia del lenguaje\nR tiene su origen en el lenguaje S, desarrollado en los años 70 en los laboratorios Bell de AT&T (actualmente Lucent Technologies). Posteriormente, S dio lugar a una versión comercial llamada S-Plus, distribuida por Insightful Corporation.\nEn 1995, los profesores de estadística Ross Ihaka y Robert Gentleman, de la Universidad de Auckland (Nueva Zelanda) iniciaron el “Proyecto R”, con la intención de desarrollar un programa estadístico inspirado en el lenguaje S pero de dominio público.\nAunque R es considerado un dialecto de S, existen diferencias importantes en el diseño de ambos lenguajes.\nEl software está desarrollado principalmente en lenguaje C++, con algunas rutinas en Fortran. El nombre “R” hace referencia a las iniciales de sus creadores: Ross y Robert. Actualmente, R es mantenido por un grupo internacional de desarrolladores voluntarios conocido como el Core Development Team.",
    "crumbs": [
      "Unidad 1",
      "Introducción a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#scripts-de-r",
    "href": "unidad_1/intro_R.html#scripts-de-r",
    "title": "Introducción a R",
    "section": "Scripts de R",
    "text": "Scripts de R\nUn script es un archivo de texto plano que contiene una secuencia de instrucciones para ser ejecutadas por el intérprete de R.\nEl término script puede traducirse como guión, archivo de órdenes, archivo de procesamiento por lotes o archivo de sintaxis.\nPuede crearse con cualquier editor de texto o con entornos especializados, y permite ser leído, modificado, guardado y ejecutado de forma completa o línea por línea.\nUna de sus principales ventajas es su reutilización: los scripts pueden adaptarse fácilmente a distintos análisis o contextos, lo que facilita la replicabilidad del trabajo.",
    "crumbs": [
      "Unidad 1",
      "Introducción a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#características-generales-del-lenguaje",
    "href": "unidad_1/intro_R.html#características-generales-del-lenguaje",
    "title": "Introducción a R",
    "section": "Características generales del lenguaje",
    "text": "Características generales del lenguaje\nR posee una sintaxis textual precisa. Como en otros lenguajes de programación, la escritura debe ser exacta: distingue entre mayúsculas y minúsculas (case sensitive), y cada línea escrita en la consola comienza con el símbolo &gt; (prompt1).",
    "crumbs": [
      "Unidad 1",
      "Introducción a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#documentación-del-código",
    "href": "unidad_1/intro_R.html#documentación-del-código",
    "title": "Introducción a R",
    "section": "Documentación del código",
    "text": "Documentación del código\nLa documentación es una tarea fundamental en cualquier lenguaje de programación, ya que nos permite entender el propósito del script, facilita su mantenimiento y posibilita su reutilización tanto por quien lo creó como por otras personas.\nEn R, la documentación de los scripts se realiza a través de comentarios, indicados con el símbolo #. Todo lo que sigue a ese símbolo es ignorado por el intérprete cuando se ejecute el código:\n\n# esto es una línea de comentario y el intérprete no la ejecuta\n\nAsí que a la hora de documentar es preferible abusar de estos comentarios que no utilizarlos.",
    "crumbs": [
      "Unidad 1",
      "Introducción a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#funciones",
    "href": "unidad_1/intro_R.html#funciones",
    "title": "Introducción a R",
    "section": "Funciones",
    "text": "Funciones\nLas órdenes elementales en R se denominan comandos o funciones. Algunas se conocen como “integradas” ya que están incluidas en el núcleo del lenguaje (R base) y otras provienen de paquetes adicionales.\nLa mayoría de las ofrecidas en los paquetes o librerías están elaboradas con R, dado que todos los usuarios podemos crear nuevas funciones con el mismo lenguaje.\nToda función tiene un nombre y puede recibir argumentos (obligatorios u opcionales), que se colocan entre paréntesis y separados por comas. Incluso algunas funciones que no tienen asociado argumentos necesitan, en su sintaxis, a los paréntesis ().\nSiempre una función devuelve un resultado, un valor o realiza una acción:\n\nnombre_de_la_función(arg_1, arg_2, arg_n)\n\nComo el interprete de R no permite errores en la sintaxis de las expresiones, debemos atender a los siguientes puntos a la hora de escribirlas:\nLa sintaxis habitual de una función es la siguiente:\n\nfuncion(arg1, arg2, arg3,...)\n\nLos títulos de los argumentos pueden escribirse y mediante un igual agregar el valor correspondiente:\n\nfuncion(arg1 = 32, arg2 = 5, arg3 = 65,...)\n\nSe puede omitir el título del argumento y escribir directamente el valor, pero en este caso, hay que respetar el orden definido por la función:\n\nfuncion(32, 5, 65,...)\n\nLos valores numéricos, lógicos, especiales y objetos van escritos en forma directa y cuando escribimos caracteres (texto) van necesariamente encerrados entre comillas:\n\nfuncion(arg1 = 3, arg2 = NA, arg3 = TRUE, arg4 = \"less\", arg5 = x, ...)",
    "crumbs": [
      "Unidad 1",
      "Introducción a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#paquetes-o-librerías",
    "href": "unidad_1/intro_R.html#paquetes-o-librerías",
    "title": "Introducción a R",
    "section": "Paquetes o librerías",
    "text": "Paquetes o librerías\nLos paquetes, también conocidos como librerías, son conjuntos de funciones, datos y documentación organizados organizadas en torno a una temática específica, que permiten ampliar las capacidades del sistema base de R.\nAl instalar R, se incorpora un núcleo básico que queda activo automáticamente en cada sesión (base, datasets, graphics, grDevices, methods, stats y utils). Junto a este núcleo, se incluye un conjunto de paquetes recomendados que forman parte de la distribución oficial y pueden activarse manualmente cuando se los necesita. No obstante, la verdadera potencia de R reside en la posibilidad de incorporar nuevos paquetes desarrollados por la comunidad, lo que permite extender continuamente sus funcionalidades.\n\n\n\n\nEn la actualidad, existen más de 17.000 paquetes disponibles para una amplia variedad de aplicaciones, número que crece mes a mes gracias a la naturaleza open source del lenguaje. Cualquier persona puede desarrollar y compartir sus propios paquetes, aunque no todos llegan a publicarse en el repositorio oficial CRAN (Comprehensive R Archive Network), que actúa como principal fuente de distribución.\nLos paquetes pueden descargarse directamente desde CRAN o instalarse a partir de archivos comprimidos locales (como .zip o .tar.gz). Una vez instalados, se los puede activar en cualquier análisis.\nDependencias\nEn muchos casos, al utilizar un paquete, este necesita de otros para funcionar correctamente. Esta relación se conoce como dependencia, y es una característica central en el ecosistema de R.\nLa mayoría de las funciones incluidas en los paquetes están desarrolladas en el propio lenguaje R y, durante su construcción, es habitual que recurran a funciones ya existentes en otros paquetes. Por ejemplo, una función nueva puede hacer uso de una función auxiliar que no pertenece al sistema base, sino a otro paquete externo.\nCuando intentamos ejecutar una función que depende de otras no disponibles en nuestra instalación, R no podrá encontrar esas funciones y nos devolverá un mensaje de error indicando que no reconoce el nombre solicitado. Este tipo de errores suele alertar sobre funciones “desconocidas” o “no encontradas”, lo que indica que falta instalar o activar alguno de los paquetes requeridos.\nPara evitar estos inconvenientes, R intenta resolver automáticamente las dependencias cuando instalamos un paquete desde el repositorio oficial CRAN. Si el paquete necesita otros para funcionar, el sistema detecta esta relación y se encarga de instalar también aquellos paquetes auxiliares. De todos modos, si alguno no se instala correctamente o no se activa en la sesión, será necesario hacerlo de forma manual.",
    "crumbs": [
      "Unidad 1",
      "Introducción a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#errores-y-advertencias",
    "href": "unidad_1/intro_R.html#errores-y-advertencias",
    "title": "Introducción a R",
    "section": "Errores y advertencias",
    "text": "Errores y advertencias\nEl lenguaje R es muy preciso en su sintaxis. Cometer errores al escribir funciones u objetos es común durante el aprendizaje, y el intérprete de R devuelve mensajes de error cuando detecta algo incorrecto.\nUno de los aspectos clave a tener en cuenta es que R distingue entre mayúsculas y minúsculas (case sensitive), por lo que no es lo mismo escribir a que A.\nExisten tres grupos de mensajes de error:\n\nErrores de sintaxis\nError de objeto no encontrado\nOtros errores\n\nErrores de sintaxis\nOcurre cuando R no puede interpretar una línea de código porque algo está mal escrito. Los errores de sintaxis más frecuentes incluyen:\n\nParéntesis, comas, comillas, corchetes o llaves mal colocados o ausentes.\nArgumentos mal separados o incorrectamente definidos.\n\nPor ejemplo la función rep() repite valores una cantidad de veces. Tiene dos argumentos, x donde se coloca el valor a repetir y times donde se define la cantidad de veces:\n\nrep(x = 3, times = 4) # repetimos 4 veces 3 con rep()\n\n[1] 3 3 3 3\n\n\nSi nos olvidamos de cerrar el paréntesis:\n\nrep(x = 3, times = 4\n\nError in parse(text = input): &lt;text&gt;:2:0: unexpected end of input\n1: rep(x = 3, times = 4\n   ^\n\n\nSi omitimos la coma entre argumentos:\n\nrep(x = 3 times = 4)\n\nError in parse(text = input): &lt;text&gt;:1:11: unexpected symbol\n1: rep(x = 3 times\n              ^\n\n\nSi usamos un nombre de argumento no válido:\n\nrep(y = 3, times = 4)\n\nError in rep(y = 3, times = 4): attempt to replicate an object of type 'symbol'\n\n\nSi escribimos mal el nombre de la función:\n\nrop(x = 3, times = 4)\n\nError in rop(x = 3, times = 4): could not find function \"rop\"\n\n\nEste último error se asemeja a un error de objeto no encontrado, aunque tiene origen en un problema de sintaxis.\nLos mensajes de error en general y sobre todo al principio pueden parecer extraños y difíciles de entender, pero con un poco de práctica podemos inferir donde está el problema.\nError de objeto no encontrado\nEste tipo de error se produce cuando R no reconoce un objeto utilizado en el código. Las causas más frecuentes incluyen:\n\nEl nombre del objeto está mal escrito (por ejemplo, errores de sintaxis o uso incorrecto de mayúsculas/minúsculas).\nEl objeto pertenece a un paquete o archivo que no fue cargado.\nFaltan comillas al declarar caracteres.\nOtras causas similares.\n\nVolvamos al ejemplo anterior, ahora repitiendo un valor tipo character:\n\nrep(x = \"A\", times = 4) # repetimos 4 veces \"A\" con rep()\n\n[1] \"A\" \"A\" \"A\" \"A\"\n\n\nSi olvidamos las comillas:\n\nrep(x = A, times = 4) # repetimos 4 veces A con rep()\n\nError: object 'A' not found\n\n\nOtros errores\nSon aquellos que se generan por causas distintas a errores de sintaxis o de objeto no encontrado. Por ejemplo:\n\n\"x\" + 10\n\nError in \"x\" + 10: non-numeric argument to binary operator\n\n\nEl código anterior genera un mensaje de error porque intenta sumar objetos de tipos incompatibles entre sí.\nVeamos otro ejemplo:\n\nt.test(1)\n\nError in t.test.default(1): not enough 'x' observations\n\n\nEn este caso, el error se debe a que no hay suficientes observaciones para realizar una prueba \\(t\\) de Student.\nOtro caso frecuente ocurre cuando se intenta acceder a una posición inexistente en un vector:\n\nx &lt;- c(1, 2, 3)\nx[[5]]\n\nError in x[[5]]: subscript out of bounds\n\n\nEste mensaje de error indica que el subíndice está fuera de los límites del objeto (subscript out of bounds).\nAdvertencias\nLas advertencia no son tan serias como un error, o al menos no lo parece, ya que permiten el código se ejecute igual. Pero puede ocurrir que ignorar una advertencia llegue a ser algo muy serio, si esto implica que la salida de la función es equivocada.\nIgnorar advertencias puede llevar a conclusiones erróneas, por lo que es recomendable prestarles atención y entender su causa.\nPor ejemplo:\n\nlog(-1)\n\nWarning in log(-1): NaNs produced\n\n\n[1] NaN\n\n\nla función genera una advertencia porque el logaritmo de un número negativo no está definido en los reales, y R devuelve un valor NaN (Not a Number).\nResumiendo…",
    "crumbs": [
      "Unidad 1",
      "Introducción a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#creación-de-objetos",
    "href": "unidad_1/intro_R.html#creación-de-objetos",
    "title": "Introducción a R",
    "section": "Creación de objetos",
    "text": "Creación de objetos\nTodas las declaraciones donde se crean objetos usan el símbolo de asignación &lt;-:\n\nnombre_objeto &lt;- valor\n\nVeámoslo en un ejemplo:\n\na &lt;- 1\n\nEn este caso asignamos el valor 1 al objeto a. El objeto a es un vector de una posición (un solo valor). Si llamamos al objeto, el intérprete devuelve el valor asignado previamente:\n\na\n\n[1] 1\n\n\nObservemos que, además de devolvernos el valor, aparece delante un número entre corchetes [1]. Este número es la ubicación o índice del comienzo del objeto. En este caso, como el vector tiene una sola posición, indica que el primer valor mostrado empieza en la posición 1.",
    "crumbs": [
      "Unidad 1",
      "Introducción a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#estructuras-de-datos",
    "href": "unidad_1/intro_R.html#estructuras-de-datos",
    "title": "Introducción a R",
    "section": "Estructuras de datos",
    "text": "Estructuras de datos\nLos objetos contenedores de datos más simples pertenecen a cinco clases atómicas, que son:\n\ninteger (números enteros)\nnumeric (números reales)\ncomplex (números complejos)\ncharacter (cadenas de caracteres)\nlogical (valores lógicos: TRUE o FALSE)\n\n\n\n\n\nSin embargo, cada una de estas clases de datos no se encuentran de manera aislada, sino encapsuladas dentro de la clase de objeto más básica de R, a la que se denomina vector.\nEn RStudio, el sistema de colores ayuda a distinguir los tipos de valores:\n\n# Número\n1111\n\n[1] 1111\n\n# Caracter\n\"esto es una cadena de texto\"\n\n[1] \"esto es una cadena de texto\"\n\n# Lógico\nTRUE\n\n[1] TRUE\n\n# Objeto\na &lt;- 1\n\nVectores\nUn vector es un conjunto de valores (números o símbolos), del mismo tipo ordenados de la forma (elemento 1, elemento 2, … , elemento \\(n\\)), donde \\(n\\) es la longitud o tamaño del vector.\nLos atributos principales son:\n\nTipo: puede ser integer, numeric, character, complex o logical.\nLongitud: cantidad de elementos que contiene el objeto,\n\nEl vector más simple contiene un solo dato, por ejemplo un vector de longitud 1 y tipo numeric:\n\nvec1 &lt;- 1\nvec1\n\n[1] 1\n\n\nOtro vector más grande por ejemplo podría ser (1, 5, 2). En este caso también es del tipo numeric pero tiene una longitud de 3 elementos:\n\nvec2 &lt;- c(1, 5, 2)\nvec2\n\n[1] 1 5 2\n\n\nPara concatenar elementos usamos la función c(), dentro de la cual van los valores separados por comas. El orden de los elementos importa, en nuestro ejemplo la primera posición la ocupa el 1, la segunda el 5 y la tercera el 2. Si tuvieramos otro vector (5, 1, 2), no sería lo mismo porque los valores están ordenados de forma diferente.\nPara conocer la longitud del vector usamos:\n\nlength(vec2)\n\n[1] 3\n\n\nNos informa que vec2 tiene 3 elementos.\nPara conocer el tipo de dato ejecutamos:\n\nclass(vec2)\n\n[1] \"numeric\"\n\n\nPodemos ver que los datos almacenados en este segundo ejemplo cumplen con la definición en lo que respecta al tipo de dato, ya que cada elemento es del mismo tipo (numeric).\nVeamos un ejemplo de asignación de otro tipo de dato atómico, como es el character:\n\nvec3 &lt;- \"Hola\"\nvec3\n\n[1] \"Hola\"\n\n\nSiempre que escribamos contenido de tipo character debemos hacerlo entre comillas. En este caso generamos el vector vec3 con el contenido \"Hola\", que, a pesar de ser una palabra compuesta de varios caracteres, dentro del vector vec3 esta ocupa una sola posición:\n\nlength(vec3)\n\n[1] 1\n\n\nRespecto al tipo de dato si usamos la función class() tendremos:\n\nclass(vec3)\n\n[1] \"character\"\n\n\nFactores\nUn factor es un objeto especialmente diseñado para contener datos categóricos y se asocia particularmente con las variables cualitativas.\nEn su estructura interna está compuesto por dos vectores:\n\nUn vector de índices enteros.\nUn vector de categorías (niveles) de tipo character, a los que hace referencia el primer vector.\n\nExisten de dos tipos: factores nominales y factores ordinales. En el caso del segundo se establece un orden en los niveles.\nNormalmente, obtenemos un tipo factor de convertir un vector u otro tipo de objeto con caracteres, pero para mostrar un ejemplo lo realizamos con la función factor():\n\nfactor1 &lt;- factor(x = c(\"a\", \"b\", \"a\", \"c\", \"b\", \"a\"), \n                  levels = c(\"a\", \"b\", \"c\"))\nfactor1\n\n[1] a b a c b a\nLevels: a b c\n\n\nCreamos el objeto factor1 con 6 elementos caracteres y tres niveles sin orden.\nAdemás de la practicidad de trabajar con factores, muchas funciones de R requieren que las variables categóricas estén en formato factor para funcionar correctamente.\nDataframe\nUn dataframe es un objeto diseñado para contener conjuntos de datos y representa una estructura bidimensional similar a una tabla, con filas y columnas. Cada columna puede almacenar elementos de distintos tipos (por ejemplo, numéricos, de texto o lógicos), siempre que todos tengan la misma longitud.\nLas columnas suelen tener nombres únicos, lo que permite referenciarlas fácilmente como si fueran variables individuales dentro del conjunto de datos.\nEste es el tipo de objeto que se utiliza habitualmente para almacenar información importada desde archivos externos (por ejemplo, archivos de texto separados por comas o planillas de Excel), y con el que más frecuentemente trabajamos en los análisis.\nDesde el punto de vista estructural, un dataframe está compuesto por una serie de vectores de igual longitud dispuestos verticalmente, uno al lado del otro, conformando las columnas de la tabla.\nVeamos un ejemplo:\n\n# Historia clínica\nHC &lt;- c(\"F324\", \"G21\", \"G34\", \"F231\")\n\n# Edad\nedad &lt;- c(34, 32, 34, 54)\n\n# Sexo\nsexo &lt;- c(\"M\", \"V\", \"V\", \"M\")\n\n# dataframe\ndf1 &lt;- data.frame(HC, edad, sexo)\n\ndf1\n\n    HC edad sexo\n1 F324   34    M\n2  G21   32    V\n3  G34   34    V\n4 F231   54    M\n\n\nCreamos tres vectores con datos de supuestos individuos, su historia clinica, la edad y el sexo. Luego mediante la función data.frame() “unimos” esos vectores en forma vertical para formar un dataframe de 3 variables y 4 observaciones.\n\n\n\n\n\n\nExisten otras estructuras de datos que aparecen en la siguiente figura. Las más habituales en nuestro trabajo son los vectores y los dataframes. Los factores serán necesarios cuando tengamos que especificar distintos órdenes de niveles.",
    "crumbs": [
      "Unidad 1",
      "Introducción a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#operadores",
    "href": "unidad_1/intro_R.html#operadores",
    "title": "Introducción a R",
    "section": "Operadores",
    "text": "Operadores\nAdemás de funciones, el lenguaje R cuenta con operadores de uso relativamente intuitivo, que permiten realizar operaciones de diferentes tipos con los objetos que contienen datos.\nOperadores aritméticos\n\n\n\n\nOperador\nDescripción\n\n\n\n+\nSuma\n\n\n-\nResta\n\n\n*\nMultiplicación\n\n\n/\nDivisión\n\n\n^\nPotencia\n\n\n%%\nMódulo\n\n\n%/%\nDivisión de enteros\n\n\n\n\n\nLos operadores aritméticos se utilizan como si el lenguaje fuese una calculadora:\n\n# Suma\n2 + 5\n\n[1] 7\n\n# Resta\n3 - 2\n\n[1] 1\n\n# Multiplicación\n9 * 3\n\n[1] 27\n\n# División\n10 / 2\n\n[1] 5\n\n# Potencia\n5 ^ 2\n\n[1] 25\n\n\nTambién se pueden hacer operaciones con los objetos que almacenan valores numéricos:\n\na &lt;- 3\n\nb &lt;- 6\n\n(a + b) * b\n\n[1] 54\n\n\nY funciona con objetos con más de un elemento, aplicando aritmética vectorial, donde las operaciones se realizan elemento a elemento:\n\na &lt;- c(1, 2, 3)\n\na * 3\n\n[1] 3 6 9\n\n\nO bien, con operaciones entre los objetos, donde se realiza entre los elementos de la misma posición:\n\na &lt;- c(1, 2, 3)\n\na * a\n\n[1] 1 4 9\n\n\nOperadores relacionales\n\n\n\n\nOperador\nDescripción\n\n\n\n&lt;\nMenor que\n\n\n&gt;\nMayor que\n\n\n&lt;=\nMenor o igual que\n\n\n&gt;=\nMayor o igual que\n\n\n==\nIgual que\n\n\n!=\nNo igual que\n\n\n\n\n\nHabitualmente estos operadores se utilizan asiduamente en expresiones para indicar relaciones entre valores.\nPodemos ver su funcionamiento en el ejemplo siguiente:\n\na &lt;- c(3, 8, 2)\n\na == c(3, 4, 5)\n\n[1]  TRUE FALSE FALSE\n\n\nEl lenguaje evalúa las comparaciones que hace el operador relacional igual (en este caso) y en aquellos valores que coinciden devuelve TRUE y en los que no hay coincidencia devuelve FALSE.\nLo mismo sucede con los otros operadores relacionales:\n\na &lt;- c(4, 8, 10)\n\na &gt; 8\n\n[1] FALSE FALSE  TRUE\n\na &lt; 8\n\n[1]  TRUE FALSE FALSE\n\na != 8\n\n[1]  TRUE FALSE  TRUE\n\n\nOperadores lógicos\n\n\n\n\nOperador\nDescripción\n\n\n\n!\nNOT\n\n\n&\nAND booleano\n\n\n&&\nAND booleano para vectores de longitud 1\n\n\n|\nOR booleano\n\n\n||\nOR booleano para vectores de longitud 1\n\n\n\n\n\nCuando queremos conectar algunas de las expresiones relacionales hacemos uso de estos operadores lógicos típicos (AND, OR, NOT).\nPara ejemplificar podemos hacer:\n\na &lt;- c(1:8)\n\na\n\n[1] 1 2 3 4 5 6 7 8\n\n(a &gt; 3) & (a &lt; 7)\n\n[1] FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE\n\n\nEn el caso anterior usamos el operador & como conector AND de dos expresiones relacionales donde el lenguaje devuelve TRUE en el rango mayor a 3 y menor a 7 (valores 4,5 y 6).",
    "crumbs": [
      "Unidad 1",
      "Introducción a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#valores-especiales",
    "href": "unidad_1/intro_R.html#valores-especiales",
    "title": "Introducción a R",
    "section": "Valores especiales",
    "text": "Valores especiales\nExisten algunos valores especiales para datos con expresiones reservadas en R, entre ellos encontramos los valores NA, NaN, Inf y NULL.\n\n\n\n\nOperador\nSignificado\nDescripción\n\n\n\nNA\nNot available\nEs la forma de expresar a los valores perdidos o faltantes (missing values)\n\n\nNaN\nNot a number\nUtilizado para resultados de operaciones que devuelven error numérico\n\n\nInf\nInfinity\nValor infinito (positivo)\n\n\n-Inf\nInfinity\nValor infinito (negativo)\n\n\nNULL\nNull\nValor nulo\n\n\n\n\n\nEl más relevante de estos valores especiales es el NA que sirve para indicar que no hay valor en esa posición o elemento de un objeto.",
    "crumbs": [
      "Unidad 1",
      "Introducción a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#secuencias-regulares",
    "href": "unidad_1/intro_R.html#secuencias-regulares",
    "title": "Introducción a R",
    "section": "Secuencias regulares",
    "text": "Secuencias regulares\nAdemás de concatenar elementos con la función c(), existen tres formas comunes de generar secuencias regulares.\nLa primera es mediante un operador secuencial (:), que genera una secuencia de enteros entre dos valores, ya sea en forma ascendente o descendente:\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n10:1\n\n [1] 10  9  8  7  6  5  4  3  2  1\n\n\nLa segunda forma es mediante la función seq(), cuyos argumentos principales son from, to y by. Esta función permite mayor flexibilidad:\n\nseq(from = 1, to = 20, by = 2)\n\n [1]  1  3  5  7  9 11 13 15 17 19\n\n\nEl ejemplo anterior genera una secuencia de números que comienza en 1 y llega hasta 20, avanzando de dos en dos.\nAlgunos otros ejemplos de la misma función:\n\nseq(from = 0.1, to = 0.9, by = 0.1)\n\n[1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9\n\nseq(from = -5, to = 5, by = 1)\n\n [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n\nseq(from = 300, to = 0, by = -50)\n\n[1] 300 250 200 150 100  50   0\n\n\nLa tercera opción es la función rep(), que permite duplicar valores. Su forma más básica es rep(x, times = n), donde se repite el valor x la cantidad de veces indicada por n.\nAlgunos ejemplos:\n\nrep(x = 2, times = 5)\n\n[1] 2 2 2 2 2\n\n# combinada con el operador :\nrep(1:4, 5)  \n\n [1] 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4\n\n# combinada con la función c()\nrep(c(4.5, 6.8, 7.2), 2) \n\n[1] 4.5 6.8 7.2 4.5 6.8 7.2",
    "crumbs": [
      "Unidad 1",
      "Introducción a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#índices",
    "href": "unidad_1/intro_R.html#índices",
    "title": "Introducción a R",
    "section": "Índices",
    "text": "Índices\nR implementa una forma eficiente y flexible de acceder selectivamente a elementos de un objeto basado en una indexación interna.\nPara acceder a un índice se utiliza la notación de corchetes. Por ejemplo, si tenemos un vector x con varios elementos y queremos acceder al segundo, usamos x[2].\nEsta forma de indexar los elementos de los distintos objetos nos permite realizar muchas operaciones desde el simple llamado, hasta seleccionar, eliminar o modificar valores.\nVeamos algunos ejemplos:\n\n# generamos un vector x con 5 letras\nx &lt;- c(\"a\",\"b\",\"c\",\"d\",\"e\")\n\n# llamamos a la primer posición y nos devuelve su valor \nx[1]\n\n[1] \"a\"\n\n# llamamos a la tercer posición y nos devuelve su valor\nx[3]    \n\n[1] \"c\"\n\n# llamamos a las posiciones 1 y 3 juntas mediante c()\nx[c(1,3)]   \n\n[1] \"a\" \"c\"\n\n# llamamos a las posiciones menos la 1 y la 4\nx[-c(1, 4)] \n\n[1] \"b\" \"c\" \"e\"\n\n# creamos otro vector y con los valores 1,2 y 5\ny &lt;- c(1, 2, 5) \n\n# utilizamos el vector y como índice    \nx[y]        \n\n[1] \"a\" \"b\" \"e\"\n\n# asignamos el valor “h” a la posición 2 del vector x\nx[2] &lt;- \"h\" \n\nx\n\n[1] \"a\" \"h\" \"c\" \"d\" \"e\"\n\n# creamos el vector z eliminando la posición 5 de x\nz &lt;- x[-5]  \n\nz\n\n[1] \"a\" \"h\" \"c\" \"d\"\n\n\nEstos ejemplos muestran las múltiples posibilidades que ofrece el uso de índices para manipular objetos en R, lo que hace al lenguaje muy poderoso y versátil.\nCuando se aplican índices a estructuras bidimensionales, como matrices o dataframes, la notación general es:\n\nnombre[índice de fila, índice de columna]",
    "crumbs": [
      "Unidad 1",
      "Introducción a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#gestión-de-factores",
    "href": "unidad_1/intro_R.html#gestión-de-factores",
    "title": "Introducción a R",
    "section": "Gestión de factores",
    "text": "Gestión de factores\nAl presentar las distintas estructuras de datos mencionamos que los factores suelen generarse a partir de vectores u otros objetos de tipo carácter.\nPara entender cómo funcionan, partamos de un vector con datos categóricos:\n\nrespuesta &lt;- c(\"Si\", \"No\", \"No\", \"Si\", \"Si\", \"Si\", \"No\")\n\nCreamos un vector llamado respuesta con 7 elementos de tipo carácter, en el que se repiten las categorías \"Si\" y \"No\".\nPodemos confirmar que se trata de un vector y que su contenido es de tipo carácter:\n\n# preguntamos si sexo es un vector\nis.vector(respuesta) \n\n[1] TRUE\n\n# visualizamos el tipo de dato de sexo\nclass(respuesta)  \n\n[1] \"character\"\n\n\nPara crear un factor a partir de este vector debemos utilizar la función factor():\n\nrespuesta &lt;- factor(respuesta)\n\nrespuesta\n\n[1] Si No No Si Si Si No\nLevels: No Si\n\n\nEn la salida observamos los siete elementos y, debajo, una línea con los niveles del factor, indicados por Levels. Estos niveles son identificados automáticamente.\nPodemos verificar cómo cambió el tipo de objeto:\n\n# preguntamos si respuesta es un vector\nis.vector(respuesta) \n\n[1] FALSE\n\n# preguntamos si respuesta es un factor\nis.factor(respuesta) \n\n[1] TRUE\n\n# visualizamos el tipo de dato de respuesta\nclass(respuesta) \n\n[1] \"factor\"\n\n\nAunque visualmente vemos palabras, internamente R trata al factor como un tipo especial basado en números. ¿Por qué sucede esto? Veámoslo con más detalle:\n\nstr(respuesta)\n\n Factor w/ 2 levels \"No\",\"Si\": 2 1 1 2 2 2 1\n\n\nLa función str() devuelve la estructura interna del objeto. En este caso, muestra que respuesta tiene dos niveles y que cada elemento del vector es representado por un número (1 o 2), donde 1 corresponde a \"No\" y 2 a \"Si\".\nEsto significa que la estructura de los factores está compuesta por dos vectores: uno numérico que funciona como índice de enteros, que sustituye al vector de caracteres original, y el otro es un vector de caracteres, que contiene los niveles o categorías, a los que hace referencia el primer vector.\nPara ver solo los niveles o categorías del factor podemos usar:\n\nlevels(respuesta)\n\n[1] \"No\" \"Si\"\n\n\nEn los factores nominales donde no importa el orden, la función factor() implementa el orden alfabético para determinar a qué índice numérico pertenece cada categoría. Es claro en el ejemplo que a No le asigna el 1 y a Si el 2.\nPero si nos encontramos frente a una variable cualitativa ordinal vamos a necesitar indicarle a la función cual es el orden de las categorías.\nVamos al siguiente ejemplo:\n\nsalud &lt;- c(4, 3, 1, 3, 2, 2, 3, 3, 1)\nsalud\n\n[1] 4 3 1 3 2 2 3 3 1\n\n\nTenemos en el vector salud algunos códigos numéricos que representan nivel de salud de personas registradas por una encuesta donde 1 significa mala salud, 2 regular, 3 buena y 4 muy buena.\nProcedemos a crear el factor nivsalud a partir de este vector:\n\nnivsalud &lt;- factor(salud,\n                   label = c(\"Mala\", \"Regular\", \"Buena\", \"Muy buena\"),\n                   levels = 1:4)\n\nnivsalud\n\n[1] Muy buena Buena     Mala      Buena     Regular   Regular   Buena    \n[8] Buena     Mala     \nLevels: Mala Regular Buena Muy buena\n\n\nAquí utilizamos dos argumentos adicionales:\n\nlabels: define las etiquetas que queremos mostrar para cada categoría.\nlevels: indica el orden de los niveles originales (en este caso, 1 a 4).\n\nAquí es necesario definir estos argumentos porque, a diferencia del factor respuesta, el vector salud contiene números en lugar de las palabras correspondientes a las categorías.\nHasta aquí hemos creado un factor pero si miramos sus niveles no encontraremos señales que sigan un orden específico:\n\nlevels(nivsalud)\n\n[1] \"Mala\"      \"Regular\"   \"Buena\"     \"Muy buena\"\n\n\nSin embargo, aún no hemos definido un orden explícito entre las categorías. Para hacerlo, agregamos el argumento ordered = TRUE:\n\nnivsalud &lt;- factor(salud,\n                   label = c(\"Mala\", \"Regular\", \"Buena\", \"Muy buena\"),\n                   levels = 1:4, \n                   ordered = TRUE)\n\nnivsalud\n\n[1] Muy buena Buena     Mala      Buena     Regular   Regular   Buena    \n[8] Buena     Mala     \nLevels: Mala &lt; Regular &lt; Buena &lt; Muy buena\n\n\nAl incorporar este argumento, estamos diciendo que los niveles tienen orden natural. Esto puede observarse en la salida donde se muestra que \"Mala\" &lt; \"Regular\" &lt; \"Buena\" &lt; \"Muy buena\".",
    "crumbs": [
      "Unidad 1",
      "Introducción a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#gestión-de-dataframes",
    "href": "unidad_1/intro_R.html#gestión-de-dataframes",
    "title": "Introducción a R",
    "section": "Gestión de dataframes",
    "text": "Gestión de dataframes\nEn R, la estructura utilizada para almacenar datos provenientes de fuentes externas (como archivos .csv, planillas de cálculo, bases SQL, etc.) es el dataframe.\nA modo de ejemplo, vamos a construir un dataframe llamado datos con 4 variables y 5 observaciones. Las variables serán:\n\nid: identificador numérico entero y correlativo.\nedad: edad en años.\nsexo: codificado como \"V\" para varón y \"M\" para mujer.\ntrabaja: variable lógica, donde TRUE (T) representa que la persona trabaja y FALSE (F) que no lo hace.\n\n\n# construimos el vector id\nid &lt;- 1:5\n\n# construimos el vector edad\nedad &lt;- c(23, 43, 12, 65, 37)\n\n# construimos el vector sexo\nsexo &lt;- c(\"V\", \"M\", \"M\", \"V\", \"M\")\n\n# construimos el vector trabaja\ntrabaja &lt;- c(T, T, F, F, T)\n\n# construimos el dataframe datos\ndatos &lt;- data.frame(id, edad, sexo, trabaja)\n\nAunque para el ejemplo construimos un dataframe manualmente, lo habitual en la práctica es leer archivos externos que se importan directamente como dataframes.\nAlgunas de las funciones generales que podemos aplicar son:\n\n# pedimos el número de columnas (variables)\nncol(datos)\n\n[1] 4\n\n# pedimos el número de filas (registros u observaciones)\nnrow(datos)\n\n[1] 5\n\n# pedimos las dimensiones del dataframe (observaciones,variables)\ndim(datos)\n\n[1] 5 4\n\n\nTambién podemos visualizar como se compone el objeto datos aplicando str() que devuelve la estructura interna de cualquier objeto en R.\n\nstr(datos)\n\n'data.frame':   5 obs. of  4 variables:\n $ id     : int  1 2 3 4 5\n $ edad   : num  23 43 12 65 37\n $ sexo   : chr  \"V\" \"M\" \"M\" \"V\" ...\n $ trabaja: logi  TRUE TRUE FALSE FALSE TRUE\n\n\nEsta salida nos informa que:\n\ndatos es un dataframe con 5 observaciones y 4 variables.\nid es un entero (int).\nedad es numérica (num).\nsexo es de tipo carácter (chr).\ntrabaja es lógica (logi).\n\nAdemás, str() muestra los primeros valores de cada variable, que en este caso son todos, ya que el dataframe tiene solo 5 registros.\nCuando necesitemos llamar al contenido de alguna columna o variable del dataframe, utilizamos la siguiente notación:\n\nnombre_del_dataframe$nombre_de_la_variable\n\nPor ejemplo, si queremos mostrar el contenido de la variable sexo del objeto datos hacemos:\n\ndatos$sexo\n\n[1] \"V\" \"M\" \"M\" \"V\" \"M\"\n\n\nEsto devuelve todos los valores de la variable sexo.\nTambién podemos acceder a los elementos del dataframe usando indexación por filas y columnas:\n\n# pedimos la tercer variable (sexo)\ndatos[,3]\n\n[1] \"V\" \"M\" \"M\" \"V\" \"M\"\n\n\nObservemos que las dos salidas son idénticas, dado que muestran todas las observaciones de la variable sexo, aunque la solicitud sea de manera diferente.\nAlgunos otros ejemplos de uso de índices:\n\n# observación 1 de la variable 2\ndatos[1,2]\n\n[1] 23\n\n# observación 4 de todas las variables\ndatos[4,]  \n\n  id edad sexo trabaja\n4  4   65    V   FALSE\n\n# observación 1,2 y 3 de la variable 3\ndatos[1:3,3] \n\n[1] \"V\" \"M\" \"M\"\n\n# observación 5 de las variables 1 y 4\ndatos[5, c(1,4)] \n\n  id trabaja\n5  5    TRUE\n\n\nPor último, vamos podemos mostrar y gestionar los nombres de las variables con la función names():\n\nnames(datos)\n\n[1] \"id\"      \"edad\"    \"sexo\"    \"trabaja\"",
    "crumbs": [
      "Unidad 1",
      "Introducción a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#fórmulas",
    "href": "unidad_1/intro_R.html#fórmulas",
    "title": "Introducción a R",
    "section": "Fórmulas",
    "text": "Fórmulas\nEn R, las fórmulas se utilizan principalmente para describir modelos estadísticos, y las vamos a emplear a lo largo de toda la cursada.\nLas fórmulas se escriben utilizando operadores como ~, +, *, entre otros. Se usan para especificar modelos como regresiones, ANOVA, pruebas de hipótesis y, en algunos casos, también para generar ciertos tipos de gráficos.\nFormula genérica\nAquí la formula está dada por el operador ~, a la izquierda está la variable de respuesta o dependiente, a la derecha la o las variables explicativas o independientes. El esquema general es el siguiente:\n\nvariable_dependiente ~ variable independiente\n\nEl símbolo ~ (llamado virgulilla) puede interpretarse como “es modelada por” o “en función de”.\nPor ejemplo, en una regresión lineal se utiliza la función base lm() y el argumento principal de esta función es una formula:\n\nregresion_lineal &lt;- lm(variable_respuesta ~ variable_explicativa,\n                       data = datos)\n\nAdemás de la fórmula, la función lm() incluye el argumento data =, que es fundamental: allí se le indica a R el dataframe en el que debe buscar las variables involucradas en el modelo.\nLa siguiente tabla muestra los usos de los los operadores más comunes dentro de una formula:\n\n\n\n\nOperador\nEjemplo\nDescripción\n\n\n\n+\n+x\nIncluye la variable x\n\n\n-\n-x\nExcluye la variable x\n\n\n:\nx : z\nIncluye la interacción de la variable x con z\n\n\n*\nx * z\nIncluye ambas variables y la interacción entre ellas",
    "crumbs": [
      "Unidad 1",
      "Introducción a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#footnotes",
    "href": "unidad_1/intro_R.html#footnotes",
    "title": "Introducción a R",
    "section": "Notas",
    "text": "Notas\n\nSímbolo que aparece en la pantalla de la computadora indicando que el sistema está esperando información del usuario o que el sistema está listo para recibir instrucciones del usuario.↩︎",
    "crumbs": [
      "Unidad 1",
      "Introducción a R"
    ]
  },
  {
    "objectID": "unidad_1/analisis_exploratorio.html#introducción",
    "href": "unidad_1/analisis_exploratorio.html#introducción",
    "title": "Análisis exploratorio de datos",
    "section": "Introducción",
    "text": "Introducción\nEl análisis exploratorio de datos (conocido como EDA, su sigla en inglés) es un enfoque de análisis fundamental para resumir y visualizar las características importantes de un conjunto de datos.\nJohn Tukey, estadístico estadounidense, fue uno de los principales impulsores de este enfoque. En 1977 publicó el libro Exploratory Data Analysis, donde, entre otras contribuciones, introdujo el gráfico boxplot (diagrama de caja y bigotes).\nEn términos sencillos, antes de avanzar hacia el análisis formal o la construcción de modelos estadísticos, resulta esencial explorar, conocer y describir las variables presentes en nuestra tabla de datos.\nEntre los principales objetivos perseguidos por EDA se encuentran:\n\nConocer la estructura de la tabla de datos y sus tipos de variable.\nDetectar observaciones incompletas (valores missing o NA).\nExplorar la distribución de las variables de interés a partir de:\n\nEstadísticos descriptivos\nRepresentaciones gráficas\n\n\nDetectar valores atípicos (outliers).\n\nAclaración\nEn este documento utilizaremos funciones del lenguaje R basadas en la filosofía tidyverse, junto con otros paquetes diseñados para tareas específicas. Esto no implica que no se puedan emplear funciones del R base; sin embargo, el ecosistema tidyverse facilita la comprensión y legibilidad del código.\nPresentaremos estas diferentes funciones de distintos paquetes que pueden servir en cada etapa de un EDA. Los paquetes con los que trabajaremos son:\n\ntidyverse\nskimr\ndlookr\njanitor\n\n\n\n\n\n\n\nNota: Algunos paquetes, como dlookr, pueden generar falsos positivos en la detección del antivirus durante el proceso de instalación. Sugerimos desactivar momentáneamente el antivirus para evitar inconvenientes.\n\n\n\nUna vez instalados, podemos activar los paquetes con el siguiente código:\n\n# Carga de paquetes\nlibrary(skimr)\nlibrary(janitor)\nlibrary(dlookr)\nlibrary(tidyverse)\n\nSe recomienda cargar tidyverse al final de la lista para evitar conflictos con funciones que puedan solaparse entre paquetes.\n\nEs importante destacar que no existe un único camino y/o función para realizar un análisis exploratorio. Esta selección de herramientas puede adaptarse según las preferencias y necesidades de cada usuario. Por lo tanto, quienes ya tengan familiaridad con otras funciones o paquetes pueden continuar utilizándolos sin inconvenientes.\n\nPara ilustrar los pasos del análisis exploratorio, utilizaremos un archivo con datos ficticios llamado “datos2.txt”, que contiene variables de distintos tipos.",
    "crumbs": [
      "Unidad 1",
      "Análisis exploratorio de datos"
    ]
  },
  {
    "objectID": "unidad_1/analisis_exploratorio.html#conocer-la-estructura-de-la-tabla-de-datos-y-sus-tipos-de-variable",
    "href": "unidad_1/analisis_exploratorio.html#conocer-la-estructura-de-la-tabla-de-datos-y-sus-tipos-de-variable",
    "title": "Análisis exploratorio de datos",
    "section": "Conocer la estructura de la tabla de datos y sus tipos de variable",
    "text": "Conocer la estructura de la tabla de datos y sus tipos de variable\nEl primer paso en la exploración de un conjunto de datos es conocer su estructura y tamaño:\n\nEl tamaño se refiere a la cantidad de observaciones (filas) y de variables (columnas).\nLa estructura incluye cómo están organizadas las variables, qué tipo de datos contiene cada una y qué categorías o valores pueden tomar.\n\nComenzaremos por cargar los datos de ejemplo con la función read_csv2() de tidyverse:\n\ndatos &lt;- read_csv2(\"datos/datos2.txt\")\n\nUna vez cargados los datos, la función glimpse() permite obtener una visión general de la tabla:\n\nglimpse(datos)\n\nRows: 74\nColumns: 7\n$ id      &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,…\n$ sexo    &lt;chr&gt; \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", NA, \"F\", \"F\", \"M\", \"F\"…\n$ edad    &lt;dbl&gt; 76, 68, 50, 49, 51, 68, 70, 64, 60, 57, 83, 76, 27, 34, 17, 45…\n$ peso    &lt;dbl&gt; 71, 71, 79, 71, 87, 75, 80, 83, 69, 73, 60, 70, 648, 718, 61, …\n$ talla   &lt;dbl&gt; 167, 164, 164, 164, 1675, 170, 166, 160, 160, 155, 155, 167, 1…\n$ trabaja &lt;lgl&gt; FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, NA, TRUE, TRUE, TRUE, …\n$ fecha   &lt;date&gt; 2020-10-20, 2020-10-20, 2020-10-20, 2020-11-05, 2020-11-05, 2…\n\n\nEsta función nos informa que la tabla contiene, por ejemplo, 74 observaciones y 7 variables, mostrando el tipo de dato de cada una y los primeros valores que aparecen.\nEntre los tipos de datos más comunes que podemos encontrar se incluyen:\n\nint (integer): números enteros.\ndbl (double): números reales.\nlgl (logical): valores lógicos (TRUE, FALSE).\nchr (character): texto o cadenas de caracteres.\nDate: fechas.\nfct (factor): variables categóricas con niveles.\ndttm (date-time): fechas y horas.\n\nEsta primera revisión de la estructura suele complementarse con el diccionario de datos, un recurso fundamental que describe el significado, tipo, unidad y codificación de cada variable. Este diccionario puede acompañar tanto a bases de datos generadas en investigaciones propias (fuentes primarias) como a datos provenientes de fuentes secundarias.\nEs importante tener en cuenta que el tipo de dato en R no siempre coincide con la naturaleza estadística de la variable. Por ejemplo:\n\nUna variable codificada como dbl puede representar una medida cuantitativa continua, como la edad o el peso.\nPero también puede representar una variable cualitativa codificada con números. Por ejemplo, si una variable que registra respuestas “Sí” y “No” fue codificada como 1 y 0, su tipo de dato será numérico (dbl o int), aunque conceptualmente sea una variable categórica.\n\nPor esta razón, además de inspeccionar el tipo de datos en R, es importante revisar el significado y el uso previsto de cada variable dentro del contexto del análisis.",
    "crumbs": [
      "Unidad 1",
      "Análisis exploratorio de datos"
    ]
  },
  {
    "objectID": "unidad_1/analisis_exploratorio.html#detectar-observaciones-incompletas",
    "href": "unidad_1/analisis_exploratorio.html#detectar-observaciones-incompletas",
    "title": "Análisis exploratorio de datos",
    "section": "Detectar observaciones incompletas",
    "text": "Detectar observaciones incompletas\nLos valores perdidos o faltantes (conocidos como missing en inglés), representados en R por el valor especial NA, constituyen un desafío importante en el análisis de datos. Su presencia puede afectar la calidad del análisis y condicionar las decisiones estadísticas posteriores.\nExisten numerosos enfoques para el tratamiento de valores faltantes, incluyendo técnicas de imputación y modelado específico. Sin embargo, en este curso nos enfocaremos exclusivamente en cómo detectar, contabilizar y, en algunos casos, excluir valores faltantes utilizando funciones del lenguaje R.\nUna forma sencilla de detectar valores faltantes es mediante la función count() del paquete dplyr. Al aplicarla a una variable, la salida incluye una fila adicional que informa cuántos valores NA hay:\n\ndatos |&gt; \n  count(trabaja)\n\n# A tibble: 3 × 2\n  trabaja     n\n  &lt;lgl&gt;   &lt;int&gt;\n1 FALSE      26\n2 TRUE       39\n3 NA          9\n\n\nUna alternativa más completa es la función find_na() del paquete dlookr (Ryu 2024):\n\nfind_na(datos, rate = T)\n\n     id    sexo    edad    peso   talla trabaja   fecha \n  0.000   4.054   0.000   0.000   0.000  12.162   0.000 \n\n\nEsta función se puede aplicar al conjunto de datos completo y devuelve, para cada variable, la cantidad y el porcentaje de valores NA. Por ejemplo, podríamos observar que la variable sexo tiene alrededor de un 4 % de valores faltantes, y la variable trabaja, algo más del 12 %.\nEstos porcentajes pueden ayudarnos a decidir si una variable debe incluirse en un análisis o si es conveniente excluir ciertas observaciones con datos incompletos, siempre que los NA sean el resultado de una ausencia real de información.\nEl mismo paquete trae una función gráfica llamada plot_na_pareto(), que genera un gráfico de barras ordenados por frecuencia de valores faltantes:\n\nplot_na_pareto(datos, only_na = T)\n\n\n\n\n\n\n\nFinalmente, para un diagnóstico más integral de la calidad de las variables, puede utilizarse la función diagnose():\n\ndiagnose(datos)\n\n# A tibble: 7 × 6\n  variables types     missing_count missing_percent unique_count unique_rate\n  &lt;chr&gt;     &lt;chr&gt;             &lt;int&gt;           &lt;dbl&gt;        &lt;int&gt;       &lt;dbl&gt;\n1 id        numeric               0            0              74      1     \n2 sexo      character             3            4.05            3      0.0405\n3 edad      numeric               0            0              45      0.608 \n4 peso      numeric               0            0              56      0.757 \n5 talla     numeric               0            0              38      0.514 \n6 trabaja   logical               9           12.2             3      0.0405\n7 fecha     Date                  0            0              11      0.149 \n\n\nEsta función ofrece un resumen detallado que incluye el tipo de variable, la cantidad de valores faltantes, la proporción de valores únicos, entre otros indicadores de utilidad para la exploración inicial.",
    "crumbs": [
      "Unidad 1",
      "Análisis exploratorio de datos"
    ]
  },
  {
    "objectID": "unidad_1/analisis_exploratorio.html#conocer-la-distribución-de-las-variables-de-interés",
    "href": "unidad_1/analisis_exploratorio.html#conocer-la-distribución-de-las-variables-de-interés",
    "title": "Análisis exploratorio de datos",
    "section": "Conocer la distribución de las variables de interés",
    "text": "Conocer la distribución de las variables de interés\nResumir variables cuantitativas\nLa instalación básica de R tiene incorporadas múltiples funciones estadísticas que permiten calcular medidas resumen para variables cuantitativas. Estas funciones pueden integrarse a la función summarise() de tidyverse.\nMedidas de tendencia central\nLas medidas de tendencia central forman parte del grupo de medidas de posición o localización, pero su objetivo principal es resumir la información en torno a un valor que representa el “centro” de la distribución. Es decir, un valor respecto al cual tienden a agruparse los demás valores.\nPodemos obtener la media y la mediana de nuestros datos con el siguiente código:\n\ndatos |&gt;\n  summarise(\n    # Media\n    media = mean(edad),\n    # Mediana\n    mediana = median(edad)\n  )\n\n# A tibble: 1 × 2\n  media mediana\n  &lt;dbl&gt;   &lt;dbl&gt;\n1  48.1    52.5\n\n\nEn cambio, R base no incluye una función específica para calcular la moda. Para obtenerla, debemos escribir una función propia o utilizar algún paquete adicional que la implemente (por ejemplo, modeest::mlv()).\nMedidas de posición\nLas medidas de posición dividen los datos en grupos con igual número de observaciones. Entre las más utilizadas se encuentran los cuartiles y percentiles.\nLa función quantile() del paquete base stats permite calcular cuartiles u otros percentiles. Por ejemplo, para calcular los cuartiles Q1 y Q3, indicamos en el argumento probs los valores 0.25 y 0.75:\n\ndatos |&gt;\n  summarise(\n    # Primer cuartil\n    cuartil1 = quantile(edad, probs = 0.25),\n    # Tercer cuartil\n    cuartil3 = quantile(edad, probs = 0.75)\n  )\n\n# A tibble: 1 × 2\n  cuartil1 cuartil3\n     &lt;dbl&gt;    &lt;dbl&gt;\n1       28       64\n\n\nPara obtener el mínimo y máximo de estos valores numéricos usamos el siguiente código:\n\ndatos |&gt;\n  summarise(\n    # Mínimo\n    minimo = min(edad),\n    # Máximo\n    maximo = max(edad)\n  )\n\n# A tibble: 1 × 2\n  minimo maximo\n   &lt;dbl&gt;  &lt;dbl&gt;\n1     13     86\n\n\nMedidas de dispersión\nLas medidas de dispersión nos permiten conocer cuán dispersos o variables son los valores dentro del conjunto de datos.\nEntre las más clásicas se encuentran la varianza y el desvío estándar, que se calculan fácilmente con las funciones var() y sd():\n\ndatos |&gt;\n  summarise(\n    # Varianza\n    varianza = var(edad),\n    # Desvío estándar\n    desvio = sd(edad)\n  )\n\n# A tibble: 1 × 2\n  varianza desvio\n     &lt;dbl&gt;  &lt;dbl&gt;\n1     405.   20.1\n\n\nTambién puede ser útil calcular el rango, que se obtiene como la diferencia entre el valor máximo y el mínimo, y el rango intercuartílico (RIC), mediante IQR():\n\ndatos |&gt;\n  summarise(\n    # Rango\n    rango = max(edad) - min(edad),\n    # Rango intercuartílico\n    ric = IQR(edad)\n  )\n\n# A tibble: 1 × 2\n  rango   ric\n  &lt;dbl&gt; &lt;dbl&gt;\n1    73    36\n\n\nEl paquete dlookr ofrece la función describe() para generar un resumen completo de las variables numéricas:\n\ndescribe(datos, -id)\n\n# A tibble: 3 × 26\n  described_variables     n    na  mean    sd se_mean   IQR skewness kurtosis\n  &lt;chr&gt;               &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n1 edad                   74     0  48.1  20.1    2.34  36     -0.211    -1.11\n2 peso                   74     0 358.  323.    37.6  626.     0.451    -1.41\n3 talla                  74     0 363.  505.    58.7   12.8    2.19      2.90\n# ℹ 17 more variables: p00 &lt;dbl&gt;, p01 &lt;dbl&gt;, p05 &lt;dbl&gt;, p10 &lt;dbl&gt;, p20 &lt;dbl&gt;,\n#   p25 &lt;dbl&gt;, p30 &lt;dbl&gt;, p40 &lt;dbl&gt;, p50 &lt;dbl&gt;, p60 &lt;dbl&gt;, p70 &lt;dbl&gt;,\n#   p75 &lt;dbl&gt;, p80 &lt;dbl&gt;, p90 &lt;dbl&gt;, p95 &lt;dbl&gt;, p99 &lt;dbl&gt;, p100 &lt;dbl&gt;\n\n\nEsta función puede aplicarse directamente sobre todo el conjunto de datos. Si bien selecciona automáticamente las variables numéricas, en este caso estamos excluyendo explícitamente la variable id, ya que un identificador no tiene interés estadístico.\nEl resumen que devuelve incluye:\n\nna: cantidad de observaciones con datos y con NA.\nmean: media aritmética.\nsd: desvío estándar de la media.\nse_mean: error estándar de la media.\nIQR: rango intercuartílico.\nMedidas de forma como la simetría (skewness) y la curtosis (kurtosis).\nPercentiles, incluyendo la mediana (P50) y los cuartiles (P25 y P75).\nResumir variables cualitativas\nLas variables cualitativas o categóricas pueden encontrarse en R bajo los tipos de dato character o factor. En ocasiones será necesario convertirlas a factor, ya que este tipo permite aplicar ciertos procedimientos específicos para variables categóricas.\nFrecuencias\nPodemos resumir individualmente variables cualitativas mediante las frecuencias absolutas y relativas de sus categorías. La función count() de dplyr nos muestra el conteo absoluto:\n\ndatos |&gt; \n  count(sexo)\n\n# A tibble: 3 × 2\n  sexo      n\n  &lt;chr&gt; &lt;int&gt;\n1 F        27\n2 M        44\n3 &lt;NA&gt;      3\n\n\nEn la salida se incluirán, además de las categorías presentes, las observaciones con valores faltantes (NA).\nLa inclusión o no de los valores faltantes dependerá del propósito del análisis. Para excluirlos, podemos utilizar drop_na():\n\ndatos |&gt; \n  count(sexo) |&gt; \n  # Saltea los valores NA\n  drop_na()  \n\n# A tibble: 2 × 2\n  sexo      n\n  &lt;chr&gt; &lt;int&gt;\n1 F        27\n2 M        44\n\n\nPara obtener frecuencias relativas en porcentaje:\n\ndatos |&gt;  \n  count(sexo) |&gt;  \n  # Saltea los valores NA\n  drop_na() |&gt; \n  # Transforma a porcentajes\n  mutate(porc = 100 * n / sum(n))\n\n# A tibble: 2 × 3\n  sexo      n  porc\n  &lt;chr&gt; &lt;int&gt; &lt;dbl&gt;\n1 F        27  38.0\n2 M        44  62.0\n\n\nRedondeamos el valor del porcentaje con round():\n\ndatos |&gt;  \n  count(sexo) |&gt;  \n  # Saltea los valores NA\n  drop_na() |&gt; \n  # Transforma a porcentajes y redondea decimales\n  mutate(\n    porc = 100 * n / sum(n),\n    porc = round(porc, digits = 2)\n  )\n\n# A tibble: 2 × 3\n  sexo      n  porc\n  &lt;chr&gt; &lt;int&gt; &lt;dbl&gt;\n1 F        27  38.0\n2 M        44  62.0\n\n\nEl paquete janitor (Firke 2024) ofrece una alternativa más completa mediante la función tabyl():\n\ndatos |&gt;\n  tabyl(sexo)\n\n sexo  n    percent valid_percent\n    F 27 0.36486486     0.3802817\n    M 44 0.59459459     0.6197183\n &lt;NA&gt;  3 0.04054054            NA\n\n\nEsta función muestra tanto frecuencias absolutas como relativas, incluyendo y excluyendo los valores NA (porcentaje sobre el total de valores válidos).\nPodemos mejorar la presentación combinando otras funciones del paquete:\n\ndatos |&gt;  \n  # Excluímos valores NA\n  tabyl(sexo, show_na = F) |&gt; \n  # Añadimos totales por fila\n  adorn_totals(where = \"row\") |&gt;  \n  # Redondea porcentajes a 2 decimales\n  adorn_pct_formatting(digits = 2) \n\n  sexo  n percent\n     F 27  38.03%\n     M 44  61.97%\n Total 71 100.00%\n\n\nTablas de contingencia\nLa forma más adecuada de describir la relación entre dos variables cualitativas es a través de una tabla de contingencia, en la cual:\n\nLas filas representan las categorías de una variable.\nLas columnas representan las categorías de otra variable.\nLas celdas muestran el número de observaciones correspondientes a cada combinación de categorías.\n\nLa función tabyl() también permite crear este tipo de tablas. A continuación, un ejemplo entre sexo y trabaja (aunque trabaja sea lógica, puede tratarse como categórica):\n\ndatos |&gt;  \n  tabyl(sexo, trabaja) \n\n sexo FALSE TRUE NA_\n    F     8   15   4\n    M    17   22   5\n &lt;NA&gt;     1    2   0\n\n\nRecordemos que el orden dentro de los paréntesis de la función es igual al de los índices, el primer argumento es la variable que aparecerá en las filas y el segundo la variable de las columnas. Por ese motivo, en la tabla de contingencia absoluta tenemos sexo en las filas y trabaja en las columnas.\nSe puede mejorar la tabla excluyendo los valores NA y agregando totales por fila:\n\ndatos |&gt;  \n  # Excluímos valores NA\n  tabyl(sexo, trabaja, show_na = F) |&gt; \n  # Añadimos totales por fila\n  adorn_totals(where = \"row\")\n\n  sexo FALSE TRUE\n     F     8   15\n     M    17   22\n Total    25   37\n\n\nPara calcular frecuencias relativas porcentuales por columna usamos el siguiente código:\n\ndatos |&gt;  \n  # Excluímos valores NA\n  tabyl(sexo, trabaja, show_na = F) |&gt; \n  # Añadimos totales\n  adorn_totals(where = \"row\") |&gt; \n  # Añadimos porcentajes por columna\n  adorn_percentages(denominator = \"col\") |&gt; \n  # Redondea porcentajes a 2 decimales\n  adorn_pct_formatting(digits = 2) \n\n  sexo   FALSE    TRUE\n     F  32.00%  40.54%\n     M  68.00%  59.46%\n Total 100.00% 100.00%\n\n\nCalculamos frecuencias relativas porcentuales por fila:\n\ndatos |&gt;  \n  # Excluímos valores NA\n  tabyl(sexo, trabaja, show_na = F) |&gt; \n  # Añadimos totales por columna\n  adorn_totals(where = \"col\") |&gt; \n  # Añadimos porcentajes por fila\n  adorn_percentages(denominator = \"row\") |&gt; \n  # Redondea porcentajes a 2 decimales\n  adorn_pct_formatting(digits = 2)\n\n sexo  FALSE   TRUE   Total\n    F 34.78% 65.22% 100.00%\n    M 43.59% 56.41% 100.00%\n\n\nCambiando el argumento denominator por \"all\" se calculan frecuencias relativas al total:\n\ndatos |&gt;  \n  # Excluímos valores NA\n  tabyl(sexo, trabaja, show_na = F) |&gt; \n  # Añadimos totales por columna\n  adorn_totals(where = \"col\") |&gt; \n  # Añadimos porcentajes al total\n  adorn_percentages(denominator = \"all\") |&gt; \n  # Redondea porcentajes a 2 decimales\n  adorn_pct_formatting(digits = 2)\n\n sexo  FALSE   TRUE  Total\n    F 12.90% 24.19% 37.10%\n    M 27.42% 35.48% 62.90%\n\n\nExplorar variables mediante gráficos\nUno de los aportes más importantes de John Tukey al análisis de datos es la incorporación de los gráficos como herramienta exploratoria. A través de representaciones visuales podemos detectar rápidamente patrones, anomalías, valores extremos, asimetrías o relaciones entre variables.\nEn R, los gráficos más útiles para explorar la distribución univariada de las variables son:\n\nPara variables cualitativas: gráficos de barras\nPara variables cuantitativas: histogramas, gráficos de densidad, boxplots y violin plots\n\nCuando queremos explorar la relación entre dos o más variables, los tipos de gráficos más comunes incluyen:\n\nDiagramas de dispersión (puntos)\nGráficos de líneas\nGráficos de mosaico para variables categóricas cruzadas\n\n\n\nEl lenguaje R soporta una serie de sistemas gráficos asociados a paquetes como graphics, lattice, ggplot2, etc. que sirven de base incluso para otros paquetes con funciones más específicas. Actualmente el estándar gráfico en R es ggplot2.\nEn el documento dedicado a tidyverse ya explicamos cómo funciona ggplot2. Aquí nos concentraremos únicamente en aplicar distintos elementos geométricos (geoms) para representar las variables según su tipo.\nBarras (univariado)\nEl gráfico de barras permite visualizar la frecuencia de las categorías de una variable cualitativa:\n\ndatos |&gt; \n  # Omitimos los NA de sexo\n  drop_na(sexo) |&gt; \n  # Generamos histograma\n  ggplot(aes(x = sexo, fill = sexo)) + \n  geom_bar() + \n  scale_fill_manual(values = c(\"palevioletred4\", \"orange\")) +\n  theme_minimal()\n\n\n\n\n\n\n\nBarras (bivariado)\nCuando cruzamos dos variables categóricas, podemos representar la relación entre ambas modificando el argumento position de geom_bar().\nEl argumento position = \"stack\" nos muestra los valores absolutos acumulados:\n\ndatos |&gt; \n  # Omitimos los NA de sexo y trabaja\n  drop_na(sexo, trabaja) |&gt; \n  # Generamos gráfico de barras\n  ggplot(aes(x = sexo, fill = trabaja)) + \n  geom_bar(position = \"stack\") + \n  scale_fill_brewer(palette = \"Set1\") +\n  theme_minimal()\n\n\n\n\n\n\n\nPor otro lado, el argumento position = “dodge” muestra las barras lado a lado, permitiendo comparar proporciones entre grupos:\n\ndatos |&gt; \n  # Omitimos los NA de sexo y trabaja\n  drop_na(sexo, trabaja) |&gt; \n  # Generamos gráfico de barras\n  ggplot(aes(x = sexo, fill = trabaja)) + \n  geom_bar(position = \"dodge\") + \n  scale_fill_brewer(palette = \"Set1\") +\n  theme_minimal()\n\n\n\n\n\n\n\nFinalmente, position = \"fill\" convierte las alturas en proporciones sobre el total por grupo:\n\ndatos |&gt; \n  # Omitimos los NA de sexo y trabaja\n  drop_na(sexo, trabaja) |&gt; \n  # Generamos gráfico de barras\n  ggplot(aes(x = sexo, fill = trabaja)) + \n  geom_bar(position = \"fill\") + \n  scale_fill_brewer(palette = \"Set1\") +\n  theme_minimal()\n\n\n\n\n\n\n\nHistograma\nRepresenta la frecuencia de valores en intervalos definidos. Útil para observar la forma general de la distribución:\n\ndatos |&gt; \n  # Genera histograma\n  ggplot(aes(x = edad)) +\n  geom_histogram(binwidth = 10,\n                 fill = \"royalblue1\",\n                 color = \"white\"\n                )\n\n\n\n\n\n\n\nDensidad\nEs una estimación suave de la distribución de frecuencias:\n\ndatos |&gt; \n  ggplot(aes(x = edad)) + \n  geom_density(fill = \"thistle1\")  \n\n\n\n\n\n\n\nBoxplot\nMuestra el rango intercuartílico, la mediana y los valores atípicos. Ideal para detectar asimetrías y outliers:\n\ndatos |&gt; \n  # Genera boxplot\n  ggplot(aes(x = edad)) + \n  geom_boxplot(fill = \"seagreen4\")  \n\n\n\n\n\n\n\nViolinplot\nCombina el boxplot con una curva de densidad reflejada. Permite visualizar tanto la forma de la distribución como los cuantiles:\n\ndatos |&gt; \n  # Omitimos los NA de sexo\n  drop_na(sexo) |&gt; \n  # Genera violinplot\n  ggplot(aes(x = edad, y = sexo, fill = sexo)) + \n  geom_violin() +\n  scale_fill_brewer(palette = \"Set2\") +\n  theme_light()\n\n\n\n\n\n\n\nQ-Q Plot\nLos gráficos Q-Q (cuantil-cuantil) permiten evaluar visualmente si una variable sigue una distribución teórica, como la normal. Suelen usarse como método gráfico para analizar “normalidad”, es decir cuanto se asemeja la distribución de la variable a la distribución normal o gaussiana.\nLa función plot_normality() de dlookr muestra un diagnóstico gráfico de normalidad de una variable usando histogramas y Q-Q plot. Además muestra otros histogramas con conversiones de datos (logarítmico y raíz cuadrada por defecto, pero también “Box-Cox” y otras):\n\n# Sobre la variable edad\ndatos |&gt; \n  plot_normality(edad)\n\n\n\n\n\n\n# Sobre la variable peso\ndatos |&gt; \n  plot_normality(peso)\n\n\n\n\n\n\n\nPodemos decir que la variable peso se ajusta mejor a una distribución normal, ya que los puntos del Q-Q plot se alinean más cercanamente a la diagonal teórica.\n\nNota: Este análisis gráfico de normalidad suele complementarse con pruebas estadísticas específicas, que abordaremos en la Unidad 2.",
    "crumbs": [
      "Unidad 1",
      "Análisis exploratorio de datos"
    ]
  },
  {
    "objectID": "unidad_1/analisis_exploratorio.html#detección-de-valores-atípicos",
    "href": "unidad_1/analisis_exploratorio.html#detección-de-valores-atípicos",
    "title": "Análisis exploratorio de datos",
    "section": "Detección de valores atípicos",
    "text": "Detección de valores atípicos\nUn valor atípico (outlier) es una observación que se encuentra numéricamente alejada del resto de los datos. Su presencia puede tener diferentes causas, y su tratamiento dependerá del contexto:\n\nErrores de carga o procedimiento: deben corregirse si se detectan.\nValores extremos plausibles: pueden ser válidos, pero conviene evaluarlos en detalle.\nEventos extraordinarios o causas desconocidas: si no se pueden justificar, suelen excluirse del análisis.\n\nEstos valores pueden afectar sensiblemente ciertos estadísticos como la media, distorsionando su interpretación.\nUna forma gráfica común de detectar valores atípicos es mediante los boxplots. Los puntos situados fuera de los “bigotes” representan posibles outliers.\nA continuación, se presenta un ejemplo con la variable peso, donde se observa un valor extremo en el límite superior de la distribución (punto rojo):\n\ndatos |&gt; \n  ggplot(aes(x = peso)) + \n  geom_boxplot(fill = \"darkkhaki\", \n               outlier.color = \"red\"\n              )  \n\n\n\n\n\n\n\nEste valor coincide con el máximo observado:\n\nmax(datos$peso)\n\n[1] 1105\n\n\nEl paquete dlookr incluye la función diagnose_outlier() para la detección automatizada de valores atípicos en todas las variables numéricas de un conjunto de datos:\n\ndiagnose_outlier(datos)\n\n# A tibble: 4 × 6\n  variables outliers_cnt outliers_ratio outliers_mean with_mean without_mean\n  &lt;chr&gt;            &lt;int&gt;          &lt;dbl&gt;         &lt;dbl&gt;     &lt;dbl&gt;        &lt;dbl&gt;\n1 id                   0            0             NaN      37.5         37.5\n2 edad                 0            0             NaN      48.1         48.1\n3 peso                 0            0             NaN     358.         358. \n4 talla               10           13.5          1630     363.         165. \n\n\nEsta función devuelve una tabla que incluye, para cada variable: cantidad y proporción de outliers detectados, media de la variable incluyendo los outliers, media de la variable excluyendo los outliers. En función de estos dos estadísticos se puede comparar el efecto de los valores atípicos en la media.\nEl paquete skimr (Waring et al. 2022) permite obtener un resumen estadístico compacto y amigable de un conjunto de datos mediante la función skim():\n\nskim(datos)\n\n\nData summary\n\n\nName\ndatos\n\n\nNumber of rows\n74\n\n\nNumber of columns\n7\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n1\n\n\nDate\n1\n\n\nlogical\n1\n\n\nnumeric\n4\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\nsexo\n3\n0.96\n1\n1\n0\n2\n0\n\n\nVariable type: Date\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\nfecha\n0\n1\n2020-10-20\n2020-12-15\n2020-11-11\n11\n\n\nVariable type: logical\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\ncount\n\n\ntrabaja\n9\n0.88\n0.6\nTRU: 39, FAL: 26\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\nid\n0\n1\n37.50\n21.51\n1\n19.25\n37.5\n55.75\n74\n▇▇▇▇▇\n\n\nedad\n0\n1\n48.07\n20.12\n13\n28.00\n52.5\n64.00\n86\n▇▃▇▇▃\n\n\npeso\n0\n1\n358.05\n323.31\n42\n75.00\n91.5\n700.50\n1105\n▇▁▂▃▁\n\n\ntalla\n0\n1\n363.09\n504.93\n148\n161.00\n166.0\n173.75\n1745\n▇▁▁▁▁\n\n\n\n\n\nAdemás, puede integrarse fácilmente con la gramática tidyverse. Por ejemplo, podemos explorar estadísticas descriptivas de variables numéricas agrupadas por sexo:\n\ndatos |&gt; \n  # Excluye NAs de sexo\n  drop_na(sexo) |&gt;\n  # Agrupa por sexo\n  group_by(sexo) |&gt;\n  # Solo variables numéricas - id\n  select(where(is.numeric), -id) |&gt; \n  # Explora outliers\n  skim()\n\n\nData summary\n\n\nName\nselect(…)\n\n\nNumber of rows\n71\n\n\nNumber of columns\n4\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n3\n\n\n________________________\n\n\n\nGroup variables\nsexo\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nsexo\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\nedad\nF\n0\n1\n41.89\n19.64\n15\n26.00\n39.0\n54.50\n83\n▇▃▅▃▂\n\n\nedad\nM\n0\n1\n51.59\n19.56\n13\n40.75\n55.5\n64.75\n86\n▅▂▅▇▂\n\n\npeso\nF\n0\n1\n426.78\n300.85\n42\n70.50\n516.0\n677.00\n856\n▇▁▃▃▆\n\n\npeso\nM\n0\n1\n306.95\n331.27\n64\n78.00\n86.5\n647.00\n1105\n▇▁▁▂▁\n\n\ntalla\nF\n0\n1\n421.74\n562.57\n148\n155.50\n161.0\n167.50\n1625\n▇▁▁▁▂\n\n\ntalla\nM\n0\n1\n340.77\n485.79\n158\n164.00\n168.5\n177.25\n1745\n▇▁▁▁▁\n\n\n\n\n\nEn este ejemplo, mostramos resultados de variables numéricas menos de id agrupados por sexo (sin considerar valores NA en las categorías de sexo).",
    "crumbs": [
      "Unidad 1",
      "Análisis exploratorio de datos"
    ]
  },
  {
    "objectID": "unidad_1/hoja_estilo.html",
    "href": "unidad_1/hoja_estilo.html",
    "title": "Hoja de Estilo del lenguaje R",
    "section": "",
    "text": "R es bastante indulgente con la forma en que escribimos código, a diferencia de otros lenguajes como Python, donde un espacio mal puesto puede arruinar el script. Sin embargo, adoptar una guía de estilo mejora la legibilidad, facilita la colaboración y reduce errores.\nLas siguientes líneas de código producen el mismo resultado, pero no todas son igual de claras:\n\n# Opción 1\nmpg |&gt; \n  filter(cty &gt; 10, class == \"compact\")\n\n# Opción 2\nmpg |&gt; filter(cty &gt; 10, class == \"compact\")\n\n# Opción 3\nmpg |&gt; \n  filter(cty &gt; 10, \n         class == \"compact\")\n\n# Opción 4\nmpg |&gt; filter(cty&gt;10, class==\"compact\")\n\n# Opción 5\nfilter(mpg,cty&gt;10,class==\"compact\")\n\n# Opción 6\nmpg |&gt; \nfilter(cty &gt; 10, \n                        class == \"compact\")\n\n# Opción 7\nfilter ( mpg,cty&gt;10,     class==\"compact\" )\n\nLas tres primeras versiones son más legibles. El resto, aunque válidas, son difíciles de seguir, especialmente en trabajos colaborativos o materiales docentes.",
    "crumbs": [
      "Unidad 1",
      "Hoja de Estilo del lenguaje R"
    ]
  },
  {
    "objectID": "unidad_1/hoja_estilo.html#convenciones-de-estilo-r",
    "href": "unidad_1/hoja_estilo.html#convenciones-de-estilo-r",
    "title": "Hoja de Estilo del lenguaje R",
    "section": "",
    "text": "R es bastante indulgente con la forma en que escribimos código, a diferencia de otros lenguajes como Python, donde un espacio mal puesto puede arruinar el script. Sin embargo, adoptar una guía de estilo mejora la legibilidad, facilita la colaboración y reduce errores.\nLas siguientes líneas de código producen el mismo resultado, pero no todas son igual de claras:\n\n# Opción 1\nmpg |&gt; \n  filter(cty &gt; 10, class == \"compact\")\n\n# Opción 2\nmpg |&gt; filter(cty &gt; 10, class == \"compact\")\n\n# Opción 3\nmpg |&gt; \n  filter(cty &gt; 10, \n         class == \"compact\")\n\n# Opción 4\nmpg |&gt; filter(cty&gt;10, class==\"compact\")\n\n# Opción 5\nfilter(mpg,cty&gt;10,class==\"compact\")\n\n# Opción 6\nmpg |&gt; \nfilter(cty &gt; 10, \n                        class == \"compact\")\n\n# Opción 7\nfilter ( mpg,cty&gt;10,     class==\"compact\" )\n\nLas tres primeras versiones son más legibles. El resto, aunque válidas, son difíciles de seguir, especialmente en trabajos colaborativos o materiales docentes.",
    "crumbs": [
      "Unidad 1",
      "Hoja de Estilo del lenguaje R"
    ]
  },
  {
    "objectID": "unidad_1/hoja_estilo.html#guía-de-estilo-de-tidyverse",
    "href": "unidad_1/hoja_estilo.html#guía-de-estilo-de-tidyverse",
    "title": "Hoja de Estilo del lenguaje R",
    "section": "Guía de estilo de tidyverse",
    "text": "Guía de estilo de tidyverse\nPara ayudar a mejorar la legibilidad y facilitar el compartir código con otros, el equipo de Tidyverse publicó una guía concisa con ejemplos claros de buenas y malas formas de escribir código, nombres de variables, sangría, líneas largas, y más:\n🔗 style.tidyverse.org\nAdemás, RStudio incluye herramientas para aplicar estas convenciones automáticamente. Por ejemplo, seleccionando el código y presionando Ctrl + i (Windows) se puede reidentar el texto. No siempre es perfecto, pero es realmente útil para lograr la sangría correcta sin tener que presionar manualmente espacio muchas veces.\nEspaciado\nColocar espacios después de las comas:\n✔️ Correcto\n\nfilter(mpg, cty &gt; 10)\n\n✖️ Incorrecto\n\nfilter(mpg , cty &gt; 10)\n\nfilter(mpg ,cty &gt; 10)\n\nfilter(mpg,cty &gt; 10)\n\nColocar espacios después de comas y alrededor de operadores (+, -, &gt;, =, etc.) mejora la legibilidad. También se deben evitar espacios innecesarios dentro de paréntesis:\n✔️ Correcto\n\nfilter(mpg, cty &gt; 10)\n\n✖️ Incorrecto\n\nfilter(mpg, cty&gt;10)\n\nfilter(mpg, cty&gt; 10)\n\nfilter(mpg, cty &gt;10)\n\nNo colocar espacios alrededor de paréntesis que sean parte de funciones:\n✔️ Correcto\n\nfilter(mpg, cty &gt; 10)\n\n✖️ Incorrecto\n\nfilter (mpg, cty &gt; 10)\n\nfilter ( mpg, cty &gt; 10)\n\nfilter( mpg, cty &gt; 10 )\n\nLíneas largas\nEn general, es una buena práctica no tener líneas de código muy largas. Se recomienda limitar las líneas a 80 caracteres. Para visualizarlo, en RStudio vamos a Tools &gt; Global Options &gt; Code &gt; Displayy seleccionamos la casilla Show margin.\nSe sugiere agregar saltos de línea dentro de las líneas de código más largas, los mismos deben colocarse luego de las comas y los argumentos se deben alinear dentro de la función:\n✔️ Correcto\n\nfilter(mpg, cty &gt; 10, class == \"compact\")\n\n\nfilter(mpg, cty &gt; 10, \n       class == \"compact\")\n\n\nfilter(mpg,\n       cty &gt; 10,\n       class == \"compact\")\n\nfilter(mpg, \n       cty &gt; 10, \n       class %in% c(\"compact\", \"pickup\", \"midsize\", \"subcompact\", \n                    \"suv\", \"2seater\", \"minivan\"))\n\n✖️ Incorrecto\n\nfilter(mpg, cty &gt; 10, class %in% c(\"compact\", \"pickup\", \"midsize\", \"subcompact\", \"suv\", \"2seater\", \"minivan\"))\n\nTuberías y capas ggplot2\n\nColocar cada paso de la tubería (%&gt;% ó |&gt;) en una línea separada, con sangría de dos espacios debajo del operador:\n✔️ Correcto\n\nmpg |&gt; \n  filter(cty &gt; 10) |&gt; \n  group_by(class) |&gt; \n  summarize(avg_hwy = mean(hwy))\n\n✖️ Incorrecto\n\n# Mal\nmpg |&gt; filter(cty &gt; 10) |&gt; group_by(class) |&gt; \n  summarize(avg_hwy = mean(hwy))\n\n# Muy mal\nmpg |&gt; filter(cty &gt; 10) |&gt; group_by(class) |&gt; summarize(avg_hwy = mean(hwy))\n\n# Tan mal que no funciona\nmpg |&gt; \n  filter(cty &gt; 10)\n  |&gt; group_by(class)\n  |&gt; summarize(avg_hwy = mean(hwy))\n\nLo mismo aplica para las capas de gráficos de ggplot2, usando el conector + al final de la línea y debajo sangría de dos espacios:\n✔️ Correcto\n\nggplot(mpg, aes(x = cty, y = hwy, color = class)) +\n  geom_point() +\n  geom_smooth() +\n  theme_bw()\n\n# Mal\nggplot(mpg, aes(x = cty, y = hwy, color = class)) +\n  geom_point() + geom_smooth() +\n  theme_bw()\n\n# Muy mal\nggplot(mpg, aes(x = cty, y = hwy, color = class)) + geom_point() + geom_smooth() + theme_bw()\n\n# Tan mal que no funciona\nggplot(mpg, aes(x = cty, y = hwy, color = class))\n  + geom_point()\n  + geom_smooth() \n  + theme_bw()\n\n✖️ Incorrecto\n\n# Mal\nggplot(mpg, aes(x = cty, y = hwy, color = class)) +\n  geom_point() + geom_smooth() +\n  theme_bw()\n\n# Muy mal\nggplot(mpg, aes(x = cty, y = hwy, color = class)) + geom_point() + geom_smooth() + theme_bw()\n\n# Tan mal que no funciona\nggplot(mpg, aes(x = cty, y = hwy, color = class))\n  + geom_point()\n  + geom_smooth() \n  + theme_bw()\n\nComentarios\nLos comentarios deben comenzar con # seguido de un espacio:\n✔️ Correcto\n\n# Bien\n\n✖️ Incorrecto\n\n#Mal\n\n    #Mal\n\nSi el comentario es corto, se puede incluir en la misma línea, separado por al menos dos espacios para mejorar la legibilidad:\n\nmpg |&gt; \n  filter(cty &gt; 10) |&gt;  # filtro filas donde cty es 10 o más\n  group_by(class) |&gt;  # estratifica por class\n  summarize(avg_hwy = mean(hwy))  # resume la media de hwy por cada grupo\n\nSe puede agregar espacios adicionales para alinear los comentarios en línea, si lo deseamos:\n\nmpg |&gt; \n  filter(cty &gt; 10) |&gt;             # filtro filas donde cty es 10 o más\n  group_by(class) |&gt;              # estratifica por class\n  summarize(avg_hwy = mean(hwy))  # resume la media de hwy por cada grupo\n\nSi el comentario es muy largo, podemos dividirlo en varias líneas. RStudio incluye una herramienta útil para comentarios largos: Code &gt; Reflow Comment los ajusta automáticamente al ancho deseado.",
    "crumbs": [
      "Unidad 1",
      "Hoja de Estilo del lenguaje R"
    ]
  },
  {
    "objectID": "unidad_1/intro_tidyverse.html#introducción",
    "href": "unidad_1/intro_tidyverse.html#introducción",
    "title": "Introducción a tidyverse",
    "section": "Introducción",
    "text": "Introducción\nTidyverse (Wickham et al. 2019) es el nombre que recibe el conjunto de paquetes desarrollados y/o promovidos por Hadley Wickham (jefe científico en Posit/RStudio) y su equipo, orientado al trabajo de ciencia de datos con R. Estos paquetes están diseñados para integrarse de manera coherente, compartiendo una misma filosofía de diseño conocida como The tidy tools manifesto.\nLos cuatro principios básicos sobre los que se construye tidyverse son:\n\nReutilización de estructuras de datos\nResolución de problemas complejos combinando varias piezas sencillas\nUso de programación funcional\nDiseño orientado a las personas\n\nLos paquetes incluidos cubren todas las etapas del análisis de datos dentro de R: importación y ordenamiento de los datos (tidy data), transformación, visualización, modelado y la posterior comunicación de resultados.\nLa palabra tidy se traduce como “ordenado”, y hace referencia a una estructura específica que deben cumplir los datos:\n\nCada variable es una columna de la tabla de datos.\nCada observación es una fila de la tabla de datos.\nCada tabla responde a una unidad de observación o análisis.\n\n\n\n\n\nAdemás de los paquetes principales, al instalar tidyverse se incluyen otros que permiten trabajar con fechas, cadenas de caracteres o factores, también siguiendo los mismos principios.\nUno de los objetivos de los desarrolladores fue dotar a la sintaxis de estos paquetes de una gramática clara: funciones cuyos nombres y argumentos permiten construir “frases” que sean semánticamente comprensibles. Un ejemplo de esto se ve en el paquete dplyr, donde la mayoría de las funciones son verbos en inglés como filter(), mutate(), summarise(), lo que facilita su lectura y comprensión.\nEl paquete tidyverse (versión 2.0.0) puede instalarse desde el repositorio oficial CRAN mediante el menú Packages de RStudio, o ejecutando el siguiente código:\n\ninstall.packages(\"tidyverse\")\n\nUna vez instalado, se activa mediante:\n\nlibrary(tidyverse)\n\nAl activarlo, se muestra un mensaje con la versión instalada, la lista de paquetes que se cargan automáticamente y posibles conflictos de nombres entre funciones. Esto es habitual cuando se utilizan múltiples paquetes, ya que algunas funciones pueden llamarse igual. Por ejemplo, la función filter() existe tanto en el paquete stats como en dplyr. Al cargar tidyverse, R avisa de esta superposición:\n✖️dplyr::filter() masks stats::filter()\nCuando necesitamos asegurarnos de que estamos usando la función de un paquete específico, se recomienda usar la notación ::, por ejemplo:\n\n# Función filter() del paquete stats\nstats::filter()\n\n# Función filter() del paquete tidyverse\ndplyr::filter()\n\nUna estrategia útil cuando trabajamos con varios paquetes es cargar tidyverse al final de la lista de paquetes, para que sus funciones sobrescriban las de otros paquetes si fuese necesario:\n\nlibrary(stats)\nlibrary(tidyverse)\n\nLos paquetes que se instalan con la versión actual de tidyverse pueden consultarse ejecutando:\n\ntidyverse_packages()\n\n [1] \"broom\"         \"conflicted\"    \"cli\"           \"dbplyr\"       \n [5] \"dplyr\"         \"dtplyr\"        \"forcats\"       \"ggplot2\"      \n [9] \"googledrive\"   \"googlesheets4\" \"haven\"         \"hms\"          \n[13] \"httr\"          \"jsonlite\"      \"lubridate\"     \"magrittr\"     \n[17] \"modelr\"        \"pillar\"        \"purrr\"         \"ragg\"         \n[21] \"readr\"         \"readxl\"        \"reprex\"        \"rlang\"        \n[25] \"rstudioapi\"    \"rvest\"         \"stringr\"       \"tibble\"       \n[29] \"tidyr\"         \"xml2\"          \"tidyverse\"    \n\n\nAdemás, existen muchos otros paquetes que siguen la misma filosofía pero no están incluidos por defecto. En esos casos, deben instalarse y activarse individualmente.\n\n\n\n\n\n\nPara profundizar el uso de tidyverse, se recomienda consultar las siguientes fuentes:\n\nSitio oficial: https://www.tidyverse.org/\nLibro R para Ciencia de Datos: r4ds o la nueva versión r4ds 2e (por ahora solo disponible en inglés).\nEpiRhandbook en español",
    "crumbs": [
      "Unidad 1",
      "Introducción a tidyverse"
    ]
  },
  {
    "objectID": "unidad_1/intro_tidyverse.html#dataframes-con-tibble",
    "href": "unidad_1/intro_tidyverse.html#dataframes-con-tibble",
    "title": "Introducción a tidyverse",
    "section": "Dataframes con tibble\n",
    "text": "Dataframes con tibble\n\n\n\n\n\nUno de los paquetes que forman parte del núcleo básico de tidyverse es tibble (Müller y Wickham 2023), que introduce una versión moderna del objeto data.frame. Todas las funciones que generan tablas de datos en tidyverse devuelven objetos tibble (tbl_df), los cuales son más eficientes y amigables para el flujo de trabajo.\nLas principales ventajas de trabajar con tibble son:\n\nImpresión en consola más legible y controlada (muestran un número limitado de filas y columnas).\nNo cambian automáticamente el tipo de datos.\nPermiten nombres de columnas con espacios o caracteres especiales si se encierran entre comillas invertidas ` (aunque no se recomienda).\n\nPara crear un objeto tibble manualmente usamos el siguiente código:\n\ndatos &lt;- tibble(\n  nombre = c(\"Ana\", \"Luis\", \"María\"),\n  edad = c(34, 28, 45),\n  altura = c(1.65, 1.80, 1.70)\n)",
    "crumbs": [
      "Unidad 1",
      "Introducción a tidyverse"
    ]
  },
  {
    "objectID": "unidad_1/intro_tidyverse.html#tuberías-con-magrittr",
    "href": "unidad_1/intro_tidyverse.html#tuberías-con-magrittr",
    "title": "Introducción a tidyverse",
    "section": "Tuberías con magrittr\n",
    "text": "Tuberías con magrittr\n\n\n\n\n\nUna de las incorporaciones más útiles y transversales del ecosistema tidyverse es el uso de “tuberías” o pipe operators. Una tubería conecta un bloque de código con otro, permitiendo encadenar operaciones de manera legible. El operador %&gt;%, proveniente del paquete magrittr (Bache y Wickham 2022), transforma llamadas de funciones anidadas (con múltiples paréntesis) en una secuencia de pasos más simple de leer y escribir.\nA partir de la versión 4.1.0 de R, también se incorporó una tubería nativa (|&gt;), con un comportamiento muy similar. Ambas opciones son válidas y su uso es prácticamente equivalente.\nEste enfoque refleja el principio de que cada función representa un paso en una secuencia lógica de transformación de datos. La forma de trabajar se puede ver en el siguiente esquema general:\n\n\n\n\nA continuación, mostramos un ejemplo comparativo de cómo cambia la sintaxis usando el dataset incorporado en R mtcars, que contiene datos sobre autos:\n\nhead(sqrt(mtcars)) \n\n                       mpg      cyl     disp        hp     drat       wt\nMazda RX4         4.582576 2.449490 12.64911 10.488088 1.974842 1.618641\nMazda RX4 Wag     4.582576 2.449490 12.64911 10.488088 1.974842 1.695582\nDatsun 710        4.774935 2.000000 10.39230  9.643651 1.962142 1.523155\nHornet 4 Drive    4.626013 2.449490 16.06238 10.488088 1.754993 1.793042\nHornet Sportabout 4.324350 2.828427 18.97367 13.228757 1.774824 1.854724\nValiant           4.254409 2.449490 15.00000 10.246951 1.661325 1.860108\n                      qsec vs am     gear     carb\nMazda RX4         4.057093  0  1 2.000000 2.000000\nMazda RX4 Wag     4.125530  0  1 2.000000 2.000000\nDatsun 710        4.313931  1  1 2.000000 1.000000\nHornet 4 Drive    4.409082  1  0 1.732051 1.000000\nHornet Sportabout 4.125530  0  0 1.732051 1.414214\nValiant           4.496665  1  0 1.732051 1.000000\n\n\nEn la línea de código anterior estamos pidiendo mostrar la cabecera (6 primeras observaciones de la tabla de datos) de la raíz cuadrada de los valores de la tabla mtcars, en formato del lenguaje clásico (anidado).\nAhora activamos magrittr y ejecutamos la línea anterior en formato tubería:\n\n# Activa paquete\nlibrary(magrittr) \n\n# Formato tubería\nmtcars %&gt;%\n  sqrt() %&gt;%\n  head()\n\n                       mpg      cyl     disp        hp     drat       wt\nMazda RX4         4.582576 2.449490 12.64911 10.488088 1.974842 1.618641\nMazda RX4 Wag     4.582576 2.449490 12.64911 10.488088 1.974842 1.695582\nDatsun 710        4.774935 2.000000 10.39230  9.643651 1.962142 1.523155\nHornet 4 Drive    4.626013 2.449490 16.06238 10.488088 1.754993 1.793042\nHornet Sportabout 4.324350 2.828427 18.97367 13.228757 1.774824 1.854724\nValiant           4.254409 2.449490 15.00000 10.246951 1.661325 1.860108\n                      qsec vs am     gear     carb\nMazda RX4         4.057093  0  1 2.000000 2.000000\nMazda RX4 Wag     4.125530  0  1 2.000000 2.000000\nDatsun 710        4.313931  1  1 2.000000 1.000000\nHornet 4 Drive    4.409082  1  0 1.732051 1.000000\nHornet Sportabout 4.125530  0  0 1.732051 1.414214\nValiant           4.496665  1  0 1.732051 1.000000\n\n\nPodemos hacer lo mismo con la tubería nativa de R sin activar ningún paquete (revisar que esté activada desde Tools &gt; Global Options):\n\n# Tubería nativa\nmtcars |&gt; \n  sqrt() |&gt; \n  head()\n\n                       mpg      cyl     disp        hp     drat       wt\nMazda RX4         4.582576 2.449490 12.64911 10.488088 1.974842 1.618641\nMazda RX4 Wag     4.582576 2.449490 12.64911 10.488088 1.974842 1.695582\nDatsun 710        4.774935 2.000000 10.39230  9.643651 1.962142 1.523155\nHornet 4 Drive    4.626013 2.449490 16.06238 10.488088 1.754993 1.793042\nHornet Sportabout 4.324350 2.828427 18.97367 13.228757 1.774824 1.854724\nValiant           4.254409 2.449490 15.00000 10.246951 1.661325 1.860108\n                      qsec vs am     gear     carb\nMazda RX4         4.057093  0  1 2.000000 2.000000\nMazda RX4 Wag     4.125530  0  1 2.000000 2.000000\nDatsun 710        4.313931  1  1 2.000000 1.000000\nHornet 4 Drive    4.409082  1  0 1.732051 1.000000\nHornet Sportabout 4.125530  0  0 1.732051 1.414214\nValiant           4.496665  1  0 1.732051 1.000000\n\n\nLas tuberías le dan mucha mas claridad al código separandolo en partes, como si fuesen oraciones de un párrafo.",
    "crumbs": [
      "Unidad 1",
      "Introducción a tidyverse"
    ]
  },
  {
    "objectID": "unidad_1/intro_tidyverse.html#lectura-y-escritura-de-datos",
    "href": "unidad_1/intro_tidyverse.html#lectura-y-escritura-de-datos",
    "title": "Introducción a tidyverse",
    "section": "Lectura y escritura de datos",
    "text": "Lectura y escritura de datos\nArchivos de texto plano con readr\n\n\n\n\n\nEl paquete readr (Wickham, Hester, y Bryan 2024) contiene funciones similares a las de la familia read.table() de R base, pero desarrollados bajo el ecosistema tidyverse.\nLos archivos de texto plano (ASCII u otras codificaciones) son universalmente utilizados por la mayoría de los gestores de bases de datos y planillas de cálculo. Generalmente se encuentran con extensiones .txt o .csv (por comma-separated values) y son el tipo de archivo de datos más habitual en R.\nEstos datos planos tienen dos características principales:\n\nLa cabecera (en inglés header).\nEl carácter o símbolo separador que indica la separación de columnas: pueden estar separadas por comas, punto y coma, tabulación, etc.\n\nLa presencia o no de una cabecera se maneja con los argumentos col_names y skip:\n\ncol_names = TRUE indica que la primera fila contiene los nombres de las columnas (cabecera).\ncol_names = FALSE indica que no hay cabecera y las columnas se nombran automáticamente (X1, X2, etc).\nskip = 0 (valor por defecto) lee los datos desde la primera fila, pero si hay encabezados complejos (por ejemplo, títulos y subtítulos ), se puede indicar cuántas filas deben omitirse. Ejemplo: skip = 5 omite las primeras 5 filas del archivo.\n\nOtro aspecto a considerar es el carácter separador utilizado para indicar la separación entre columnas. Los separadores más comunes son:\n\ncoma (,)\npunto y coma (;)\ntabulación (TAB)\nespacio (\" \")\nbarra vertical o pipe (|)\n\nFunciones de lectura\nAlgunas de las funciones del paquete asumen un separador particular. Por caso read_csv() lee separados por coma y read_tsv() separado por tabulaciones, pero la función read_delim() permite que definamos el separador a través del argumento delim.\nEn forma detallada el paquete readr soporta siete formatos de archivo a partir de siete funciones:\n\n\nread_csv(): archivos separados por comas (CSV).\n\nread_tsv(): archivos separados por tabulaciones.\n\nread_delim(): archivos separados con delimitadores generales.\n\nread_fwf(): archivos con columnas de ancho fijo.\n\nread_table(): archivos formato tabla con columnas separadas por espacios.\n\nread_log(): archivos log web.\n\nEn comparación con las funciones R base, las funciones de readr:\n\nUsan un esquema de nombres consistente de parámetros.\nSon más rápidas.\nAnalizan eficientemente los formatos de datos comunes (especialmente fechas y horas).\nMuestra una barra de progreso para archivos grandes.\nVienen incluidas dentro de tidyverse pero también pueden usarse de forma independiente:\n\n\nlibrary(readr)\n\nA modo de ejemplo, leeremos un archivo sin cabecera separado por comas bajo el nombre datos:\n\ndatos &lt;- read_csv(\"datos/ejemplo-datos.csv\", \n                  col_names = F)\ndatos\n\n# A tibble: 4 × 5\n     X1 X2       X3       X4    X5        \n  &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt; &lt;date&gt;    \n1     9 Leone    Fernando M     1958-12-24\n2    26 Garcia   Esteban  M     1954-01-21\n3    35 Salamone Nicolas  M     1993-06-27\n4    48 Gonzalez Viviana  F     1965-06-21\n\n\nLeemos el mismo archivo con cabecera y separado por punto y comas, bajo el nombre info:\n\ninfo &lt;- read_csv2(\"datos/ejemplo-datos-header.csv\",\n                  col_names = T)\ninfo\n\n# A tibble: 4 × 5\n   Iden Apellido Nombre   Sexo  FNac      \n  &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt; &lt;date&gt;    \n1     9 Leone    Fernando M     1958-12-24\n2    26 Garcia   Laura    M     1954-01-21\n3    35 Salamone Nicolas  M     1993-06-27\n4    48 Gonzalez Viviana  F     1965-06-21\n\n\nEn estos ejemplos:\n\nread_csv() espera comas como separador\nread_csv2() espera punto y coma como separador\n\nAl leer un archivo, readr intenta adivinar automáticamente el tipo de dato de cada columna (parse). Si no hay cabecera, los nombres de columna serán X1, X2, etc.\nPodemos inspeccionar la estructura de un dataframe con glimpse():\n\nglimpse(info)\n\nRows: 4\nColumns: 5\n$ Iden     &lt;dbl&gt; 9, 26, 35, 48\n$ Apellido &lt;chr&gt; \"Leone\", \"Garcia\", \"Salamone\", \"Gonzalez\"\n$ Nombre   &lt;chr&gt; \"Fernando\", \"Laura\", \"Nicolas\", \"Viviana\"\n$ Sexo     &lt;chr&gt; \"M\", \"M\", \"M\", \"F\"\n$ FNac     &lt;date&gt; 1958-12-24, 1954-01-21, 1993-06-27, 1965-06-21\n\n\nLos tipos de datos posibles son:\n\ncharacter (&lt;chr&gt;)\ninteger, double o numeric (&lt;int&gt;, &lt;dbl&gt;)\nlogical (&lt;lgl&gt;)\ndate, datetime, etc.\n\nPor ejemplo, columnas con enteros pueden aparecer como &lt;dbl&gt; si se interpretan como double, y las fechas como &lt;date&gt;.\nAgregamos unos argumentos más y ejemplificamos la sintaxis con read_delim() para leer un archivo con cabecera compleja (la tabla comienza en la fila 9) separado por caracteres | (pipes).\n\nread_delim(\"ejemplo-datos-header-skip.txt\", \n           col_names = T, \n           skip = 8, \n           delim = \"|\")\n\n\nImportante: No olvides asignar la lectura a un nombre para guardar el dataframe dentro del entorno de trabajo (por ejemplo: datos &lt;-).\n\nFunciones de escritura\nEl paquete también incluye funciones para escribir archivos de texto plano, con formatos espejo de las funciones de lectura más comunes:\n\n\nwrite_csv(): escribe archivos separados por comas\n\nwrite_csv2(): escribe archivos separados por punto y comas\n\nwrite_tsv(): escribe archivos separados por tabulaciones\n\nwrite_delim(): escribe archivos separados con delimitadores definidos por el usuario\n\nLos argumentos son generales y para el caso del último más extensos, dado que hay que definir cual es el separador que deseamos en el archivo. Podemos consultarlos con el siguiente código:\n\nargs(write_delim)\n\nfunction (x, file, delim = \" \", na = \"NA\", append = FALSE, col_names = !append, \n    quote = c(\"needed\", \"all\", \"none\"), escape = c(\"double\", \n        \"backslash\", \"none\"), eol = \"\\n\", num_threads = readr_threads(), \n    progress = show_progress(), path = deprecated(), quote_escape = deprecated()) \nNULL\n\n\nPor ejemplo para exportar un conjunto de datos en texto plano al que denominaremos “ejemplo.csv“ con separador punto y coma y cabecera incluida podemos hacer:\n\nwrite_delim(x = datos, file = \"ejemplo.csv\", delim = \";\")\n\no más sencillo, usando la función específica write_csv2():\n\nwrite_csv2(datos, \"ejemplo.csv\") # define cabecera y separador ;\n\nLectura de hojas de cálculo con readxl\n\n\n\n\n\nUno de los formatos más comunes para almacenar datos son las hojas de cálculo, en particular las creadas con Microsoft Excel. El paquete readxl (Wickham y Bryan 2025), parte del ecosistema tidyverse, permite leer este tipo de archivos.\nreadxl es compatible con hojas de cálculo de Excel 97-2003, con extensión .xls, y con versiones más recientes, con extensión .xlsx.\nUna primera función útil es excel_sheets(), que permite conocer y listar los nombres de las hojas contenidas en un archivo Excel (también llamado libro o workbook).\nPor ejemplo, supongamos que tenemos un archivo denominado “datos.xlsx“ y queremos saber por cuantas hojas está compuesto y que nombre tienen:\n\nlibrary(readxl) # hay que activarlo independientemente de tidyverse\n\nexcel_sheets(\"datos/datos.xlsx\")\n\n[1] \"diabetes\"   \"vigilancia\" \"mortalidad\"\n\n\nEsto devuelve, por ejemplo, tres hojas: \"diabetes\", \"vigilancia\" y \"mortalidad\".\nPara leer una de estas hojas utilizamos la función read_excel(), cuyos argumentos principales son:\n\nargs(read_excel)\n\nfunction (path, sheet = NULL, range = NULL, col_names = TRUE, \n    col_types = NULL, na = \"\", trim_ws = TRUE, skip = 0, n_max = Inf, \n    guess_max = min(1000, n_max), progress = readxl_progress(), \n    .name_repair = \"unique\") \nNULL\n\n\nEntre los más relevantes encontramos:\n\npath: nombre del archivo y su ubicación (entre comillas)\nsheet: nombre de la hoja o su número de orden\ncol_names: si es TRUE, toma la primera fila como nombres de las columnas\nskip: permite saltear un número determinado de filas antes de comenzar la lectura\n\nAl ejecutar read_excel(), internamente se utiliza la función excel_format() para detectar si el archivo es .xls o .xlsx, y luego se aplica la función específica para cada caso: read_xls() o read_xlsx(). Estas funciones también pueden usarse directamente si se desea.\nSupongamos ahora que queremos leer la hoja llamada \"diabetes\":\n\ndiabetes &lt;- read_excel(path = \"datos/datos.xlsx\", \n                       sheet = \"diabetes\",\n                       col_names = T)\n\n# mostramos las 6 primeras observaciones\nhead(diabetes)\n\n# A tibble: 6 × 8\n    A1C  hba1 GLUCB   SOG Tol_Glucosa    DM    SM  HOMA\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  6.17   7.9   101   122 IFG             0     1  4.04\n2  5.58   7.2   103   100 IFG             0     0  5.03\n3  5.38   7.1   103    90 IFG             0     1  2.92\n4  5.38   6.6   109    96 IFG             0     1  4.79\n5  5.19   6.3   107    69 IFG             0     1  3.06\n6  4.89   6      NA   117 IFG             0     0  5.77\n\n\nObservemos que en los argumentos escribimos el nombre del archivo que se encuentra en nuestro proyecto y por lo tanto en nuestra carpeta activa, el nombre de la hoja y nos aseguramos que la primer fila representa a la cabecera de la tabla (sus nombres de variables).\nComo readxl forma parte del ecosistema tidyverse el formato de salida es un tibble. En este caso de 23 observaciones por 8 variables.\nAhora leamos la segunda hoja de nombre \"vigilancia\":\n\nvigilancia &lt;- read_excel(path = \"datos/datos.xlsx\", \n                         sheet = 2, \n                         col_names = F)\n\n# mostramos las 6 primeras observaciones\nhead(vigilancia)\n\n# A tibble: 6 × 9\n   ...1 ...2        ...3      ...4  ...5  ...6  ...7 ...8  ...9                 \n  &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;                \n1   875 09/28/2015  2015 544080000     1    31     1 F     VIGILANCIA EN SALUD …\n2   875 42317       2015 544080000     1    35     1 F     VIGILANCIA EN SALUD …\n3   875 42317       2015 544080000     1    47     1 F     VIGILANCIA EN SALUD …\n4   307 09/26/2015  2015 544005273     1    23     1 M     VIGILANCIA INTEGRADA…\n5   307 09/24/2015  2015 544005273     1    19     1 M     VIGILANCIA INTEGRADA…\n6   875 09/28/2015  2015 544080000     1    63     1 F     VIGILANCIA EN SALUD …\n\n\nEn este caso, en lugar del nombre de la hoja usamos un 2 que es su ubicación y especificamos col_names = FALSE porque el conjunto de datos no tiene cabecera. readxl asignará nombres genéricos como ...1, ...2, etc.\nFinalmente leamos la última hoja disponible del archivo:\n\nmortalidad &lt;- read_excel(path = \"datos/datos.xlsx\", \n                         sheet = \"mortalidad\",\n                         col_names = T, \n                         skip = 1)\n\n# mostramos las 6 primeras observaciones\nhead(mortalidad) \n\n# A tibble: 5 × 10\n  grupo_edad grupo.I.1.1 grupo.II.1.1 grupo.III.1.1 grupo.I.2.1 grupo.II.2.1\n  &lt;chr&gt;            &lt;dbl&gt;        &lt;dbl&gt;         &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;\n1 30-44               41          202           222         539         1438\n2 45-59               99         1071           181         759         6210\n3 60-69              114         1782           119         985         9238\n4 70-79              221         2336           119        1571        12369\n5 80+                362         2492            81        2523        14642\n# ℹ 4 more variables: grupo.III.2.1 &lt;dbl&gt;, grupo.I.3.1 &lt;dbl&gt;,\n#   grupo.II.3.1 &lt;dbl&gt;, grupo.III.3.1 &lt;dbl&gt;\n\n\nLo novedoso de esta lectura es el argumento skip = 1 que debimos incorporar dado que, en este caso, la hoja de Excel comienza con una línea de título que no pertenece al conjunto de datos. También que el argumento sheet permite el nombre de la hoja elegida entre comillas.\nAdemás de los argumentos generales de read_xl(), podemos mencionar estos otros:\n\nn_max: número máximo de filas a leer.\nrange: rango de celdas a importar (como en Excel, por ejemplo \"B3:D87\").\ncol_types: define el tipo de datos de cada columna. Valores posibles: \"numeric\", \"logical\", \"text\", \"date\", \"skip\" (no leer la columna), \"guess\" (modo predeterminado: la función decide automáticamente el tipo).\nna: carácter o vector de caracteres que se deben interpretar como valores perdidos (NA). Por defecto, las celdas vacías se interpretan así.",
    "crumbs": [
      "Unidad 1",
      "Introducción a tidyverse"
    ]
  },
  {
    "objectID": "unidad_1/intro_tidyverse.html#gestión-de-datos-con-dplyr",
    "href": "unidad_1/intro_tidyverse.html#gestión-de-datos-con-dplyr",
    "title": "Introducción a tidyverse",
    "section": "Gestión de datos con dplyr\n",
    "text": "Gestión de datos con dplyr\n\n\n\n\n\nEl paquete dplyr (Wickham et al. 2023) fue desarrollado por Hadley Wickham como una versión optimizada del paquete plyr (Wickham 2011).\nSu principal contribución es ofrecer una gramática para la manipulación de datos, basada en funciones que actúan como verbos, lo que facilita la lectura y comprensión del código.\nLas funciones clave del paquete permiten realizar las siguientes acciones (verbos):\n\n\nselect(): selecciona un conjunto de columnas (variables)\n\nrename(): renombra variables en un conjunto de datos\n\nfilter(): selecciona un conjunto de filas (observaciones) según una o varias condiciones lógicas\n\narrange(): reordena las filas de un conjunto de datos\n\nmutate(): añade nuevas variables/columnas o transforma variables existentes\n\nsummarise()/summarize(): genera resúmenes estadísticos de diferentes variables en el conjunto de datos\n\ngroup_by(): agrupa las observaciones en función de una o más variables, lo que permite realizar operaciones por grupo\n\ncount(): contabiliza valores que se repiten, generando una tabla de frecuencias\n\nAdemás, al ser parte del ecosistema tidyverse, dplyr integra al operador %&gt;% (pipe) formando una única secuencia de procesamiento o pipeline.\nArgumentos comunes en las funciones dplyr\n\nTodas las funciones, básicamente, tienen en común una serie de argumentos.\n\nEl primer argumento es el nombre del conjunto de datos (objeto donde esta nuestra tabla de datos).\nLos otros argumentos describen que hacer con el conjunto de datos especificado en el primer argumento, podemos referirnos a las columnas en el objeto directamente sin utilizar el operador $, es decir sólo con el nombre de la columna/variable.\nEl valor de retorno es un nuevo conjunto de datos.\nLos conjuntos de datos deben estar bien organizados/estructurados, es decir debe existir una observación por columna y, cada columna representar una variable, medida o característica de esa observación. Es decir, debe cumplir con tidy data.\nActivación del paquete\ndplyr está incluído en el núcleo base de tidyverse, por lo que se encuentra disponible si tenemos activado a este último.\nTambién se puede activar en forma independiente:\n\nlibrary(dplyr)\n\nConjunto de datos para ejemplo\nPara visualizar y comprender el funcionamiento de estos “verbos” de manipulación, resulta muy útil contar con ejemplos concretos. Por eso, en esta unidad trabajaremos con un conjunto de datos que nos permitirá practicar el uso de las funciones del paquete:\n⬇️ Descargar datos en formato ZIP\nTambién podés acceder a este archivo desde el enlace disponible en la barra superior de esta página.\nUno de los archivos incluidos, “noti-vih.csv”, contiene registros de notificaciones de VIH por jurisdicción en Argentina correspondientes a los años 2015 y 2016.\n\n# asignamos la lectura a datos\ndatos &lt;- read_csv(\"datos/noti-vih.csv\") \n\n# mostramos las 6 primeras observaciones\nhead(datos)\n\n# A tibble: 6 × 4\n  jurisdiccion   año casos      pob\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n1 Buenos Aires  2015  1513 16626374\n2 Buenos Aires  2016   957 16789474\n3 CABA          2015   901  3054237\n4 CABA          2016   427  3050000\n5 Catamarca     2015    69   396552\n6 Catamarca     2016    51   401575\n\n\nFunción select()\n\nLa función select() permite elegir columnas específicas de un conjunto de datos, devolviendo una versión “recortada por columnas” del mismo.\nA continuación, exploramos algunas formas útiles de seleccionar variables:\nSeleccionar todas las variables excepto pob:\n\ndatos |&gt; \n  select(-pob)\n\n# A tibble: 48 × 3\n   jurisdiccion   año casos\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;\n 1 Buenos Aires  2015  1513\n 2 Buenos Aires  2016   957\n 3 CABA          2015   901\n 4 CABA          2016   427\n 5 Catamarca     2015    69\n 6 Catamarca     2016    51\n 7 Chaco         2015    15\n 8 Chaco         2016     9\n 9 Chubut        2015   110\n10 Chubut        2016    89\n# ℹ 38 more rows\n\n\nOtra forma para el mismo resultado anterior (mediante el operador rango :):\n\ndatos |&gt; \n  select(jurisdiccion:casos)\n\n# A tibble: 48 × 3\n   jurisdiccion   año casos\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;\n 1 Buenos Aires  2015  1513\n 2 Buenos Aires  2016   957\n 3 CABA          2015   901\n 4 CABA          2016   427\n 5 Catamarca     2015    69\n 6 Catamarca     2016    51\n 7 Chaco         2015    15\n 8 Chaco         2016     9\n 9 Chubut        2015   110\n10 Chubut        2016    89\n# ℹ 38 more rows\n\n\nSeleccionar solamente las variables jurisdiccion y casos:\n\ndatos |&gt; \n  select(jurisdiccion, casos)\n\n# A tibble: 48 × 2\n   jurisdiccion casos\n   &lt;chr&gt;        &lt;dbl&gt;\n 1 Buenos Aires  1513\n 2 Buenos Aires   957\n 3 CABA           901\n 4 CABA           427\n 5 Catamarca       69\n 6 Catamarca       51\n 7 Chaco           15\n 8 Chaco            9\n 9 Chubut         110\n10 Chubut          89\n# ℹ 38 more rows\n\n\nLo mismo que el ejemplo anterior, pero usando la posición de las columnas:\n\ndatos |&gt; \n  select(1, 3)\n\n# A tibble: 48 × 2\n   jurisdiccion casos\n   &lt;chr&gt;        &lt;dbl&gt;\n 1 Buenos Aires  1513\n 2 Buenos Aires   957\n 3 CABA           901\n 4 CABA           427\n 5 Catamarca       69\n 6 Catamarca       51\n 7 Chaco           15\n 8 Chaco            9\n 9 Chubut         110\n10 Chubut          89\n# ℹ 38 more rows\n\n\nMover la variable año al inicio y mantener todas las demás:\n\ndatos |&gt; \n  select(\"año\", everything())\n\n# A tibble: 48 × 4\n     año jurisdiccion casos      pob\n   &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;\n 1  2015 Buenos Aires  1513 16626374\n 2  2016 Buenos Aires   957 16789474\n 3  2015 CABA           901  3054237\n 4  2016 CABA           427  3050000\n 5  2015 Catamarca       69   396552\n 6  2016 Catamarca       51   401575\n 7  2015 Chaco           15  1153846\n 8  2016 Chaco            9  1125000\n 9  2015 Chubut         110   567010\n10  2016 Chubut          89   577922\n# ℹ 38 more rows\n\n\nOtros posibles argumentos son:\n\nstarts_with(): selecciona todas las columnas que comiencen con el patrón indicado.\nends_with(): selecciona todas las columnas que terminen con el patrón indicado.\ncontains(): selecciona las columnas que posean el patrón indicado.\nmatches(): similar a contains(), pero permite poner una expresión regular.\nall_of(): selecciona las variables pasadas en un vector (todos los nombres deben estar presentes o devuelve un error).\nany_of(): idem anterior excepto que no se genera ningún error para los nombres que no existen.\nnum_range(): selecciona variables con nombre combinados con caracteres y números (ejemplo: num_range(\"x\", 1:3) selecciona las variables x1, x2 y x3.\nwhere(): aplica una función a todas las variables y selecciona aquellas para las cuales la función regresa TRUE (por ejemplo: is.numeric() para seleccionar todas las variables numéricas).\nFunción rename()\n\nLa función rename() puede considerarse una extensión de select(). Si bien select() también permite renombrar variables, no resulta muy útil para este fin, ya que descarta todas las variables que no se mencionan explícitamente.\nEn cambio, rename() permite cambiar el nombre de una o más variables sin eliminar las demás. Solo se modifican los nombres indicados, y el resto del conjunto de datos permanece sin cambios.\nEjemplo: renombrar la variable pob como población:\n\ndatos |&gt;\n  rename(\"población\" = pob)\n\n# A tibble: 48 × 4\n   jurisdiccion   año casos población\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;\n 1 Buenos Aires  2015  1513  16626374\n 2 Buenos Aires  2016   957  16789474\n 3 CABA          2015   901   3054237\n 4 CABA          2016   427   3050000\n 5 Catamarca     2015    69    396552\n 6 Catamarca     2016    51    401575\n 7 Chaco         2015    15   1153846\n 8 Chaco         2016     9   1125000\n 9 Chubut        2015   110    567010\n10 Chubut        2016    89    577922\n# ℹ 38 more rows\n\n\nFunción filter()\n\nLa función filter() permite seleccionar filas de un conjunto de datos, produciendo un subconjunto de observaciones.\nVeamos un ejemplo sencillo con nuestros datos:\n\ndatos |&gt;\n  filter(jurisdiccion == \"Tucuman\")\n\n# A tibble: 2 × 4\n  jurisdiccion   año casos     pob\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n1 Tucuman       2015   258 1592593\n2 Tucuman       2016   246 1618421\n\n\nUtiliza los mismos operadores de comparación propios del lenguaje R:\n\n\n\n\nOperador\nDescripción\n\n\n\n&lt;\nMenor que\n\n\n&gt;\nMenor que\n\n\n&lt;=\nMenor o igual que\n\n\n&gt;=\nMayor o igual que\n\n\n==\nIgual que\n\n\n!=\nNo igual que\n\n\n%in%\nEs parte de\n\n\nis.na()\nEs un valor ausente\n\n\n!is.na()\nNo es un valor ausente\n\n\n\n\n\nLo mismo con los operadores lógicos que se utilizan como conectores entre las expresiones:\n\n\n\n\nOperador\nDescripción\n\n\n\n&\nAND booleano\n\n\n|\nOR booleano\n\n\nxor()\nOR exclusivo\n\n\n!\nNOT\n\n\nany()\ncualquier TRUE\n\n\nall()\ntodos TRUE\n\n\n\n\n\nCuando usamos múltiples argumentos separados por coma dentro de filter(), estas se combinan con un operador AND implícito, es decir, cada expresión debe ser verdadera para que la fila sea incluida en la salida.\nPor ejemplo, filtramos las observaciones que cumplan que casos sea mayor a 100 y que pob sea menor a 1.000.000:\n\ndatos |&gt;\n  filter(casos &gt; 100, pob &lt; 1000000)\n\n# A tibble: 7 × 4\n  jurisdiccion   año casos    pob\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1 Chubut        2015   110 567010\n2 Jujuy         2015   160 727273\n3 Jujuy         2016   133 734807\n4 Neuquen       2015   109 619318\n5 Neuquen       2016   101 627329\n6 Rio Negro     2015   112 700000\n7 Rio Negro     2016   105 709459\n\n\nPara combinar condiciones dentro de una misma variable usamos el operador OR (|) o, de forma más práctica, %in%:\n\n# Con OR\ndatos |&gt;\n  filter(jurisdiccion == \"Buenos Aires\" | jurisdiccion == \"La Pampa\")\n\n# A tibble: 4 × 4\n  jurisdiccion   año casos      pob\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n1 Buenos Aires  2015  1513 16626374\n2 Buenos Aires  2016   957 16789474\n3 La Pampa      2015    57   343373\n4 La Pampa      2016    67   345361\n\n# Con %in%\ndatos |&gt;\n  filter(jurisdiccion %in% c(\"Buenos Aires\", \"La Pampa\"))\n\n# A tibble: 4 × 4\n  jurisdiccion   año casos      pob\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n1 Buenos Aires  2015  1513 16626374\n2 Buenos Aires  2016   957 16789474\n3 La Pampa      2015    57   343373\n4 La Pampa      2016    67   345361\n\n\nEn el siguiente ejemplo, filtramos observaciones del año 2016 con más de 200 casos. El uso de & es equivalente al uso de coma:\n\ndatos |&gt;\n  filter(año == \"2016\" & casos &gt; 200)\n\n# A tibble: 6 × 4\n  jurisdiccion   año casos      pob\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n1 Buenos Aires  2016   957 16789474\n2 CABA          2016   427  3050000\n3 Cordoba       2016   368  3607843\n4 Mendoza       2016   254  1909774\n5 Salta         2016   230  1352941\n6 Tucuman       2016   246  1618421\n\n\nPor último, podemos usar xor() para seleccionar observaciones que cumplan solo una de las condiciones, pero no ambas. Por ejemplo, el siguiente filtro selecciona registros donde el año sea 2016 ó los casos sean mayores a 200, pero no ambos al mismo tiempo (es decir que no se den ambos en TRUE):\n\ndatos |&gt; \n  filter(xor(año == \"2016\", casos &gt; 200))\n\n# A tibble: 25 × 4\n   jurisdiccion   año casos      pob\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n 1 Buenos Aires  2015  1513 16626374\n 2 CABA          2015   901  3054237\n 3 Catamarca     2016    51   401575\n 4 Chaco         2016     9  1125000\n 5 Chubut        2016    89   577922\n 6 Cordoba       2015   468  3572519\n 7 Corrientes    2016    99  1076087\n 8 Entre Rios    2016   109  1329268\n 9 Formosa       2016    60   582524\n10 Jujuy         2016   133   734807\n# ℹ 15 more rows\n\n\nFunción arrange()\n\nLa función arrange() se utiliza para ordenar las filas de un conjunto de datos de acuerdo a una o varias columnas/variables. Por defecto, el ordenamiento es ascendente alfanumérico.\nOrdenamos la tabla por la variable pob (forma ascendente predeterminada):\n\ndatos |&gt;\n  arrange(pob)\n\n# A tibble: 48 × 4\n   jurisdiccion       año casos    pob\n   &lt;chr&gt;            &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n 1 Tierra del Fuego  2015    36 152542\n 2 Tierra del Fuego  2016    34 156682\n 3 Santa Cruz        2015    65 320197\n 4 Santa Cruz        2016    59 329609\n 5 La Pampa          2015    57 343373\n 6 La Pampa          2016    67 345361\n 7 La Rioja          2015    41 369369\n 8 La Rioja          2016     6 375000\n 9 Catamarca         2015    69 396552\n10 Catamarca         2016    51 401575\n# ℹ 38 more rows\n\n\nPara ordenar en forma descendente podemos utilizar desc() dentro de los argumentos de arrange():\n\ndatos |&gt;\n  arrange(desc(pob))\n\n# A tibble: 48 × 4\n   jurisdiccion   año casos      pob\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n 1 Buenos Aires  2016   957 16789474\n 2 Buenos Aires  2015  1513 16626374\n 3 Cordoba       2016   368  3607843\n 4 Cordoba       2015   468  3572519\n 5 Santa Fe      2016   170  3400000\n 6 Santa Fe      2015   301  3382022\n 7 CABA          2015   901  3054237\n 8 CABA          2016   427  3050000\n 9 Mendoza       2016   254  1909774\n10 Mendoza       2015   316  1880952\n# ℹ 38 more rows\n\n\nPodemos combinar ordenamientos. Por ejemplo, en forma alfabética ascendente para jusrisdiccion y luego numérica descendente para casos:\n\ndatos |&gt;\n  arrange(jurisdiccion, desc(casos))\n\n# A tibble: 48 × 4\n   jurisdiccion   año casos      pob\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n 1 Buenos Aires  2015  1513 16626374\n 2 Buenos Aires  2016   957 16789474\n 3 CABA          2015   901  3054237\n 4 CABA          2016   427  3050000\n 5 Catamarca     2015    69   396552\n 6 Catamarca     2016    51   401575\n 7 Chaco         2015    15  1153846\n 8 Chaco         2016     9  1125000\n 9 Chubut        2015   110   567010\n10 Chubut        2016    89   577922\n# ℹ 38 more rows\n\n\nFunción mutate()\n\nEsta función nos permite transformar variables dentro de un conjunto de datos. A menudo tendremos la necesidad de modificar variables existentes o crear nuevas variables a partir de las ya disponibles. La función mutate() nos ofrece una forma clara y eficiente de realizar este tipo de operaciones.\nPor ejemplo, podríamos querer calcular tasas crudas para cada jurisdicción y año, en función del número de casos y de la población total:\n\ndatos |&gt;\n  mutate(\n    tasa = casos/pob*100000\n  )\n\n# A tibble: 48 × 5\n   jurisdiccion   año casos      pob  tasa\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1 Buenos Aires  2015  1513 16626374  9.10\n 2 Buenos Aires  2016   957 16789474  5.70\n 3 CABA          2015   901  3054237 29.5 \n 4 CABA          2016   427  3050000 14   \n 5 Catamarca     2015    69   396552 17.4 \n 6 Catamarca     2016    51   401575 12.7 \n 7 Chaco         2015    15  1153846  1.30\n 8 Chaco         2016     9  1125000  0.8 \n 9 Chubut        2015   110   567010 19.4 \n10 Chubut        2016    89   577922 15.4 \n# ℹ 38 more rows\n\n\nEn este caso, mutate() calcula la tasa cruda por 100.000 habitantes e incorpora una nueva variable (tasa) con los resultados correspondientes a cada observación.\nTambién se pueden construir múltiples variables en la misma expresión, solamente separadas por comas:\n\ndatos |&gt;\n  mutate(\n    tasaxcien_mil = casos/pob*100000,\n    tasaxdiez_mil = casos/pob*10000\n  )\n\n# A tibble: 48 × 6\n   jurisdiccion   año casos      pob tasaxcien_mil tasaxdiez_mil\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n 1 Buenos Aires  2015  1513 16626374          9.10         0.910\n 2 Buenos Aires  2016   957 16789474          5.70         0.570\n 3 CABA          2015   901  3054237         29.5          2.95 \n 4 CABA          2016   427  3050000         14            1.4  \n 5 Catamarca     2015    69   396552         17.4          1.74 \n 6 Catamarca     2016    51   401575         12.7          1.27 \n 7 Chaco         2015    15  1153846          1.30         0.130\n 8 Chaco         2016     9  1125000          0.8          0.08 \n 9 Chubut        2015   110   567010         19.4          1.94 \n10 Chubut        2016    89   577922         15.4          1.54 \n# ℹ 38 more rows\n\n\nSi deseamos que estas nuevas variables se incorporen de forma permanente al conjunto de datos (y no solo se muestren en la consola), debemos utilizar el operador de asignación &lt;-:\n\ndatos &lt;- datos |&gt;\n  mutate(\n    tasaxcien_mil = casos/pob*100000,\n    tasaxdiez_mil = casos/pob*10000\n  )\n\nUn aspecto fundamental es que las funciones utilizadas dentro de mutate() deben estar vectorizadas: deben aceptar un vector de entrada y devolver otro vector del mismo tamaño como salida.\nExisten muchas funciones que se pueden utilizar dentro de mutate(). A continuación se presentan algunas útiles:\n\nOperadores aritméticos: +, -, *, /, ^.\nAritmética modular: %/% (división entera) y %% (resto), donde x == y * (x %/% y) + (x %% y). Esta herramienta resulta útil para dividir números enteros en porciones.\nFunciones matemáticas: log(), log2(), log10(), exp(), sqrt(), abs(), entre otras.\nValores acumulados: R ofrece funciones como cumsum(), cumprod(), cummin(), cummax() y dplyr incluye cummean() para promedios acumulados.\nClasificación o ranking: funciones como min_rank() permiten asignar rangos (1º, 2º, etc.). Por defecto, los valores más pequeños reciben rangos más bajos. Si se desea invertir el orden, puede utilizarse desc(x).\n\nFinalmente, si se utiliza en mutate() el mismo nombre de una variable que ya existe en la tabla, dicha variable será sobrescrita (por ejemplo, al cambiarle el tipo de character a factor). Si se desea crear una variable nueva, se debe utilizar un nombre que no esté previamente en el conjunto de datos.\nFunción summarise()\n\nLa función summarise() o summarize() se utiliza para calcular resúmenes estadísticos a partir de una o más variables de un conjunto de datos.\nPor ejemplo, podemos calcular el promedio y el total de casos:\n\ndatos |&gt;\n  summarise(\n    promedio_casos = mean(casos), \n    casos_totales = sum(casos)\n  )\n\n# A tibble: 1 × 2\n  promedio_casos casos_totales\n           &lt;dbl&gt;         &lt;dbl&gt;\n1           192.          9211\n\n\nSu uso es muy interesante cuando la combinamos con group_by() (función que detallaremos luego). Esta situación permite estratificar los resultados por grupos específicos.\nPor ejemplo, podemos agrupar el por año y simultáneamente aplicar el mismo summarise() anterior:\n\ndatos |&gt; \n  group_by(año) |&gt; \n  summarise(\n    promedio_casos = mean(casos), \n    casos_totales = sum(casos)\n  )\n\n# A tibble: 2 × 3\n    año promedio_casos casos_totales\n  &lt;dbl&gt;          &lt;dbl&gt;         &lt;dbl&gt;\n1  2015           224.          5369\n2  2016           160.          3842\n\n\nEl resultado es una tabla con dos filas, una para cada grupo (año 2015 y año 2016) con los valores promedio y casos totales respectivos.\nAlgunas de las funciones del R base que se pueden utilizar dentro de los argumentos de esta función son:\n\n\nmin(): mínimo\n\nmax(): máximo\n\nmean(): media\n\nmedian(): mediana\n\nvar(): varianza\n\nsd(): desvío\n\nsum(): sumatoria\n\nOtras funciones que se pueden incorporar las provee el mismo paquete dplyr, por ejemplo:\n\n\nfirst(): primer valor en el vector.\n\nlast(): último valor en el vector.\n\nn(): número de valores en el vector.\n\nn_distinct(): números de valores distintos en el vector.\nFunción group_by()\n\nComo mencionamos anteriormente, la función group_by() resulta especialmente útil cuando se utiliza en combinación con summarise(), dado que agrupa un conjunto de filas seleccionado según los valores de una o más columnas antes de aplicar funciones de resumen.\nAl aplicar group_by(), el conjunto de datos se estructura internamente en subgrupos definidos por las variables indicadas. Las funciones que se apliquen a continuación (por ejemplo, summarise() o mutate()) se ejecutarán dentro de cada grupo de forma independiente.\nPor ejemplo, podemos calcular las tasas crudas por 100.000 habitantes para cada combinación de jurisdicción y año:\n\ndatos |&gt;\n  group_by(jurisdiccion, año) |&gt; \n  summarise(tasa = casos/pob*100000)\n\n# A tibble: 48 × 3\n# Groups:   jurisdiccion [24]\n   jurisdiccion   año  tasa\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;\n 1 Buenos Aires  2015  9.10\n 2 Buenos Aires  2016  5.70\n 3 CABA          2015 29.5 \n 4 CABA          2016 14   \n 5 Catamarca     2015 17.4 \n 6 Catamarca     2016 12.7 \n 7 Chaco         2015  1.30\n 8 Chaco         2016  0.8 \n 9 Chubut        2015 19.4 \n10 Chubut        2016 15.4 \n# ℹ 38 more rows\n\n\nEn la mayoría de estos ejemplos, la salida es directa, es decir, no construimos nuevos objetos. Sin embargo, en muchas situaciones vamos a necesitar conservar los resultados obtenidos, asignándolos a un nuevo objeto.\nAdemás, si en algún momento aplicamos group_by() y luego queremos continuar trabajando con los datos sin agrupamientos, podemos utilizar la función ungroup(), que elimina la estructura de agrupamiento:\n\ndatos |&gt; \n  group_by(jurisdiccion, año) |&gt; \n  summarise(tasa = casos / pob * 100000) |&gt; \n  ungroup()\n\n# A tibble: 48 × 3\n   jurisdiccion   año  tasa\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;\n 1 Buenos Aires  2015  9.10\n 2 Buenos Aires  2016  5.70\n 3 CABA          2015 29.5 \n 4 CABA          2016 14   \n 5 Catamarca     2015 17.4 \n 6 Catamarca     2016 12.7 \n 7 Chaco         2015  1.30\n 8 Chaco         2016  0.8 \n 9 Chubut        2015 19.4 \n10 Chubut        2016 15.4 \n# ℹ 38 more rows\n\n\nEsto resulta útil cuando queremos realizar otras operaciones posteriores que no dependen de los grupos definidos previamente.\nCombinaciones\nEn los ejemplos anteriores vimos cómo se van integrando algunas de las funciones mediante el uso del operador de tubería %&gt;% o |&gt;. La idea detrás de esta “gramática de los datos” que propone el paquete dplyr es poder encadenar acciones de forma legible y lógica, construyendo oraciones más complejas paso a paso.\nVeamos un ejemplo que integra muchas de las funciones vistas hasta ahora:\n\nObtener una nueva tabla con las tasas crudas de casos notificados de VIH, por año y jurisdicción, mayores a 20 por 100.000 habitantes, ordenadas de mayor a menor.\n\n\ndatos |&gt;                                  # siempre partimos de los datos\n  group_by(año, jurisdiccion) |&gt;          # agrupamos\n  summarise(tasa = casos/pob*100000) |&gt;   # resumimos\n  filter(tasa &gt; 20) |&gt;                    # filtramos\n  arrange(desc(tasa))                     # ordenamos   \n\n# A tibble: 5 × 3\n# Groups:   año [2]\n    año jurisdiccion      tasa\n  &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt;\n1  2015 CABA              29.5\n2  2015 Tierra del Fuego  23.6\n3  2015 Jujuy             22.0\n4  2016 Tierra del Fuego  21.7\n5  2015 Santa Cruz        20.3\n\n\nUna buena práctica para construir este tipo de código es escribir cada paso de la operación en una línea separada. Esto no solo mejora la legibilidad, sino que facilita la identificación de errores o la modificación de pasos específicos.\nEste ejemplo muestra claramente el poder y la claridad que se logran al combinar funciones como group_by(), summarise(), filter() y arrange() en una misma operación fluida y coherente.\nFunción count()\n\nEsta función permite contar rápidamente los valores únicos de una o más variables en un conjunto de datos. Es especialmente útil para crear tablas de frecuencias absolutas, que posteriormente pueden ser usadas para calcular frecuencias relativas.\nUn ejemplo básico de su uso es contar las observaciones por cada valor único de la variable jurisdiccion en el conjunto de datos:\n\ndatos |&gt;\n  count(jurisdiccion)\n\n# A tibble: 24 × 2\n   jurisdiccion     n\n   &lt;chr&gt;        &lt;int&gt;\n 1 Buenos Aires     2\n 2 CABA             2\n 3 Catamarca        2\n 4 Chaco            2\n 5 Chubut           2\n 6 Cordoba          2\n 7 Corrientes       2\n 8 Entre Rios       2\n 9 Formosa          2\n10 Jujuy            2\n# ℹ 14 more rows\n\n\nTiene un par de argumentos opcionales:\n\nname: Define el nombre de la columna que contendrá el conteo. Por defecto, esta columna se llama n.\nsort: Ordena la tabla de frecuencias de mayor a menor (por defecto, no realiza ninguna ordenación).\nwt: Permite incorporar una variable que funcione como ponderación (o factor de expansión) para el cálculo de la frecuencia.",
    "crumbs": [
      "Unidad 1",
      "Introducción a tidyverse"
    ]
  },
  {
    "objectID": "unidad_1/intro_tidyverse.html#gráficos-estadísticos-con-ggplot2",
    "href": "unidad_1/intro_tidyverse.html#gráficos-estadísticos-con-ggplot2",
    "title": "Introducción a tidyverse",
    "section": "Gráficos estadísticos con ggplot2\n",
    "text": "Gráficos estadísticos con ggplot2\n\n\n\n\n\nEl paquete ggplot2 (Wickham 2016) se autodefine como una librería para “crear elegantes visualizaciones de datos utilizando una gramática de gráficos”. Proporciona una forma intuitiva de construir gráficos basada en The Grammar of Graphics a través de un sistema basado en tres componentes básicos:\n\ndatos\ncoordenadas\nobjetos geométricos\n\nLa estructura para construir un gráfico es la siguiente:\n\n\n\n\nAnatomía de gráficos con ggplot2\n\nLa estructura básica para construir un gráfico con ggplot2 se organiza a partir de una gramática de gráficos, que se puede entender a través de sus componentes fundamentales:\n\n\n\n\n\n\ndata: el conjunto de datos que vamos a graficar, que debe contener toda la información necesaria para crear el gráfico.\n\naes(): el mapeo estético (aesthetic mapping) es donde se declaran las variables que se van a mapear en el gráfico (por ejemplo, qué variable va en el eje X, en el eje Y, o cómo se asignan los colores).\n\ngeoms: representaciones gráficas de los datos, como puntos, líneas, barras, cajas, entre otros. Son los “objetos geométricos” que realmente dibujan el gráfico.\n\nstats: Transformaciones estadísticas que se realizan sobre los datos, como el cálculo de medias, medias móviles o regresiones, que ayudan a hacer un resumen de los datos para visualizarlos mejor.\n\nscales: se utilizan para colorear o escalar los datos según distintas variables. Controlan los ejes y las leyendas.\n\ncoordinate systems: es el sistema de coordenadas para el mapeo del gráfico en un plano bidimensional.\n\nfacets: permiten dividir el conjunto de datos según factores y crear gráficos en paneles separados (viñetas), creando matrices gráficas.\n\ntheme: son conjuntos de características gráficas que permiten controlar la apariencia general de todos los elementos que no son datos, como el color del fondo, el tipo de fuente o los bordes.\n\nAntes de comenzar a mostrar cómo se usan estos componentes en un gráfico, leemos la base de datos de ejemplo “facultad.csv”, que contiene datos ficticios sobre ingresantes a una facultad (por ejemplo, sexo, edad, talla y peso). Usaremos este conjunto de datos para ilustrar los ejemplos gráficos:\n\n# Cargar datos\nfacultad &lt;- read_csv(\"datos/facultad.csv\")\n\n# Mostramos las 6 primeras observaciones\nhead(facultad) \n\n# A tibble: 6 × 18\n     hc sexo   edad ant_diabetes ant_tbc ant_cancer ant_obesidad ant_ecv ant_ht\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;        &lt;chr&gt;   &lt;chr&gt; \n1 26880 M        17 NO           NO      NO         SI           NO      SI    \n2 26775 M        18 SI           NO      NO         NO           NO      NO    \n3 26877 M        18 SI           NO      SI         NO           NO      SI    \n4 26776 M        18 NO           NO      NO         SI           SI      NO    \n5 26718 M        18 NO           NO      NO         NO           NO      SI    \n6 26738 M        18 NO           NO      NO         NO           NO      SI    \n# ℹ 9 more variables: ant_col &lt;chr&gt;, fuma &lt;chr&gt;, edadini &lt;dbl&gt;, cantidad &lt;dbl&gt;,\n#   col &lt;dbl&gt;, peso &lt;dbl&gt;, talla &lt;dbl&gt;, sist &lt;dbl&gt;, diast &lt;dbl&gt;\n\n\nMapeo estético con aes() y capas geométricas (geom_)\nDecíamos que la función aes() hace referencia al contenido estético del gráfico. Es decir, le brinda indicaciones a ggplot2 sobre cómo dibujar los distintos elementos del gráfico: líneas, formas, colores y tamaños.\nEs importante notar que aes() crea una nueva capa vinculada a las variables que se desean mapear, y también agrega automáticamente leyendas cuando corresponde. Al incorporar aes() dentro del llamado a ggplot(), estamos compartiendo la información estética con todas las capas del gráfico. Si deseamos que esa información sólo esté en una de las capas, debemos usar aes() en la capa correspondiente.\nVeamos cómo funciona y cuáles son sus implicancias:\n\nfacultad |&gt;\n  # solo la capa estética aes()\n  ggplot(aes(x = talla, y = peso)) \n\n\n\n\n\n\n\nEste código genera un gráfico vacío que contiene únicamente los ejes especificados (peso y talla), pero aún no muestra los datos. Para visualizar los puntos, debemos agregar una capa geométrica usando geom_point() y enlazarla con el símbolo +:\n\nfacultad |&gt;\n  # mapeo estético\n  ggplot(aes(x = talla, y = peso))  + \n  \n  # agregamos la capa geométrica de puntos\n  geom_point()                    \n\n\n\n\n\n\n\nPodemos diferenciar los puntos según sexo incorporando la variable sexo como argumento del color dentro de aes():\n\nfacultad |&gt;\n  # mapeo estético\n  ggplot(aes(x = talla, y = peso, color = sexo))  + \n  \n  # agregamos la capa geométrica de puntos\n  geom_point()  \n\n\n\n\n\n\n\nTambién es posible superponer otras capas geométricas. Por ejemplo, podemos agregar rectas de regresión para cada grupo según sexo:\n\nfacultad |&gt;\n  # mapeo estético\n  ggplot(aes(x = talla, y = peso, color = sexo))  + \n  \n  # agregamos la capa geométrica de puntos\n  geom_point()  +\n  \n  # agregamos una segunda capa geométrica para la recta de regresión\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\nLa función geom_smooth() permite aplicar distintos métodos de suavizado o ajuste. En este caso usamos \"lm\" para mostrar la recta de regresión lineal entre talla y peso, junto con sus intervalos de confianza.\nA continuación, veremos las diferencias entre incluir aes() en ggplot() (aplicando el mapeo a todo el gráfico) o colocarlo solo dentro de alguna capa geométrica específica:\n\nfacultad |&gt;\n  # mapeo estético\n  ggplot(aes(x = talla, y = peso))  + \n  \n  # agregamos la capa geométrica de puntos coloreada por sexo\n  geom_point(aes(color = sexo))  +\n  \n  # agregamos una segunda capa geométrica para la recta de regresión\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\nEn este ejemplo, el color solo se especifica dentro de geom_point(), por lo que los puntos se dibujan diferenciados por sexo, pero no afecta a la capa de geom_smooth() produciendo solo una línea de regresión para el conjunto de puntos.\nEste comportamiento brinda gran flexibilidad en la construcción de gráficos, permitiendo definir qué capas deben responder a qué mapeos estéticos.\nAlgunas otras funciones de geom_ son:\n\ngeom_line(): gráfico de líneas.\ngeom_boxplot(): gráfico de caja y bigotes (boxplot).\ngeom_histogram(): histograma.\ngeom_density(): curva de densidad.\ngeom_bar(): gráfico de barras.\n\nTodas estas funciones pueden aplicarse sobre los mismos datos, y su uso depende del objetivo del análisis.\nA continuación, algunos ejemplos para visualizar la relación entre sexo y talla utilizando distintas capas geométricas:\n\n# Gráfico de puntos\nfacultad |&gt;\n  ggplot(aes(x = sexo, y = talla, color = sexo)) + \n  # capa geométrica de puntos\n  geom_point()\n\n\n\n\n\n\n# Boxplot\nfacultad |&gt;\n  ggplot(aes(x = sexo, y = talla, color = sexo)) + \n  # capa geométrica de boxplot\n  geom_boxplot()            \n\n\n\n\n\n\n# Entramado de puntos\nfacultad |&gt;\n  ggplot(aes(x = sexo, y = talla, color = sexo)) + \n  # capa geométrica jitter (entramado de puntos)\n  geom_jitter() \n\n\n\n\n\n\n# Gráfico de violín\nfacultad |&gt;\n  ggplot(aes(x = sexo, y = talla, color = sexo)) + \n  # capa geométrica de violin\n  geom_violin()\n\n\n\n\n\n\n\nObservemos que en el último gráfico se usó el argumento fill en lugar de color. Mientras color define el contorno de líneas, curvas o puntos, fill define el relleno de objetos geométricos, como los polígonos en gráficos de violín o barras.\nPersonalización de escalas con scale_\n\nEl sistema de escalas en ggplot2 permite ajustar múltiples aspectos visuales de un gráfico. Podemos modificar colores de contorno y relleno, invertir ejes, cambiar tamaños, tipos de línea, entre muchas otras opciones.\nTodas las funciones relacionadas con escalas comienzan con el prefijo scale_, seguido del atributo que queremos modificar (por ejemplo, scale_fill_ para cambiar el color de relleno).\nA continuación, mostramos algunos ejemplos aplicados sobre el conjunto de datos facultad:\n\nfacultad |&gt;\n  ggplot(aes(x = sexo, y = talla, fill = sexo)) + \n  \n  # capa geométrica boxplot\n  geom_boxplot() +\n  \n  # paleta de naranjas\n  scale_fill_brewer(palette = \"Oranges\")\n\n\n\n\n\n\n\nEn este ejemplo aplicamos una capa scale_fill_brewer() con la paleta de colores \"Oranges\" que se vincula con el argumento fill de aes() y definen los colores del boxplot.\nOtra alternativa es aplicar una escala de grises mediante scale_fill_grey():\n\nfacultad |&gt;\n  ggplot(aes(x = sexo, y = talla, fill = sexo)) + \n  \n  # capa geométrica boxplot\n  geom_boxplot() +\n  \n  # paleta en escala de grises\n  scale_fill_grey(start = 0.4, end = 0.8)\n\n\n\n\n\n\n\n\nRecomendamos trabajar con paletas de colores accesibles para personas con daltonismo y otras discapacidades visuales, como las incluidas en las dependencias RColorBrewer(Neuwirth 2022) y viridisLite, así como en paquetes específicos con paletas colorblind-friendly, como scico (Pedersen y Crameri 2023).\n\nTambién podemos modificar las escalas de los ejes. Por ejemplo, invertir el eje X con scale_x_reverse():\n\nfacultad |&gt;\n  ggplot(aes(x = talla, y = peso, fill = sexo)) + \n  \n  # capa geométrica de puntos\n  geom_point() +\n  \n  # invierte el eje x\n  scale_x_reverse()\n\n\n\n\n\n\n\nLa inclusión de scale_x_reverse() provoca la variable talla se muestre en orden descendente, de mayor a menor.\nPor último, podemos personalizar los cortes del eje Y utilizando scale_y_continuous(). Por ejemplo, en el boxplot pintado en escala de grises, definimos que el eje Y comienza en 130cm y termina en 200cm, con cortes cada 5cm y etiquetas cada 10cm:\n\nfacultad |&gt;\n  ggplot(aes(x = sexo, y = talla, fill = sexo)) + \n  \n  # capa geométrica boxplot\n  geom_boxplot() +\n  \n  # paleta en escala de grises\n  scale_fill_grey(start = 0.4, end = 0.8)   +\n  \n  # puntos de corte del eje Y\n  scale_y_continuous(limits = c(130, 200),       # límites\n                     breaks = seq(130, 200, 10)) # nro de etiquetas\n\n\n\n\n\n\n\nTransformaciones estadísticas con stat_\n\nAlgunos gráficos en ggplot2 no requieren transformaciones estadísticas, como los gráficos de dispersión. Sin embargo, otros tipos —como boxplots, histogramas o líneas de tendencia— sí aplican transformaciones estadísticas predeterminadas que pueden ser modificadas o personalizadas.\nEstas transformaciones pueden formar parte de las funciones geométricas, como ocurre en los histogramas, o agregarse como capas independientes mediante funciones stat_.\nPor ejemplo, en los histogramas podemos definir la cantidad de intervalos (o “clases”) a través del argumento bins, que forma parte de geom_histogram():\n\nfacultad |&gt;\n  ggplot(aes(edad)) +\n  \n  # capa geométrica histograma\n  geom_histogram(bins = nclass.Sturges(facultad$edad), \n                 fill = \"Blue\")\n\n\n\n\n\n\n\nEn este caso, utilizamos la regla de Sturges —a través de la función nclass.Sturges()— para determinar automáticamente la cantidad de clases para la variable edad.\nTambién podemos superponer al gráfico transformaciones estadísticas como capas adicionales. Por ejemplo, si deseamos agregar la media de talla en cada grupo de sexo sobre un boxplot, utilizamos stat_summary():\n\nfacultad |&gt;\n  ggplot(aes(x = sexo, y = talla, fill = sexo)) + \n  \n  # capa geométrica boxplot\n  geom_boxplot() +\n  \n  # paleta de tonos verdes\n  scale_fill_brewer(palette = \"Greens\") +\n  \n  # añade capa summary\n  stat_summary(fun = mean, \n               color = \"darkred\", \n               geom = \"point\", \n               shape = 18, \n               size = 3)\n\n\n\n\n\n\n\nLa función stat_summary() permite aplicar funciones estadísticas como mean, median, sd, entre otras, y representar el resultado con un objeto geométrico, en este caso geom = \"point\". En el gráfico, la media de talla se muestra con un punto rojo oscuro (color = \"darkred\"), de forma romboidal (shape = 18) y tamaño ampliado (size = 3).\nFacetado con facet_\n\nEl facetado permite dividir un gráfico en múltiples paneles o viñetas según los niveles de una o más variables categóricas. Esto resulta especialmente útil cuando se desea comparar patrones entre grupos sin sobrecargar un único gráfico con demasiada información.\nggplot2 ofrece dos funciones principales para realizar esta tarea:\n\nfacet_wrap(): separa los datos según una única variable categórica, generando una serie de paneles dispuestos de forma automática en filas y columnas.\nfacet_grid(): permite crear una matriz de paneles cruzando dos variables categóricas, una para las filas y otra para las columnas.\n\nRetomemos el gráfico de dispersión entre talla y peso, y generemos paneles separados para cada nivel de la variable sexo con facet_wrap():\n\nfacultad |&gt;\n  \n  ggplot(aes(x = talla, y = peso, color = sexo)) +\n  \n  # capa geométrica de puntos\n  geom_point() +\n  \n  # separa en paneles por sexo\n  facet_wrap(~ sexo)\n\n\n\n\n\n\n\nUsaremos facet_grid() para crear una matriz de histogramas producto del cruce de las variables fuma y sexo. Dentro de la cuadrícula graficaremos histogramas de la variable peso coloreados por sexo:\n\nfacultad |&gt;\n  ggplot(aes(y = peso, fill = sexo)) +\n  \n  # capa geométrica histograma\n  geom_histogram(bins = nclass.Sturges(facultad$peso)) +\n  \n  # paleta de colores\n  scale_fill_brewer(palette = \"Set1\") +\n  \n  # separa en paneles por sexo y fuma\n  facet_grid(sexo ~ fuma)\n\n\n\n\n\n\n\nComo se puede ver en estos ejemplos, estamos integrando varias de las funciones vistas: mapeo estético, capas geométricas, escalas, y ahora también el facetado.\nEl número de combinaciones posibles es enorme, dada la variedad de funciones y argumentos que ofrece ggplot2. Sin embargo, el objetivo de este material es comprender los principios fundamentales sobre los que se construye esta “gramática de los gráficos”, propuesta por los autores del paquete.\nSistema de coordenadas con coord_\n\nEn algunas ocasiones, puede ser útil modificar el sistema de coordenadas predeterminado del gráfico. Por ejemplo, para invertir los ejes y presentar un gráfico de barras en disposición horizontal:\n\nfacultad |&gt;\n  \n  ggplot(aes(sexo, fill = sexo)) +\n  \n  # capa geométrica barras\n  geom_bar() +\n  \n  # paleta de colores\n  scale_fill_brewer(palette = \"Set2\") +\n  \n  # invierte disposición de ejes\n  coord_flip()   \n\n\n\n\n\n\n\nTemas con theme()\n\nggplot2 incluye un conjunto de temas gráficos predefinidos que permiten modificar el aspecto general del gráfico. El tema por defecto es theme_gray(), pero puede cambiarse agregando una capa theme_*() dentro del gráfico.\nRepetimos el gráfico anterior, esta vez utilizando el tema blanco y negro (theme_bw()):\n\nfacultad |&gt;\n  \n  ggplot(aes(sexo, fill = sexo)) +\n  \n  # capa geométrica barras\n  geom_bar() +\n  \n  # paleta de colores\n  scale_fill_brewer(palette = \"Set2\") +\n  \n  # invierte disposición de ejes\n  coord_flip() +\n  \n  # tema en blanco y negro\n  theme_bw()\n\n\n\n\n\n\n\nTambién podemos aplicar un tema de fondo oscuro con theme_dark():\n\nfacultad |&gt;\n  \n  ggplot(aes(sexo, fill = sexo)) +\n  \n  # capa geométrica barras\n  geom_bar() +\n  \n  # paleta de colores\n  scale_fill_brewer(palette = \"Set2\") +\n  \n  # invierte disposición de ejes\n  coord_flip() +\n  \n  # tema con fondo oscuro\n  theme_dark()\n\n\n\n\n\n\n\nA continuación se muestra un cuadro con los principales temas disponibles en ggplot2 y sus características visuales:\n\n\n\n\nAdemás del aspecto general del gráfico, es posible agregar títulos, subtítulos y etiquetas de ejes con la función labs(). Por ejemplo:\n\nlabs(\n  x = \"Etiqueta X\", \n  y = \"Etiqueta Y\", \n  title = \"Título del gráfico\", \n  subtitle = \"Subtítulo del gráfico\"\n)\n\nTambién se pueden ajustar detalles del texto, como tipo de fuente o tamaño, mediante la función theme():\n\nfacultad |&gt;\n  ggplot(aes(sexo, fill = sexo)) +\n  # capa geométrica barras\n  geom_bar() +\n  # paleta de colores\n  scale_fill_brewer(palette = \"Set2\") +\n  # invierte disposición de ejes\n  coord_flip() +\n  # cambia etiquetas de los ejes\n  labs(y = \"Cantidad\", \n       title = \"Distribución de sexo\") +\n  # modifica el estilo de fuente del título\n  theme(plot.title = element_text(face = \"italic\", \n                                  size = 16)) \n\n\n\n\n\n\n\nPaquete esquisse\n\n\n\n\n\nEl paqueteesquisse (Meyer y Perrier 2025) es una extensión de ggplot2 que permite crear gráficos de manera interactiva, mediante una interfaz gráfica intuitiva basada en el sistema de arrastrar y soltar (drag & drop).\nCon esquisse es posible:\n\nExplorar visualmente los datos según su tipo.\nAsignar variables a diferentes estéticas del gráfico (ejes, color, tamaño, etc.).\nExportar los resultados en distintos formatos.\nRecuperar el código R que genera el gráfico, facilitando su reproducción y modificación.\n\nEl paquete se instala mediante el menú Packages de RStudio o ejecutando:\n\ninstall.packages(\"esquisse\")\n\nLuego se puede acceder a la aplicación por medio del acceso Addins:\n\n\n\n\no ejecutando en consola:\n\nesquisser()\n\nTambién se puede agregar el nombre de la tabla de datos dentro de los paréntesis\n\nesquisser(datos)\n\nPara más detalles, se puede consultar la viñeta del paquete disponible en CRAN o en su repositorio de GitHub.\nOtras extensiones de ggplot2\nUna de las grandes fortalezas de ggplot2 es su ecosistema de extensiones. Hasta el momento, existen más de 140 paquetes desarrollados para ampliar sus funcionalidades, muchos de ellos diseñados para facilitar tareas específicas o agregar nuevas capas, geometrías, temas, escalas o herramientas interactivas.\nAlgunas de las extensiones que utilizaremos durante el curso son:\n\npatchwork(Pedersen 2024): permite combinar múltiples gráficos de ggplot2 en una misma figura de forma sencilla y controlada.\nGGally(Schloerke et al. 2024): extiende ggplot2 con funciones para crear matrices de gráficos (como ggpairs()), útiles para análisis exploratorio multivariado.\nggpubr(Kassambara 2023): facilita la creación de gráficos listos para publicar, con funciones simplificadas para agregar títulos, etiquetas, comparaciones estadísticas y anotaciones.\nsee(Lüdecke et al. 2021): ofrece temas, paletas de colores y escalas compatibles con personas con daltonismo, además de geometrías personalizadas.\nsurvminer(Kassambara, Kosinski, y Biecek 2024): diseñado para la visualización de análisis de supervivencia (como curvas de Kaplan-Meier) utilizando ggplot2.\nggfortify(Tang, Horikoshi, y Li 2016): permite graficar objetos estadísticos como modelos lineales, PCA o series temporales sin necesidad de escribir código ggplot2 desde cero.\n\nEstas extensiones permiten ampliar la flexibilidad y expresividad gráfica de ggplot2 sin perder la estructura gramatical que lo caracteriza.",
    "crumbs": [
      "Unidad 1",
      "Introducción a tidyverse"
    ]
  }
]