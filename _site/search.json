[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Curso Epidemiolog√≠a - Nivel Avanzado",
    "section": "",
    "text": "¬°Les damos la bienvenida al curso de Epidemiolog√≠a Nivel Avanzado!\n\nEs un gusto recibirles en esta nueva edici√≥n del curso, dise√±ado para profundizar en el an√°lisis de datos provenientes de distintos dise√±os de estudio mediante el uso de modelos estad√≠sticos.\nA lo largo del curso, abordaremos herramientas anal√≠ticas avanzadas que nos permitir√°n modelar adecuadamente la relaci√≥n entre exposiciones y desenlaces en estudios transversales, de casos y controles, de cohortes y experimentales. Nos enfocaremos en la aplicaci√≥n pr√°ctica de estos modelos, en la interpretaci√≥n de resultados y en los supuestos que los sustentan, promoviendo una mirada cr√≠tica sobre su uso en la investigaci√≥n epidemiol√≥gica.\nEsperamos que este espacio sea una experiencia formativa enriquecedora y un nuevo impulso en su desarrollo como investigadoras e investigadores en salud.\n\nEl equipo docente\n\n\n\n\n Volver arribaReutilizaci√≥nCC BY-NC 4.0"
  },
  {
    "objectID": "unidad_1/primeros_pasos.html",
    "href": "unidad_1/primeros_pasos.html",
    "title": "Primeros pasos y generalidades",
    "section": "",
    "text": "Artwork por @allison_horst",
    "crumbs": [
      "Unidad 1",
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "unidad_1/primeros_pasos.html#introducci√≥n-a-rstudio",
    "href": "unidad_1/primeros_pasos.html#introducci√≥n-a-rstudio",
    "title": "Primeros pasos y generalidades",
    "section": "Introducci√≥n a RStudio",
    "text": "Introducci√≥n a RStudio\nRStudio Desktop (2025, Posit Software) es un entorno de desarrollo integrado (IDE, por sus siglas en ingl√©s) dise√±ado espec√≠ficamente para trabajar con el lenguaje R.\nEs una herramienta multiplataforma y de c√≥digo abierto que facilita la programaci√≥n, el an√°lisis de datos y la elaboraci√≥n de informes cient√≠ficos. Ofrece una integraci√≥n fluida con otros componentes del ecosistema de R, como R Markdown, Quarto, control de versiones (por ejemplo, Git) y la gesti√≥n de proyectos.\nRStudio presenta una interfaz unificada compuesta por distintos paneles, lo que permite organizar el trabajo de forma clara y eficiente:\n\n\n\n\n\nEditor de scripts (Source): permite crear y editar scripts de R, as√≠ como documentos R Markdown o Quarto.\nConsola de R (Console): muestra la salida del c√≥digo ejecutado y ejecuta c√≥digo de R de forma inmediata.\nEntorno (Environment): muestra los objetos creados durante la sesi√≥n, como vectores, dataframes o funciones.\nPanel de resultados (Output): presenta los gr√°ficos, tablas, visualizaciones en HTML y tambi√©n incluye un explorador de archivos, visor de paquetes instalados y panel de ayuda.\n\nPara garantizar la reproducibilidad de los resultados, es recomendable evitar el guardado autom√°tico del historial de objetos entre sesiones, ya que puede generar confusi√≥n. Para desactivar esta opci√≥n, ir a Tools &gt; Global Options y desmarcar las casillas de las opciones Workspace y History como se muestra en la siguiente imagen:",
    "crumbs": [
      "Unidad 1",
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "unidad_1/primeros_pasos.html#proyectos-de-rstudio",
    "href": "unidad_1/primeros_pasos.html#proyectos-de-rstudio",
    "title": "Primeros pasos y generalidades",
    "section": "Proyectos de RStudio",
    "text": "Proyectos de RStudio\nLos proyectos de RStudio permiten organizar de forma estructurada todo el material asociado a un an√°lisis: scripts, informes, bases de datos, im√°genes, etc. Cada proyecto se vincula a una carpeta espec√≠fica del sistema de archivos, y RStudio la utiliza como directorio de trabajo por defecto. Esta carpeta puede estar ubicada en cualquier parte del sistema de almacenamiento que deseemos (disco r√≠gido, pendrive, disco externo, etc).\nTrabajar con proyectos facilita la importaci√≥n de datos y evita errores relacionados con rutas relativas o absolutas.\nCrear un proyecto\nPara crear un nuevo proyecto, se puede utilizar el men√∫ File &gt; New Project.... Tambi√©n accedemos a generar un proyecto nuevo a partir de pulsar el acceso directo New Project... ubicado en la esquina superior derecha de la interfaz:\n\n\n\n\nEn cualquiera de los dos casos aparecer√° un cuadro de di√°logo que presenta tres opciones para crear el nuevo proyecto de RStudio:\n\n\n\n\n\nNew Directory: crea una nueva carpeta para el proyecto a la que deberemos asignarle un nombre, es la opci√≥n m√°s habitual. Todos los archivos de configuraci√≥n aparecer√°n asociados a esta nueva carpeta.\nExisting Directory: vincula el proyecto a una carpeta ya existente que contenga archivos previos con los que deseamos trabajar.\nVersion Control: permite clonar un repositorio (Git o SVN). Esta opci√≥n no se utilizar√° durante el curso.\n\nUna vez que creamos un nuevo proyecto con la opci√≥n New Directory, aparecer√° una pantalla con una lista de tipos de proyectos que se pueden crear en RStudio:\n\n\n\n\nDurante este curso utilizaremos siempre la primera opci√≥n (New Project). Las dem√°s opciones est√°n pensadas para usos m√°s espec√≠ficos, como el desarrollo de paquetes de R, sitios web o documentos con Quarto o R Markdown.\nAl seleccionar New Project, se abrir√° una nueva ventana con los siguientes campos:\n\nDirectory name: aqu√≠ debemos escribir el nombre del nuevo directorio (carpeta) que tambi√©n ser√° el nombre del proyecto. Por ejemplo, podemos llamarlo Practicas_R.\nCreate project as subdirectory of: este campo permite definir en qu√© ubicaci√≥n del sistema de archivos se guardar√° el proyecto. Podemos hacer clic en el bot√≥n Browse‚Ä¶ para abrir el explorador de archivos y seleccionar la carpeta contenedora. En nuestro ejemplo, lo ubicaremos dentro de Mis Documentos.\n\n\n\n\n\nUna vez completados estos campos, hacemos clic en Create Project.\nLos proyectos en RStudio tienen entornos independientes, lo que significa que si cerramos un proyecto o cambiamos a otro, la configuraci√≥n de cada uno se mantendr√° inalterable sin interferir con los dem√°s.\nEsto incluye los scripts abiertos, el directorio de trabajo, las pesta√±as que dejamos activas y otros elementos del entorno que puedan ser necesarios para continuar con un an√°lisis. Este sistema permite mantener organizados los distintos trabajos que llevamos adelante.\nEchemos un vistazo a lo que RStudio realiz√≥:\n\nEn primer lugar el panel Files (pantalla inferior derecha) apunta a la nueva carpeta Practicas_R y dentro de ella vemos un nuevo archivo el nombre del proyecto y la extensi√≥n .Rproj. Este archivo contiene todas las configuraciones para su proyecto.\nEl otro cambio se observa en la parte superior derecha, que muestra el nombre del proyecto. Si hacemos click en √©l, se desplegar√° el men√∫ de proyectos. Desde aqu√≠ se puede abrir y cerrar proyectos, navegar r√°pidamente a proyectos que se han abierto recientemente y configurar las opciones de RStudio para cada uno de ellos.\n\n\n\n\n\nAbrir un proyecto existente\nCuando el proyecto ya existe, sea porque lo creamos nosotros o porque alguien nos pas√≥ una carpeta con un proyecto de RStudio creado vamos a visualizar dentro de esa carpeta un archivo con extensi√≥n .Rproj.\nLa forma m√°s veloz para abrir el proyecto es ejecutar este archivo (deber√≠a abrir una sesi√≥n de RStudio con el proyecto activo). La otra forma es desde el men√∫ superior derecho de RStudio en la opci√≥n Open project‚Ä¶ y luego buscando en nuestro directorio el mismo archivo .Rproj.\n\n\n\n\n\n\nNota\n\n\n\nEl men√∫ de proyectos del √°rea superior derecha va guardando como elementos recientes los proyectos que se van abriendo y tambi√©n es una forma r√°pida de acceder a ellos pulsando sobre estos atajos.",
    "crumbs": [
      "Unidad 1",
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "unidad_1/primeros_pasos.html#scripts-en-rstudio",
    "href": "unidad_1/primeros_pasos.html#scripts-en-rstudio",
    "title": "Primeros pasos y generalidades",
    "section": "Scripts en RStudio",
    "text": "Scripts en RStudio\nComo vimos anteriormente, un script es un archivo de c√≥digo que contiene una secuencia de instrucciones escritas en R. Estos scripts pueden ser reutilizados, modificados y compartidos, lo que los convierte en una herramienta fundamental para garantizar la reproducibilidad del trabajo.\nCrear un nuevo script\nTenemos varias formas de crear un script nuevo:\n\nDesde el men√∫ superior: File &gt; New File &gt; R Script\nCon el atajo de teclado: Ctrl + Shift + N\nDesde la barra de herramientas: presionando el √≠cono \nEjecutar scripts\nLa forma habitual de ejecutar el contenido de un script es l√≠nea por l√≠nea, usando alguna de las siguientes opciones:\n\nPresionando el bot√≥n  del editor de c√≥digo de RStudio\nMediante el atajo de teclado Ctrl + Enter\n\nPara ejecutar una l√≠nea, simplemente ubicamos el cursor en cualquier parte de ella y presionamos el comando correspondiente. Luego de ejecutarse, el cursor avanzar√° autom√°ticamente a la siguiente l√≠nea de c√≥digo.\nMientras ejecutamos cada l√≠nea debemos ir observando la salida en la consola (panel inferior izquierdo) y tambi√©n los cambios que se dan en el panel Environment (panel superior derecho) donde aparecer√°n los objetos que vayamos creando y manipulando.\nEdici√≥n de scripts\nModificar o agregar l√≠neas al script puede hacerse directamente en el editor. Cada vez que realizamos un cambio, es necesario volver a ejecutar la l√≠nea o bloque modificado para que los cambios se reflejen en el entorno de trabajo.\nPodemos probar y modificar tantas veces como sea necesario. Sin embargo, debemos tener presente que cada manipulaci√≥n en los objetos se mantiene hasta que se vuelvan a cambiar y a veces, cuando los objetos est√°n vinculados con otras l√≠neas de c√≥digo posteriores tenemos que tener cuidado que se mantenga la consistencia del script.\nPor ejemplo: si definimos un vector num√©rico para realizar c√°lculos matem√°ticos, pero luego lo sobrescribimos con un valor de tipo caracter, los c√°lculos posteriores producir√°n un error y RStudio nos informar√° de esto en la consola.\nPor eso, es clave observar el contenido de los objetos en el panel Environment, lo que nos ayuda a evitar errores y operaciones incoherentes.\nGuardado de scripts\nCualquier agregado o modificaci√≥n que hayamos realizado al script y nos interese mantener nos obligar√° a guardar el archivo de c√≥digo editado.\nExisten distintas formas de guardar un script:\n\nDesde el men√∫ superior: File &gt; Save\nCon el atajo de teclado: Ctrl + S\nPresionando el √≠cono del disquete azul üíæ\n\nSi en cambio quisiera guardarlo como otro archivo para mantener el script original, podemos guardarlo con diferente nombre o en otra ubicaci√≥n mediante File &gt; Save As...\nAbrir scripts existentes\nLos scripts que construyamos o nos compartan siempre tendr√°n extensi√≥n .R y, por lo general, se encontrar√°n dentro de un proyecto.\nPara abrir estos archivos .R podemos:\n\nDesde el men√∫ superior: File &gt; Open file...\nCon el atajo de teclado: Ctrl + O\nHaciendo click sobre el archivo desde el panel Files\nPresionando el bot√≥n de la carpeta amarilla üìÇ\n\nEsto abrir√° el script en una nueva pesta√±a dentro del editor de c√≥digo.\n¬øC√≥mo trabajaremos en este curso?\nEn general, utilizaremos scripts dentro de proyectos de RStudio. La secuencia recomendada ser√°:\n\nDescargar desde el Aula Virtual un archivo comprimido conteniendo la carpeta, el proyecto, los scripts y archivos de datos.\nDescomprimir el archivo en la ubicaci√≥n que deseamos (recomendamos crear una carpeta destinada al curso).\nAbrir la carpeta y ejecutar el archivo de proyecto .Rproj.\nUna vez abierto RStudio con el proyecto activo, ubicamos los scripts desde el panel Files.\nEjecutar cada l√≠nea del script, leyendo la documentaci√≥n del c√≥digo y observando la salida en la consola y los cambios en el entorno",
    "crumbs": [
      "Unidad 1",
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "unidad_1/primeros_pasos.html#herramientas-de-rstudio",
    "href": "unidad_1/primeros_pasos.html#herramientas-de-rstudio",
    "title": "Primeros pasos y generalidades",
    "section": "Herramientas de RStudio",
    "text": "Herramientas de RStudio\nAlgunas de las herramientas fundamentales de RStudio son el asistente de c√≥digo, la ayuda en l√≠nea y el historial de comandos.\nAsistente de c√≥digo\nAl escribir en el editor o la consola, la tecla Tab activa el autocompletado de funciones, nombres de objetos y argumentos, agilizando la escritura y reduciendo errores de sintaxis. En versiones recientes, el asistente tambi√©n permite la previsualizaci√≥n de colores en los gr√°ficos, resaltar los par√©ntesis de cierre en funciones anidadas con distintos colores y gestionar autom√°ticamente la indentaci√≥n del c√≥digo.\n\n\n\n\nMuchas de estas opciones se pueden configurar desde el men√∫ Code y desde Tools &gt; Global Options &gt; Code(pesta√±as Editing y Format).\nAyuda en l√≠nea\nAl posicionar el cursor sobre el nombre de una funci√≥n en el editor y presionar F1, se accede directamente a la documentaci√≥n correspondiente en el panel Help (habitualmente ubicado en la esquina inferior derecha).\n\n\n\n\nHistorial de comandos\nEn la consola, al usar las teclas de flecha arriba/abajo, se puede navegar por los comandos ejecutados durante la sesi√≥n actual. Adem√°s, el panel History (parte superior derecha) almacena los comandos de todas las sesiones previas, permitiendo reutilizarlos con un clic en To Console (Enter) o To Source (Shift + Enter), seg√∫n se desee insertarlos en la consola o en el script activo.",
    "crumbs": [
      "Unidad 1",
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "unidad_1/primeros_pasos.html#atajos-de-teclado-windows",
    "href": "unidad_1/primeros_pasos.html#atajos-de-teclado-windows",
    "title": "Primeros pasos y generalidades",
    "section": "Atajos de teclado (Windows)",
    "text": "Atajos de teclado (Windows)\n\n\n\n\nMen√∫\nDescripci√≥n\n\n\n\nArchivo (File)\n\n\n\nCtrl + Shift + N\nCrea un nuevo script\n\n\nCtrl + O\nAbre un script guardado\n\n\nCtrl + S\nGuarda el script activo\n\n\nCtrl + W\nCierra el script activo\n\n\nCtrl + Q\nSale del programa RStudio\n\n\nEdici√≥n (Edit)\n\n\n\nCtrl + F\nAbre la ventana de b√∫squeda (para buscar palabras dentro de un script)\n\n\nCtrl + L\nLimpia la consola\n\n\nC√≥digo (Code)\n\n\n\nCtrl + Enter\nEjecuta la l√≠nea de c√≥digo donde est√° situado el cursor\n\n\nCtrl + Alt + R\nEjecuta todo el c√≥digo del script activo\n\n\nCtrl + Shift + N\nInserta nueva secci√≥n de c√≥digo\n\n\nCtrl + Shift + R\nInserta nueva secci√≥n de comentarios de texto\n\n\nSesi√≥n (Session)\n\n\n\nCtrl + Shift + H\nAbre la ventana para establecer directorio de trabajo\n\n\nCtrl + Shift + F10\nReinicia la sesi√≥n de R\n\n\nHerramientas (Tools)\n\n\n\nAlt + Shift + K\nAbre la lista de ayuda de atajos de teclado",
    "crumbs": [
      "Unidad 1",
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "unidad_1/primeros_pasos.html#paquetes",
    "href": "unidad_1/primeros_pasos.html#paquetes",
    "title": "Primeros pasos y generalidades",
    "section": "Paquetes",
    "text": "Paquetes\nExisten dos formas principales de descargar paquetes: directamente desde RStudio o desde el sitio web de CRAN, descarg√°ndolos como archivos comprimidos. Si el equipo cuenta con conexi√≥n a Internet, lo m√°s pr√°ctico es realizar la descarga directamente desde RStudio. En cambio, si no se dispone de acceso permanente a la red, es posible descargar los paquetes desde otro equipo y luego transferirlos como archivos .zip o .tar.gz al equipo donde se encuentra instalado R.\nCuando accedemos al sitio web de CRAN y buscamos un paquete espec√≠fico, encontraremos informaci√≥n √∫til como una breve descripci√≥n del paquete, el n√∫mero de versi√≥n, la fecha de publicaci√≥n, el nombre del autor, documentaci√≥n asociada y enlaces de descarga espec√≠ficos para cada sistema operativo.\nDado que la mayor√≠a de las computadoras hoy en d√≠a cuentan con acceso a Internet, en este curso nos enfocaremos en la instalaci√≥n y activaci√≥n de paquetes directamente desde RStudio.\nDentro del entorno de RStudio, la gesti√≥n de paquetes se realiza desde la pesta√±a Packages, ubicada en el panel inferior derecho. Esta interfaz facilita tareas como la instalaci√≥n, actualizaci√≥n y activaci√≥n de paquetes, y cada acci√≥n que realizamos desde la interfaz gr√°fica se traduce internamente en la ejecuci√≥n de funciones del lenguaje R que pueden observarse en la consola.\nPara instalar un paquete nuevo, simplemente pulsamos el bot√≥n Install dentro de la pesta√±a Packages, lo cual abrir√° una ventana emergente.\n\n\n\n\nAll√≠ podemos escribir el nombre del paquete que deseamos instalar. Para asegurarnos de que tambi√©n se descarguen e instalen autom√°ticamente los paquetes de los que depende, es importante tildar la opci√≥n Install dependencies.\n\n\n\n\nComo alternativa, tambi√©n podemos realizar la instalaci√≥n desde el editor de scripts mediante el siguiente comando:\n\ninstall.packages(\"nombre_del_paquete\", \n                 dependencies = TRUE)\n\n\n\n\n\n\n\nPara facilitar la instalaci√≥n de los paquetes requeridos durante el curso, recomendamos descargar el archivo ‚ÄúPaquetes de R necesarios‚Äù, descomprimirlo y ejecutar el script que se encuentra en su interior.",
    "crumbs": [
      "Unidad 1",
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "unidad_1/primeros_pasos.html#lectura-de-archivos-de-datos",
    "href": "unidad_1/primeros_pasos.html#lectura-de-archivos-de-datos",
    "title": "Primeros pasos y generalidades",
    "section": "Lectura de archivos de datos",
    "text": "Lectura de archivos de datos\nR permite importar tablas de datos desde diversos formatos, tanto utilizando funciones de R base como funciones provistas por paquetes espec√≠ficos.\nEl formato m√°s com√∫n es el texto plano (ASCII), donde los valores est√°n organizados en columnas separadas por caracteres delimitadores. Los separadores m√°s habituales incluyen:\n\nComa (,)\nPunto y coma (;)\nTabulaci√≥n (\\t)\nBarra vertical (|)\n\nEstos archivos suelen tener una cabecera (header) en la primera fila con los nombres de las variables, y cada columna debe contener datos del mismo tipo (n√∫meros, texto, l√≥gicos, etc.).\nPara importar correctamente un archivo es importante conocer su estructura:\n\nSi incluye o no cabecera.\nQu√© car√°cter se usa como separador.\nEl tipo de codificaci√≥n (UTF-8, Latin1, etc.).\n\nDado que son archivos de texto, pueden visualizarse con editores simples como el Bloc de Notas o desde RStudio, lo que facilita su inspecci√≥n previa.\nPara cargar los datos desde un archivo de texto plano usamos el c√≥digo:\n\ndatos &lt;- read.xxx(\"mis_datos.xxx\")\n\n(Se debe reemplazar read.xxx() por la funci√≥n correspondiente: read.table(), read.csv(), read_delim(), read_excel(), etc., seg√∫n la extensi√≥n del archivo).\nR tambi√©n permite cargar bases de datos incluidas en paquetes instalados mediante:\n\ndata(nombre_datos)\n\ndatos &lt;- nombre_datos",
    "crumbs": [
      "Unidad 1",
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "unidad_1/primeros_pasos.html#buenas-pr√°cticas",
    "href": "unidad_1/primeros_pasos.html#buenas-pr√°cticas",
    "title": "Primeros pasos y generalidades",
    "section": "Buenas pr√°cticas",
    "text": "Buenas pr√°cticas\nAdoptar buenas pr√°cticas desde el inicio mejora la reproducibilidad, facilita el trabajo colaborativo y reduce errores. Algunas recomendaciones clave son:\n\nTrabajar siempre dentro de un proyecto de RStudio (.Rproj). Esto permite organizar los archivos, mantener rutas relativas consistentes y acceder a funcionalidades espec√≠ficas como control de versiones o panel de archivos integrados.\nIncluir al comienzo de cada script las l√≠neas de activaci√≥n de paquetes necesarios, utilizando la funci√≥n library().\nCargar los datos una vez activados los paquetes, para garantizar que todas las funciones requeridas est√©n disponibles.\nDocumentar el c√≥digo mediante comentarios iniciados con #. Esto permite entender qu√© hace cada bloque de c√≥digo, facilitando futuras modificaciones o revisiones.\nUsar espacios e indentaci√≥n adecuada para mejorar la legibilidad. Esto es especialmente importante en estructuras anidadas (como condicionales, bucles o funciones).\n\nUna gu√≠a de estilo ampliamente recomendada ‚Äîaunque no oficial‚Äî es la de tidyverse. Incluye ejemplos concretos de buenas y malas pr√°cticas para nombrar variables, manejar l√≠neas largas, usar sangr√≠as, entre otros aspectos. Al final de la unidad incluimos una versi√≥n resumida de la misma, pero puede consultarse completa en:\n‚û°Ô∏è https://style.tidyverse.org/",
    "crumbs": [
      "Unidad 1",
      "Primeros pasos y generalidades"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html",
    "href": "unidad_1/intro_R.html",
    "title": "Introducci√≥n a R",
    "section": "",
    "text": "Artwork por @allison_horst",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#qu√©-es-r",
    "href": "unidad_1/intro_R.html#qu√©-es-r",
    "title": "Introducci√≥n a R",
    "section": "¬øQu√© es R?",
    "text": "¬øQu√© es R?\nEl sitio oficial r-project.org define a R como ‚Äúun entorno de software libre para gr√°ficos y computaci√≥n estad√≠stica. Se compila y se ejecuta en una amplia variedad de plataformas UNIX, Windows y MacOS.‚Äù\nProfundizando en su descripci√≥n, podemos decir que R es un lenguaje de programaci√≥n interpretado, orientado a objetos, multiplataforma y de c√≥digo abierto (open source) aplicado al manejo y an√°lisis de datos estad√≠sticos.\nA continuaci√≥n, detallamos cada una de sus caracter√≠sticas:\nR es un lenguaje de programaci√≥n estad√≠stico\nSi bien posee un entorno y se puede utilizar como calculadora avanzada o para simulaciones, R es fundamentalmente un lenguaje de programaci√≥n. Presenta una estructura y reglas de sintaxis propias, as√≠ como gran variedad de funciones desarrolladas con fines estad√≠sticos.\nR es un lenguaje orientado a objetos\nR implementa conceptos de la programaci√≥n orientada a objetos, lo cual le permite ofrecer simpleza y flexibilidad en el manejo de datos. En R, todo con lo que trabajamos ‚Äîvariables, funciones, datos, resultados‚Äî son objetos que pueden ser modificados o combinados con otros objetos.\nR es un lenguaje interpretado\nR no requiere compilaci√≥n previa. Los scripts se ejecutan directamente mediante el int√©rprete del lenguaje, que devuelve resultados de forma inmediata.\nR es un lenguaje multiplataforma\nR puede instalarse y utilizarse en sistemas operativos Linux, Windows y MacOS. En todos ellos funciona de la misma manera, lo que garantiza que los scripts pueden correr en cualquier plataforma sin necesidad de modificaciones.\nR es software libre y de c√≥digo abierto\nR se distribuye gratuitamente bajo licencia GNU - GPL (General Public License), lo que otorga a los usuarios la libertad de usar, estudiar, compartir y modificar el software. Esto ha favorecido el crecimiento de una comunidad global activa y colaborativa.",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#breve-historia-del-lenguaje",
    "href": "unidad_1/intro_R.html#breve-historia-del-lenguaje",
    "title": "Introducci√≥n a R",
    "section": "Breve historia del lenguaje",
    "text": "Breve historia del lenguaje\nR tiene su origen en el lenguaje S, desarrollado en los a√±os 70 en los laboratorios Bell de AT&T (actualmente Lucent Technologies). Posteriormente, S dio lugar a una versi√≥n comercial llamada S-Plus, distribuida por Insightful Corporation.\nEn 1995, los profesores de estad√≠stica Ross Ihaka y Robert Gentleman, de la Universidad de Auckland (Nueva Zelanda) iniciaron el ‚ÄúProyecto R‚Äù, con la intenci√≥n de desarrollar un programa estad√≠stico inspirado en el lenguaje S pero de dominio p√∫blico.\nAunque R es considerado un dialecto de S, existen diferencias importantes en el dise√±o de ambos lenguajes.\nEl software est√° desarrollado principalmente en lenguaje C++, con algunas rutinas en Fortran. El nombre ‚ÄúR‚Äù hace referencia a las iniciales de sus creadores: Ross y Robert. Actualmente, R es mantenido por un grupo internacional de desarrolladores voluntarios conocido como el Core Development Team.",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#scripts-de-r",
    "href": "unidad_1/intro_R.html#scripts-de-r",
    "title": "Introducci√≥n a R",
    "section": "Scripts de R",
    "text": "Scripts de R\nUn script es un archivo de texto plano que contiene una secuencia de instrucciones para ser ejecutadas por el int√©rprete de R.\nEl t√©rmino script puede traducirse como gui√≥n, archivo de √≥rdenes, archivo de procesamiento por lotes o archivo de sintaxis.\nPuede crearse con cualquier editor de texto o con entornos especializados, y permite ser le√≠do, modificado, guardado y ejecutado de forma completa o l√≠nea por l√≠nea.\nUna de sus principales ventajas es su reutilizaci√≥n: los scripts pueden adaptarse f√°cilmente a distintos an√°lisis o contextos, lo que facilita la replicabilidad del trabajo.",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#caracter√≠sticas-generales-del-lenguaje",
    "href": "unidad_1/intro_R.html#caracter√≠sticas-generales-del-lenguaje",
    "title": "Introducci√≥n a R",
    "section": "Caracter√≠sticas generales del lenguaje",
    "text": "Caracter√≠sticas generales del lenguaje\nR posee una sintaxis textual precisa. Como en otros lenguajes de programaci√≥n, la escritura debe ser exacta: distingue entre may√∫sculas y min√∫sculas (case sensitive), y cada l√≠nea escrita en la consola comienza con el s√≠mbolo &gt; (prompt1).",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#documentaci√≥n-del-c√≥digo",
    "href": "unidad_1/intro_R.html#documentaci√≥n-del-c√≥digo",
    "title": "Introducci√≥n a R",
    "section": "Documentaci√≥n del c√≥digo",
    "text": "Documentaci√≥n del c√≥digo\nLa documentaci√≥n es una tarea fundamental en cualquier lenguaje de programaci√≥n, ya que nos permite entender el prop√≥sito del script, facilita su mantenimiento y posibilita su reutilizaci√≥n tanto por quien lo cre√≥ como por otras personas.\nEn R, la documentaci√≥n de los scripts se realiza a trav√©s de comentarios, indicados con el s√≠mbolo #. Todo lo que sigue a ese s√≠mbolo es ignorado por el int√©rprete cuando se ejecute el c√≥digo:\n\n# esto es una l√≠nea de comentario y el int√©rprete no la ejecuta\n\nAs√≠ que a la hora de documentar es preferible abusar de estos comentarios que no utilizarlos.",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#funciones",
    "href": "unidad_1/intro_R.html#funciones",
    "title": "Introducci√≥n a R",
    "section": "Funciones",
    "text": "Funciones\nLas √≥rdenes elementales en R se denominan comandos o funciones. Algunas se conocen como ‚Äúintegradas‚Äù ya que est√°n incluidas en el n√∫cleo del lenguaje (R base) y otras provienen de paquetes adicionales.\nLa mayor√≠a de las ofrecidas en los paquetes o librer√≠as est√°n elaboradas con R, dado que todos los usuarios podemos crear nuevas funciones con el mismo lenguaje.\nToda funci√≥n tiene un nombre y puede recibir argumentos (obligatorios u opcionales), que se colocan entre par√©ntesis y separados por comas. Incluso algunas funciones que no tienen asociado argumentos necesitan, en su sintaxis, a los par√©ntesis ().\nSiempre una funci√≥n devuelve un resultado, un valor o realiza una acci√≥n:\n\nnombre_de_la_funci√≥n(arg_1, arg_2, arg_n)\n\nComo el interprete de R no permite errores en la sintaxis de las expresiones, debemos atender a los siguientes puntos a la hora de escribirlas:\nLa sintaxis habitual de una funci√≥n es la siguiente:\n\nfuncion(arg1, arg2, arg3,...)\n\nLos t√≠tulos de los argumentos pueden escribirse y mediante un igual agregar el valor correspondiente:\n\nfuncion(arg1 = 32, arg2 = 5, arg3 = 65,...)\n\nSe puede omitir el t√≠tulo del argumento y escribir directamente el valor, pero en este caso, hay que respetar el orden definido por la funci√≥n:\n\nfuncion(32, 5, 65,...)\n\nLos valores num√©ricos, l√≥gicos, especiales y objetos van escritos en forma directa y cuando escribimos caracteres (texto) van necesariamente encerrados entre comillas:\n\nfuncion(arg1 = 3, arg2 = NA, arg3 = TRUE, arg4 = \"less\", arg5 = x, ...)",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#paquetes-o-librer√≠as",
    "href": "unidad_1/intro_R.html#paquetes-o-librer√≠as",
    "title": "Introducci√≥n a R",
    "section": "Paquetes o librer√≠as",
    "text": "Paquetes o librer√≠as\nLos paquetes, tambi√©n conocidos como librer√≠as, son conjuntos de funciones, datos y documentaci√≥n organizados organizadas en torno a una tem√°tica espec√≠fica, que permiten ampliar las capacidades del sistema base de R.\nAl instalar R, se incorpora un n√∫cleo b√°sico que queda activo autom√°ticamente en cada sesi√≥n (base, datasets, graphics, grDevices, methods, stats y utils). Junto a este n√∫cleo, se incluye un conjunto de paquetes recomendados que forman parte de la distribuci√≥n oficial y pueden activarse manualmente cuando se los necesita. No obstante, la verdadera potencia de R reside en la posibilidad de incorporar nuevos paquetes desarrollados por la comunidad, lo que permite extender continuamente sus funcionalidades.\n\n\n\n\nEn la actualidad, existen m√°s de 17.000 paquetes disponibles para una amplia variedad de aplicaciones, n√∫mero que crece mes a mes gracias a la naturaleza open source del lenguaje. Cualquier persona puede desarrollar y compartir sus propios paquetes, aunque no todos llegan a publicarse en el repositorio oficial CRAN (Comprehensive R Archive Network), que act√∫a como principal fuente de distribuci√≥n.\nLos paquetes pueden descargarse directamente desde CRAN o instalarse a partir de archivos comprimidos locales (como .zip o .tar.gz). Una vez instalados, se los puede activar en cualquier an√°lisis.\nDependencias\nEn muchos casos, al utilizar un paquete, este necesita de otros para funcionar correctamente. Esta relaci√≥n se conoce como dependencia, y es una caracter√≠stica central en el ecosistema de R.\nLa mayor√≠a de las funciones incluidas en los paquetes est√°n desarrolladas en el propio lenguaje R y, durante su construcci√≥n, es habitual que recurran a funciones ya existentes en otros paquetes. Por ejemplo, una funci√≥n nueva puede hacer uso de una funci√≥n auxiliar que no pertenece al sistema base, sino a otro paquete externo.\nCuando intentamos ejecutar una funci√≥n que depende de otras no disponibles en nuestra instalaci√≥n, R no podr√° encontrar esas funciones y nos devolver√° un mensaje de error indicando que no reconoce el nombre solicitado. Este tipo de errores suele alertar sobre funciones ‚Äúdesconocidas‚Äù o ‚Äúno encontradas‚Äù, lo que indica que falta instalar o activar alguno de los paquetes requeridos.\nPara evitar estos inconvenientes, R intenta resolver autom√°ticamente las dependencias cuando instalamos un paquete desde el repositorio oficial CRAN. Si el paquete necesita otros para funcionar, el sistema detecta esta relaci√≥n y se encarga de instalar tambi√©n aquellos paquetes auxiliares. De todos modos, si alguno no se instala correctamente o no se activa en la sesi√≥n, ser√° necesario hacerlo de forma manual.",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#errores-y-advertencias",
    "href": "unidad_1/intro_R.html#errores-y-advertencias",
    "title": "Introducci√≥n a R",
    "section": "Errores y advertencias",
    "text": "Errores y advertencias\nEl lenguaje R es muy preciso en su sintaxis. Cometer errores al escribir funciones u objetos es com√∫n durante el aprendizaje, y el int√©rprete de R devuelve mensajes de error cuando detecta algo incorrecto.\nUno de los aspectos clave a tener en cuenta es que R distingue entre may√∫sculas y min√∫sculas (case sensitive), por lo que no es lo mismo escribir a que A.\nExisten tres grupos de mensajes de error:\n\nErrores de sintaxis\nError de objeto no encontrado\nOtros errores\n\nErrores de sintaxis\nOcurre cuando R no puede interpretar una l√≠nea de c√≥digo porque algo est√° mal escrito. Los errores de sintaxis m√°s frecuentes incluyen:\n\nPar√©ntesis, comas, comillas, corchetes o llaves mal colocados o ausentes.\nArgumentos mal separados o incorrectamente definidos.\n\nPor ejemplo la funci√≥n rep() repite valores una cantidad de veces. Tiene dos argumentos, x donde se coloca el valor a repetir y times donde se define la cantidad de veces:\n\nrep(x = 3, times = 4) # repetimos 4 veces 3 con rep()\n\n[1] 3 3 3 3\n\n\nSi nos olvidamos de cerrar el par√©ntesis:\n\nrep(x = 3, times = 4\n\nError in parse(text = input): &lt;text&gt;:2:0: unexpected end of input\n1: rep(x = 3, times = 4\n   ^\n\n\nSi omitimos la coma entre argumentos:\n\nrep(x = 3 times = 4)\n\nError in parse(text = input): &lt;text&gt;:1:11: unexpected symbol\n1: rep(x = 3 times\n              ^\n\n\nSi usamos un nombre de argumento no v√°lido:\n\nrep(y = 3, times = 4)\n\nError in rep(y = 3, times = 4): attempt to replicate an object of type 'symbol'\n\n\nSi escribimos mal el nombre de la funci√≥n:\n\nrop(x = 3, times = 4)\n\nError in rop(x = 3, times = 4): could not find function \"rop\"\n\n\nEste √∫ltimo error se asemeja a un error de objeto no encontrado, aunque tiene origen en un problema de sintaxis.\nLos mensajes de error en general y sobre todo al principio pueden parecer extra√±os y dif√≠ciles de entender, pero con un poco de pr√°ctica podemos inferir donde est√° el problema.\nError de objeto no encontrado\nEste tipo de error se produce cuando R no reconoce un objeto utilizado en el c√≥digo. Las causas m√°s frecuentes incluyen:\n\nEl nombre del objeto est√° mal escrito (por ejemplo, errores de sintaxis o uso incorrecto de may√∫sculas/min√∫sculas).\nEl objeto pertenece a un paquete o archivo que no fue cargado.\nFaltan comillas al declarar caracteres.\nOtras causas similares.\n\nVolvamos al ejemplo anterior, ahora repitiendo un valor tipo character:\n\nrep(x = \"A\", times = 4) # repetimos 4 veces \"A\" con rep()\n\n[1] \"A\" \"A\" \"A\" \"A\"\n\n\nSi olvidamos las comillas:\n\nrep(x = A, times = 4) # repetimos 4 veces A con rep()\n\nError: object 'A' not found\n\n\nOtros errores\nSon aquellos que se generan por causas distintas a errores de sintaxis o de objeto no encontrado. Por ejemplo:\n\n\"x\" + 10\n\nError in \"x\" + 10: non-numeric argument to binary operator\n\n\nEl c√≥digo anterior genera un mensaje de error porque intenta sumar objetos de tipos incompatibles entre s√≠.\nVeamos otro ejemplo:\n\nt.test(1)\n\nError in t.test.default(1): not enough 'x' observations\n\n\nEn este caso, el error se debe a que no hay suficientes observaciones para realizar una prueba \\(t\\) de Student.\nOtro caso frecuente ocurre cuando se intenta acceder a una posici√≥n inexistente en un vector:\n\nx &lt;- c(1, 2, 3)\nx[[5]]\n\nError in x[[5]]: subscript out of bounds\n\n\nEste mensaje de error indica que el sub√≠ndice est√° fuera de los l√≠mites del objeto (subscript out of bounds).\nAdvertencias\nLas advertencia no son tan serias como un error, o al menos no lo parece, ya que permiten el c√≥digo se ejecute igual. Pero puede ocurrir que ignorar una advertencia llegue a ser algo muy serio, si esto implica que la salida de la funci√≥n es equivocada.\nIgnorar advertencias puede llevar a conclusiones err√≥neas, por lo que es recomendable prestarles atenci√≥n y entender su causa.\nPor ejemplo:\n\nlog(-1)\n\nWarning in log(-1): NaNs produced\n\n\n[1] NaN\n\n\nla funci√≥n genera una advertencia porque el logaritmo de un n√∫mero negativo no est√° definido en los reales, y R devuelve un valor NaN (Not a Number).\nResumiendo‚Ä¶",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#creaci√≥n-de-objetos",
    "href": "unidad_1/intro_R.html#creaci√≥n-de-objetos",
    "title": "Introducci√≥n a R",
    "section": "Creaci√≥n de objetos",
    "text": "Creaci√≥n de objetos\nTodas las declaraciones donde se crean objetos usan el s√≠mbolo de asignaci√≥n &lt;-:\n\nnombre_objeto &lt;- valor\n\nVe√°moslo en un ejemplo:\n\na &lt;- 1\n\nEn este caso asignamos el valor 1 al objeto a. El objeto a es un vector de una posici√≥n (un solo valor). Si llamamos al objeto, el int√©rprete devuelve el valor asignado previamente:\n\na\n\n[1] 1\n\n\nObservemos que, adem√°s de devolvernos el valor, aparece delante un n√∫mero entre corchetes [1]. Este n√∫mero es la ubicaci√≥n o √≠ndice del comienzo del objeto. En este caso, como el vector tiene una sola posici√≥n, indica que el primer valor mostrado empieza en la posici√≥n 1.",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#estructuras-de-datos",
    "href": "unidad_1/intro_R.html#estructuras-de-datos",
    "title": "Introducci√≥n a R",
    "section": "Estructuras de datos",
    "text": "Estructuras de datos\nLos objetos contenedores de datos m√°s simples pertenecen a cinco clases at√≥micas, que son:\n\ninteger (n√∫meros enteros)\nnumeric (n√∫meros reales)\ncomplex (n√∫meros complejos)\ncharacter (cadenas de caracteres)\nlogical (valores l√≥gicos: TRUE o FALSE)\n\n\n\n\n\nSin embargo, cada una de estas clases de datos no se encuentran de manera aislada, sino encapsuladas dentro de la clase de objeto m√°s b√°sica de R, a la que se denomina vector.\nEn RStudio, el sistema de colores ayuda a distinguir los tipos de valores:\n\n# N√∫mero\n1111\n\n[1] 1111\n\n# Caracter\n\"esto es una cadena de texto\"\n\n[1] \"esto es una cadena de texto\"\n\n# L√≥gico\nTRUE\n\n[1] TRUE\n\n# Objeto\na &lt;- 1\n\nVectores\nUn vector es un conjunto de valores (n√∫meros o s√≠mbolos), del mismo tipo ordenados de la forma (elemento 1, elemento 2, ‚Ä¶ , elemento \\(n\\)), donde \\(n\\) es la longitud o tama√±o del vector.\nLos atributos principales son:\n\nTipo: puede ser integer, numeric, character, complex o logical.\nLongitud: cantidad de elementos que contiene el objeto,\n\nEl vector m√°s simple contiene un solo dato, por ejemplo un vector de longitud 1 y tipo numeric:\n\nvec1 &lt;- 1\nvec1\n\n[1] 1\n\n\nOtro vector m√°s grande por ejemplo podr√≠a ser (1, 5, 2). En este caso tambi√©n es del tipo numeric pero tiene una longitud de 3 elementos:\n\nvec2 &lt;- c(1, 5, 2)\nvec2\n\n[1] 1 5 2\n\n\nPara concatenar elementos usamos la funci√≥n c(), dentro de la cual van los valores separados por comas. El orden de los elementos importa, en nuestro ejemplo la primera posici√≥n la ocupa el 1, la segunda el 5 y la tercera el 2. Si tuvieramos otro vector (5, 1, 2), no ser√≠a lo mismo porque los valores est√°n ordenados de forma diferente.\nPara conocer la longitud del vector usamos:\n\nlength(vec2)\n\n[1] 3\n\n\nNos informa que vec2 tiene 3 elementos.\nPara conocer el tipo de dato ejecutamos:\n\nclass(vec2)\n\n[1] \"numeric\"\n\n\nPodemos ver que los datos almacenados en este segundo ejemplo cumplen con la definici√≥n en lo que respecta al tipo de dato, ya que cada elemento es del mismo tipo (numeric).\nVeamos un ejemplo de asignaci√≥n de otro tipo de dato at√≥mico, como es el character:\n\nvec3 &lt;- \"Hola\"\nvec3\n\n[1] \"Hola\"\n\n\nSiempre que escribamos contenido de tipo character debemos hacerlo entre comillas. En este caso generamos el vector vec3 con el contenido \"Hola\", que, a pesar de ser una palabra compuesta de varios caracteres, dentro del vector vec3 esta ocupa una sola posici√≥n:\n\nlength(vec3)\n\n[1] 1\n\n\nRespecto al tipo de dato si usamos la funci√≥n class() tendremos:\n\nclass(vec3)\n\n[1] \"character\"\n\n\nFactores\nUn factor es un objeto especialmente dise√±ado para contener datos categ√≥ricos y se asocia particularmente con las variables cualitativas.\nEn su estructura interna est√° compuesto por dos vectores:\n\nUn vector de √≠ndices enteros.\nUn vector de categor√≠as (niveles) de tipo character, a los que hace referencia el primer vector.\n\nExisten de dos tipos: factores nominales y factores ordinales. En el caso del segundo se establece un orden en los niveles.\nNormalmente, obtenemos un tipo factor de convertir un vector u otro tipo de objeto con caracteres, pero para mostrar un ejemplo lo realizamos con la funci√≥n factor():\n\nfactor1 &lt;- factor(x = c(\"a\", \"b\", \"a\", \"c\", \"b\", \"a\"), \n                  levels = c(\"a\", \"b\", \"c\"))\nfactor1\n\n[1] a b a c b a\nLevels: a b c\n\n\nCreamos el objeto factor1 con 6 elementos caracteres y tres niveles sin orden.\nAdem√°s de la practicidad de trabajar con factores, muchas funciones de R requieren que las variables categ√≥ricas est√©n en formato factor para funcionar correctamente.\nDataframe\nUn dataframe es un objeto dise√±ado para contener conjuntos de datos y representa una estructura bidimensional similar a una tabla, con filas y columnas. Cada columna puede almacenar elementos de distintos tipos (por ejemplo, num√©ricos, de texto o l√≥gicos), siempre que todos tengan la misma longitud.\nLas columnas suelen tener nombres √∫nicos, lo que permite referenciarlas f√°cilmente como si fueran variables individuales dentro del conjunto de datos.\nEste es el tipo de objeto que se utiliza habitualmente para almacenar informaci√≥n importada desde archivos externos (por ejemplo, archivos de texto separados por comas o planillas de Excel), y con el que m√°s frecuentemente trabajamos en los an√°lisis.\nDesde el punto de vista estructural, un dataframe est√° compuesto por una serie de vectores de igual longitud dispuestos verticalmente, uno al lado del otro, conformando las columnas de la tabla.\nVeamos un ejemplo:\n\n# Historia cl√≠nica\nHC &lt;- c(\"F324\", \"G21\", \"G34\", \"F231\")\n\n# Edad\nedad &lt;- c(34, 32, 34, 54)\n\n# Sexo\nsexo &lt;- c(\"M\", \"V\", \"V\", \"M\")\n\n# dataframe\ndf1 &lt;- data.frame(HC, edad, sexo)\n\ndf1\n\n    HC edad sexo\n1 F324   34    M\n2  G21   32    V\n3  G34   34    V\n4 F231   54    M\n\n\nCreamos tres vectores con datos de supuestos individuos, su historia clinica, la edad y el sexo. Luego mediante la funci√≥n data.frame() ‚Äúunimos‚Äù esos vectores en forma vertical para formar un dataframe de 3 variables y 4 observaciones.\n\n\n\n\n\n\nExisten otras estructuras de datos que aparecen en la siguiente figura. Las m√°s habituales en nuestro trabajo son los vectores y los dataframes. Los factores ser√°n necesarios cuando tengamos que especificar distintos √≥rdenes de niveles.",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#operadores",
    "href": "unidad_1/intro_R.html#operadores",
    "title": "Introducci√≥n a R",
    "section": "Operadores",
    "text": "Operadores\nAdem√°s de funciones, el lenguaje R cuenta con operadores de uso relativamente intuitivo, que permiten realizar operaciones de diferentes tipos con los objetos que contienen datos.\nOperadores aritm√©ticos\n\n\n\n\nOperador\nDescripci√≥n\n\n\n\n+\nSuma\n\n\n-\nResta\n\n\n*\nMultiplicaci√≥n\n\n\n/\nDivisi√≥n\n\n\n^\nPotencia\n\n\n%%\nM√≥dulo\n\n\n%/%\nDivisi√≥n de enteros\n\n\n\n\n\nLos operadores aritm√©ticos se utilizan como si el lenguaje fuese una calculadora:\n\n# Suma\n2 + 5\n\n[1] 7\n\n# Resta\n3 - 2\n\n[1] 1\n\n# Multiplicaci√≥n\n9 * 3\n\n[1] 27\n\n# Divisi√≥n\n10 / 2\n\n[1] 5\n\n# Potencia\n5 ^ 2\n\n[1] 25\n\n\nTambi√©n se pueden hacer operaciones con los objetos que almacenan valores num√©ricos:\n\na &lt;- 3\n\nb &lt;- 6\n\n(a + b) * b\n\n[1] 54\n\n\nY funciona con objetos con m√°s de un elemento, aplicando aritm√©tica vectorial, donde las operaciones se realizan elemento a elemento:\n\na &lt;- c(1, 2, 3)\n\na * 3\n\n[1] 3 6 9\n\n\nO bien, con operaciones entre los objetos, donde se realiza entre los elementos de la misma posici√≥n:\n\na &lt;- c(1, 2, 3)\n\na * a\n\n[1] 1 4 9\n\n\nOperadores relacionales\n\n\n\n\nOperador\nDescripci√≥n\n\n\n\n&lt;\nMenor que\n\n\n&gt;\nMayor que\n\n\n&lt;=\nMenor o igual que\n\n\n&gt;=\nMayor o igual que\n\n\n==\nIgual que\n\n\n!=\nNo igual que\n\n\n\n\n\nHabitualmente estos operadores se utilizan asiduamente en expresiones para indicar relaciones entre valores.\nPodemos ver su funcionamiento en el ejemplo siguiente:\n\na &lt;- c(3, 8, 2)\n\na == c(3, 4, 5)\n\n[1]  TRUE FALSE FALSE\n\n\nEl lenguaje eval√∫a las comparaciones que hace el operador relacional igual (en este caso) y en aquellos valores que coinciden devuelve TRUE y en los que no hay coincidencia devuelve FALSE.\nLo mismo sucede con los otros operadores relacionales:\n\na &lt;- c(4, 8, 10)\n\na &gt; 8\n\n[1] FALSE FALSE  TRUE\n\na &lt; 8\n\n[1]  TRUE FALSE FALSE\n\na != 8\n\n[1]  TRUE FALSE  TRUE\n\n\nOperadores l√≥gicos\n\n\n\n\nOperador\nDescripci√≥n\n\n\n\n!\nNOT\n\n\n&\nAND booleano\n\n\n&&\nAND booleano para vectores de longitud 1\n\n\n|\nOR booleano\n\n\n||\nOR booleano para vectores de longitud 1\n\n\n\n\n\nCuando queremos conectar algunas de las expresiones relacionales hacemos uso de estos operadores l√≥gicos t√≠picos (AND, OR, NOT).\nPara ejemplificar podemos hacer:\n\na &lt;- c(1:8)\n\na\n\n[1] 1 2 3 4 5 6 7 8\n\n(a &gt; 3) & (a &lt; 7)\n\n[1] FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE\n\n\nEn el caso anterior usamos el operador & como conector AND de dos expresiones relacionales donde el lenguaje devuelve TRUE en el rango mayor a 3 y menor a 7 (valores 4,5 y 6).",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#valores-especiales",
    "href": "unidad_1/intro_R.html#valores-especiales",
    "title": "Introducci√≥n a R",
    "section": "Valores especiales",
    "text": "Valores especiales\nExisten algunos valores especiales para datos con expresiones reservadas en R, entre ellos encontramos los valores NA, NaN, Inf y NULL.\n\n\n\n\nOperador\nSignificado\nDescripci√≥n\n\n\n\nNA\nNot available\nEs la forma de expresar a los valores perdidos o faltantes (missing values)\n\n\nNaN\nNot a number\nUtilizado para resultados de operaciones que devuelven error num√©rico\n\n\nInf\nInfinity\nValor infinito (positivo)\n\n\n-Inf\nInfinity\nValor infinito (negativo)\n\n\nNULL\nNull\nValor nulo\n\n\n\n\n\nEl m√°s relevante de estos valores especiales es el NA que sirve para indicar que no hay valor en esa posici√≥n o elemento de un objeto.",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#secuencias-regulares",
    "href": "unidad_1/intro_R.html#secuencias-regulares",
    "title": "Introducci√≥n a R",
    "section": "Secuencias regulares",
    "text": "Secuencias regulares\nAdem√°s de concatenar elementos con la funci√≥n c(), existen tres formas comunes de generar secuencias regulares.\nLa primera es mediante un operador secuencial (:), que genera una secuencia de enteros entre dos valores, ya sea en forma ascendente o descendente:\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n10:1\n\n [1] 10  9  8  7  6  5  4  3  2  1\n\n\nLa segunda forma es mediante la funci√≥n seq(), cuyos argumentos principales son from, to y by. Esta funci√≥n permite mayor flexibilidad:\n\nseq(from = 1, to = 20, by = 2)\n\n [1]  1  3  5  7  9 11 13 15 17 19\n\n\nEl ejemplo anterior genera una secuencia de n√∫meros que comienza en 1 y llega hasta 20, avanzando de dos en dos.\nAlgunos otros ejemplos de la misma funci√≥n:\n\nseq(from = 0.1, to = 0.9, by = 0.1)\n\n[1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9\n\nseq(from = -5, to = 5, by = 1)\n\n [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n\nseq(from = 300, to = 0, by = -50)\n\n[1] 300 250 200 150 100  50   0\n\n\nLa tercera opci√≥n es la funci√≥n rep(), que permite duplicar valores. Su forma m√°s b√°sica es rep(x, times = n), donde se repite el valor x la cantidad de veces indicada por n.\nAlgunos ejemplos:\n\nrep(x = 2, times = 5)\n\n[1] 2 2 2 2 2\n\n# combinada con el operador :\nrep(1:4, 5)  \n\n [1] 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4\n\n# combinada con la funci√≥n c()\nrep(c(4.5, 6.8, 7.2), 2) \n\n[1] 4.5 6.8 7.2 4.5 6.8 7.2",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#√≠ndices",
    "href": "unidad_1/intro_R.html#√≠ndices",
    "title": "Introducci√≥n a R",
    "section": "√çndices",
    "text": "√çndices\nR implementa una forma eficiente y flexible de acceder selectivamente a elementos de un objeto basado en una indexaci√≥n interna.\nPara acceder a un √≠ndice se utiliza la notaci√≥n de corchetes. Por ejemplo, si tenemos un vector x con varios elementos y queremos acceder al segundo, usamos x[2].\nEsta forma de indexar los elementos de los distintos objetos nos permite realizar muchas operaciones desde el simple llamado, hasta seleccionar, eliminar o modificar valores.\nVeamos algunos ejemplos:\n\n# generamos un vector x con 5 letras\nx &lt;- c(\"a\",\"b\",\"c\",\"d\",\"e\")\n\n# llamamos a la primer posici√≥n y nos devuelve su valor \nx[1]\n\n[1] \"a\"\n\n# llamamos a la tercer posici√≥n y nos devuelve su valor\nx[3]    \n\n[1] \"c\"\n\n# llamamos a las posiciones 1 y 3 juntas mediante c()\nx[c(1,3)]   \n\n[1] \"a\" \"c\"\n\n# llamamos a las posiciones menos la 1 y la 4\nx[-c(1, 4)] \n\n[1] \"b\" \"c\" \"e\"\n\n# creamos otro vector y con los valores 1,2 y 5\ny &lt;- c(1, 2, 5) \n\n# utilizamos el vector y como √≠ndice    \nx[y]        \n\n[1] \"a\" \"b\" \"e\"\n\n# asignamos el valor ‚Äúh‚Äù a la posici√≥n 2 del vector x\nx[2] &lt;- \"h\" \n\nx\n\n[1] \"a\" \"h\" \"c\" \"d\" \"e\"\n\n# creamos el vector z eliminando la posici√≥n 5 de x\nz &lt;- x[-5]  \n\nz\n\n[1] \"a\" \"h\" \"c\" \"d\"\n\n\nEstos ejemplos muestran las m√∫ltiples posibilidades que ofrece el uso de √≠ndices para manipular objetos en R, lo que hace al lenguaje muy poderoso y vers√°til.\nCuando se aplican √≠ndices a estructuras bidimensionales, como matrices o dataframes, la notaci√≥n general es:\n\nnombre[√≠ndice de fila, √≠ndice de columna]",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#gesti√≥n-de-factores",
    "href": "unidad_1/intro_R.html#gesti√≥n-de-factores",
    "title": "Introducci√≥n a R",
    "section": "Gesti√≥n de factores",
    "text": "Gesti√≥n de factores\nAl presentar las distintas estructuras de datos mencionamos que los factores suelen generarse a partir de vectores u otros objetos de tipo car√°cter.\nPara entender c√≥mo funcionan, partamos de un vector con datos categ√≥ricos:\n\nrespuesta &lt;- c(\"Si\", \"No\", \"No\", \"Si\", \"Si\", \"Si\", \"No\")\n\nCreamos un vector llamado respuesta con 7 elementos de tipo car√°cter, en el que se repiten las categor√≠as \"Si\" y \"No\".\nPodemos confirmar que se trata de un vector y que su contenido es de tipo car√°cter:\n\n# preguntamos si sexo es un vector\nis.vector(respuesta) \n\n[1] TRUE\n\n# visualizamos el tipo de dato de sexo\nclass(respuesta)  \n\n[1] \"character\"\n\n\nPara crear un factor a partir de este vector debemos utilizar la funci√≥n factor():\n\nrespuesta &lt;- factor(respuesta)\n\nrespuesta\n\n[1] Si No No Si Si Si No\nLevels: No Si\n\n\nEn la salida observamos los siete elementos y, debajo, una l√≠nea con los niveles del factor, indicados por Levels. Estos niveles son identificados autom√°ticamente.\nPodemos verificar c√≥mo cambi√≥ el tipo de objeto:\n\n# preguntamos si respuesta es un vector\nis.vector(respuesta) \n\n[1] FALSE\n\n# preguntamos si respuesta es un factor\nis.factor(respuesta) \n\n[1] TRUE\n\n# visualizamos el tipo de dato de respuesta\nclass(respuesta) \n\n[1] \"factor\"\n\n\nAunque visualmente vemos palabras, internamente R trata al factor como un tipo especial basado en n√∫meros. ¬øPor qu√© sucede esto? Ve√°moslo con m√°s detalle:\n\nstr(respuesta)\n\n Factor w/ 2 levels \"No\",\"Si\": 2 1 1 2 2 2 1\n\n\nLa funci√≥n str() devuelve la estructura interna del objeto. En este caso, muestra que respuesta tiene dos niveles y que cada elemento del vector es representado por un n√∫mero (1 o 2), donde 1 corresponde a \"No\" y 2 a \"Si\".\nEsto significa que la estructura de los factores est√° compuesta por dos vectores: uno num√©rico que funciona como √≠ndice de enteros, que sustituye al vector de caracteres original, y el otro es un vector de caracteres, que contiene los niveles o categor√≠as, a los que hace referencia el primer vector.\nPara ver solo los niveles o categor√≠as del factor podemos usar:\n\nlevels(respuesta)\n\n[1] \"No\" \"Si\"\n\n\nEn los factores nominales donde no importa el orden, la funci√≥n factor() implementa el orden alfab√©tico para determinar a qu√© √≠ndice num√©rico pertenece cada categor√≠a. Es claro en el ejemplo que a No le asigna el 1 y a Si el 2.\nPero si nos encontramos frente a una variable cualitativa ordinal vamos a necesitar indicarle a la funci√≥n cual es el orden de las categor√≠as.\nVamos al siguiente ejemplo:\n\nsalud &lt;- c(4, 3, 1, 3, 2, 2, 3, 3, 1)\nsalud\n\n[1] 4 3 1 3 2 2 3 3 1\n\n\nTenemos en el vector salud algunos c√≥digos num√©ricos que representan nivel de salud de personas registradas por una encuesta donde 1 significa mala salud, 2 regular, 3 buena y 4 muy buena.\nProcedemos a crear el factor nivsalud a partir de este vector:\n\nnivsalud &lt;- factor(salud,\n                   label = c(\"Mala\", \"Regular\", \"Buena\", \"Muy buena\"),\n                   levels = 1:4)\n\nnivsalud\n\n[1] Muy buena Buena     Mala      Buena     Regular   Regular   Buena    \n[8] Buena     Mala     \nLevels: Mala Regular Buena Muy buena\n\n\nAqu√≠ utilizamos dos argumentos adicionales:\n\nlabels: define las etiquetas que queremos mostrar para cada categor√≠a.\nlevels: indica el orden de los niveles originales (en este caso, 1 a 4).\n\nAqu√≠ es necesario definir estos argumentos porque, a diferencia del factor respuesta, el vector salud contiene n√∫meros en lugar de las palabras correspondientes a las categor√≠as.\nHasta aqu√≠ hemos creado un factor pero si miramos sus niveles no encontraremos se√±ales que sigan un orden espec√≠fico:\n\nlevels(nivsalud)\n\n[1] \"Mala\"      \"Regular\"   \"Buena\"     \"Muy buena\"\n\n\nSin embargo, a√∫n no hemos definido un orden expl√≠cito entre las categor√≠as. Para hacerlo, agregamos el argumento ordered = TRUE:\n\nnivsalud &lt;- factor(salud,\n                   label = c(\"Mala\", \"Regular\", \"Buena\", \"Muy buena\"),\n                   levels = 1:4, \n                   ordered = TRUE)\n\nnivsalud\n\n[1] Muy buena Buena     Mala      Buena     Regular   Regular   Buena    \n[8] Buena     Mala     \nLevels: Mala &lt; Regular &lt; Buena &lt; Muy buena\n\n\nAl incorporar este argumento, estamos diciendo que los niveles tienen orden natural. Esto puede observarse en la salida donde se muestra que \"Mala\" &lt; \"Regular\" &lt; \"Buena\" &lt; \"Muy buena\".",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#gesti√≥n-de-dataframes",
    "href": "unidad_1/intro_R.html#gesti√≥n-de-dataframes",
    "title": "Introducci√≥n a R",
    "section": "Gesti√≥n de dataframes",
    "text": "Gesti√≥n de dataframes\nEn R, la estructura utilizada para almacenar datos provenientes de fuentes externas (como archivos .csv, planillas de c√°lculo, bases SQL, etc.) es el dataframe.\nA modo de ejemplo, vamos a construir un dataframe llamado datos con 4 variables y 5 observaciones. Las variables ser√°n:\n\nid: identificador num√©rico entero y correlativo.\nedad: edad en a√±os.\nsexo: codificado como \"V\" para var√≥n y \"M\" para mujer.\ntrabaja: variable l√≥gica, donde TRUE (T) representa que la persona trabaja y FALSE (F) que no lo hace.\n\n\n# construimos el vector id\nid &lt;- 1:5\n\n# construimos el vector edad\nedad &lt;- c(23, 43, 12, 65, 37)\n\n# construimos el vector sexo\nsexo &lt;- c(\"V\", \"M\", \"M\", \"V\", \"M\")\n\n# construimos el vector trabaja\ntrabaja &lt;- c(T, T, F, F, T)\n\n# construimos el dataframe datos\ndatos &lt;- data.frame(id, edad, sexo, trabaja)\n\nAunque para el ejemplo construimos un dataframe manualmente, lo habitual en la pr√°ctica es leer archivos externos que se importan directamente como dataframes.\nAlgunas de las funciones generales que podemos aplicar son:\n\n# pedimos el n√∫mero de columnas (variables)\nncol(datos)\n\n[1] 4\n\n# pedimos el n√∫mero de filas (registros u observaciones)\nnrow(datos)\n\n[1] 5\n\n# pedimos las dimensiones del dataframe (observaciones,variables)\ndim(datos)\n\n[1] 5 4\n\n\nTambi√©n podemos visualizar como se compone el objeto datos aplicando str() que devuelve la estructura interna de cualquier objeto en R.\n\nstr(datos)\n\n'data.frame':   5 obs. of  4 variables:\n $ id     : int  1 2 3 4 5\n $ edad   : num  23 43 12 65 37\n $ sexo   : chr  \"V\" \"M\" \"M\" \"V\" ...\n $ trabaja: logi  TRUE TRUE FALSE FALSE TRUE\n\n\nEsta salida nos informa que:\n\ndatos es un dataframe con 5 observaciones y 4 variables.\nid es un entero (int).\nedad es num√©rica (num).\nsexo es de tipo car√°cter (chr).\ntrabaja es l√≥gica (logi).\n\nAdem√°s, str() muestra los primeros valores de cada variable, que en este caso son todos, ya que el dataframe tiene solo 5 registros.\nCuando necesitemos llamar al contenido de alguna columna o variable del dataframe, utilizamos la siguiente notaci√≥n:\n\nnombre_del_dataframe$nombre_de_la_variable\n\nPor ejemplo, si queremos mostrar el contenido de la variable sexo del objeto datos hacemos:\n\ndatos$sexo\n\n[1] \"V\" \"M\" \"M\" \"V\" \"M\"\n\n\nEsto devuelve todos los valores de la variable sexo.\nTambi√©n podemos acceder a los elementos del dataframe usando indexaci√≥n por filas y columnas:\n\n# pedimos la tercer variable (sexo)\ndatos[,3]\n\n[1] \"V\" \"M\" \"M\" \"V\" \"M\"\n\n\nObservemos que las dos salidas son id√©nticas, dado que muestran todas las observaciones de la variable sexo, aunque la solicitud sea de manera diferente.\nAlgunos otros ejemplos de uso de √≠ndices:\n\n# observaci√≥n 1 de la variable 2\ndatos[1,2]\n\n[1] 23\n\n# observaci√≥n 4 de todas las variables\ndatos[4,]  \n\n  id edad sexo trabaja\n4  4   65    V   FALSE\n\n# observaci√≥n 1,2 y 3 de la variable 3\ndatos[1:3,3] \n\n[1] \"V\" \"M\" \"M\"\n\n# observaci√≥n 5 de las variables 1 y 4\ndatos[5, c(1,4)] \n\n  id trabaja\n5  5    TRUE\n\n\nPor √∫ltimo, vamos podemos mostrar y gestionar los nombres de las variables con la funci√≥n names():\n\nnames(datos)\n\n[1] \"id\"      \"edad\"    \"sexo\"    \"trabaja\"",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#f√≥rmulas",
    "href": "unidad_1/intro_R.html#f√≥rmulas",
    "title": "Introducci√≥n a R",
    "section": "F√≥rmulas",
    "text": "F√≥rmulas\nEn R, las f√≥rmulas se utilizan principalmente para describir modelos estad√≠sticos, y las vamos a emplear a lo largo de toda la cursada.\nLas f√≥rmulas se escriben utilizando operadores como ~, +, *, entre otros. Se usan para especificar modelos como regresiones, ANOVA, pruebas de hip√≥tesis y, en algunos casos, tambi√©n para generar ciertos tipos de gr√°ficos.\nFormula gen√©rica\nAqu√≠ la formula est√° dada por el operador ~, a la izquierda est√° la variable de respuesta o dependiente, a la derecha la o las variables explicativas o independientes. El esquema general es el siguiente:\n\nvariable_dependiente ~ variable independiente\n\nEl s√≠mbolo ~ (llamado virgulilla) puede interpretarse como ‚Äúes modelada por‚Äù o ‚Äúen funci√≥n de‚Äù.\nPor ejemplo, en una regresi√≥n lineal se utiliza la funci√≥n base lm() y el argumento principal de esta funci√≥n es una formula:\n\nregresion_lineal &lt;- lm(variable_respuesta ~ variable_explicativa,\n                       data = datos)\n\nAdem√°s de la f√≥rmula, la funci√≥n lm() incluye el argumento data =, que es fundamental: all√≠ se le indica a R el dataframe en el que debe buscar las variables involucradas en el modelo.\nLa siguiente tabla muestra los usos de los los operadores m√°s comunes dentro de una formula:\n\n\n\n\nOperador\nEjemplo\nDescripci√≥n\n\n\n\n+\n+x\nIncluye la variable x\n\n\n-\n-x\nExcluye la variable x\n\n\n:\nx : z\nIncluye la interacci√≥n de la variable x con z\n\n\n*\nx * z\nIncluye ambas variables y la interacci√≥n entre ellas",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a R"
    ]
  },
  {
    "objectID": "unidad_1/intro_R.html#footnotes",
    "href": "unidad_1/intro_R.html#footnotes",
    "title": "Introducci√≥n a R",
    "section": "Notas",
    "text": "Notas\n\nS√≠mbolo que aparece en la pantalla de la computadora indicando que el sistema est√° esperando informaci√≥n del usuario o que el sistema est√° listo para recibir instrucciones del usuario.‚Ü©Ô∏é",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a R"
    ]
  },
  {
    "objectID": "unidad_1/analisis_exploratorio.html#introducci√≥n",
    "href": "unidad_1/analisis_exploratorio.html#introducci√≥n",
    "title": "An√°lisis exploratorio de datos",
    "section": "Introducci√≥n",
    "text": "Introducci√≥n\nEl an√°lisis exploratorio de datos (conocido como EDA, su sigla en ingl√©s) es un enfoque de an√°lisis fundamental para resumir y visualizar las caracter√≠sticas importantes de un conjunto de datos.\nJohn Tukey, estad√≠stico estadounidense, fue uno de los principales impulsores de este enfoque. En 1977 public√≥ el libro Exploratory Data Analysis, donde, entre otras contribuciones, introdujo el gr√°fico boxplot (diagrama de caja y bigotes).\nEn t√©rminos sencillos, antes de avanzar hacia el an√°lisis formal o la construcci√≥n de modelos estad√≠sticos, resulta esencial explorar, conocer y describir las variables presentes en nuestra tabla de datos.\nEntre los principales objetivos perseguidos por EDA se encuentran:\n\nConocer la estructura de la tabla de datos y sus tipos de variable.\nDetectar observaciones incompletas (valores missing o NA).\nExplorar la distribuci√≥n de las variables de inter√©s a partir de:\n\nEstad√≠sticos descriptivos\nRepresentaciones gr√°ficas\n\n\nDetectar valores at√≠picos (outliers).\n\nAclaraci√≥n\nEn este documento utilizaremos funciones del lenguaje R basadas en la filosof√≠a tidyverse, junto con otros paquetes dise√±ados para tareas espec√≠ficas. Esto no implica que no se puedan emplear funciones del R base; sin embargo, el ecosistema tidyverse facilita la comprensi√≥n y legibilidad del c√≥digo.\nPresentaremos estas diferentes funciones de distintos paquetes que pueden servir en cada etapa de un EDA. Los paquetes con los que trabajaremos son:\n\ntidyverse\nskimr\ndlookr\njanitor\n\n\n\n\n\n\n\nNota: Algunos paquetes, como dlookr, pueden generar falsos positivos en la detecci√≥n del antivirus durante el proceso de instalaci√≥n. Sugerimos desactivar moment√°neamente el antivirus para evitar inconvenientes.\n\n\n\nUna vez instalados, podemos activar los paquetes con el siguiente c√≥digo:\n\n# Carga de paquetes\nlibrary(skimr)\nlibrary(janitor)\nlibrary(dlookr)\nlibrary(tidyverse)\n\nSe recomienda cargar tidyverse al final de la lista para evitar conflictos con funciones que puedan solaparse entre paquetes.\n\nEs importante destacar que no existe un √∫nico camino y/o funci√≥n para realizar un an√°lisis exploratorio. Esta selecci√≥n de herramientas puede adaptarse seg√∫n las preferencias y necesidades de cada usuario. Por lo tanto, quienes ya tengan familiaridad con otras funciones o paquetes pueden continuar utiliz√°ndolos sin inconvenientes.\n\nPara ilustrar los pasos del an√°lisis exploratorio, utilizaremos un archivo con datos ficticios llamado ‚Äúdatos2.txt‚Äù, que contiene variables de distintos tipos.",
    "crumbs": [
      "Unidad 1",
      "An√°lisis exploratorio de datos"
    ]
  },
  {
    "objectID": "unidad_1/analisis_exploratorio.html#conocer-la-estructura-de-la-tabla-de-datos-y-sus-tipos-de-variable",
    "href": "unidad_1/analisis_exploratorio.html#conocer-la-estructura-de-la-tabla-de-datos-y-sus-tipos-de-variable",
    "title": "An√°lisis exploratorio de datos",
    "section": "Conocer la estructura de la tabla de datos y sus tipos de variable",
    "text": "Conocer la estructura de la tabla de datos y sus tipos de variable\nEl primer paso en la exploraci√≥n de un conjunto de datos es conocer su estructura y tama√±o:\n\nEl tama√±o se refiere a la cantidad de observaciones (filas) y de variables (columnas).\nLa estructura incluye c√≥mo est√°n organizadas las variables, qu√© tipo de datos contiene cada una y qu√© categor√≠as o valores pueden tomar.\n\nComenzaremos por cargar los datos de ejemplo con la funci√≥n read_csv2() de tidyverse:\n\ndatos &lt;- read_csv2(\"datos/datos2.txt\")\n\nUna vez cargados los datos, la funci√≥n glimpse() permite obtener una visi√≥n general de la tabla:\n\nglimpse(datos)\n\nRows: 74\nColumns: 7\n$ id      &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,‚Ä¶\n$ sexo    &lt;chr&gt; \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", NA, \"F\", \"F\", \"M\", \"F\"‚Ä¶\n$ edad    &lt;dbl&gt; 76, 68, 50, 49, 51, 68, 70, 64, 60, 57, 83, 76, 27, 34, 17, 45‚Ä¶\n$ peso    &lt;dbl&gt; 71, 71, 79, 71, 87, 75, 80, 83, 69, 73, 60, 70, 648, 718, 61, ‚Ä¶\n$ talla   &lt;dbl&gt; 167, 164, 164, 164, 1675, 170, 166, 160, 160, 155, 155, 167, 1‚Ä¶\n$ trabaja &lt;lgl&gt; FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, NA, TRUE, TRUE, TRUE, ‚Ä¶\n$ fecha   &lt;date&gt; 2020-10-20, 2020-10-20, 2020-10-20, 2020-11-05, 2020-11-05, 2‚Ä¶\n\n\nEsta funci√≥n nos informa que la tabla contiene, por ejemplo, 74 observaciones y 7 variables, mostrando el tipo de dato de cada una y los primeros valores que aparecen.\nEntre los tipos de datos m√°s comunes que podemos encontrar se incluyen:\n\nint (integer): n√∫meros enteros.\ndbl (double): n√∫meros reales.\nlgl (logical): valores l√≥gicos (TRUE, FALSE).\nchr (character): texto o cadenas de caracteres.\nDate: fechas.\nfct (factor): variables categ√≥ricas con niveles.\ndttm (date-time): fechas y horas.\n\nEsta primera revisi√≥n de la estructura suele complementarse con el diccionario de datos, un recurso fundamental que describe el significado, tipo, unidad y codificaci√≥n de cada variable. Este diccionario puede acompa√±ar tanto a bases de datos generadas en investigaciones propias (fuentes primarias) como a datos provenientes de fuentes secundarias.\nEs importante tener en cuenta que el tipo de dato en R no siempre coincide con la naturaleza estad√≠stica de la variable. Por ejemplo:\n\nUna variable codificada como dbl puede representar una medida cuantitativa continua, como la edad o el peso.\nPero tambi√©n puede representar una variable cualitativa codificada con n√∫meros. Por ejemplo, si una variable que registra respuestas ‚ÄúS√≠‚Äù y ‚ÄúNo‚Äù fue codificada como 1 y 0, su tipo de dato ser√° num√©rico (dbl o int), aunque conceptualmente sea una variable categ√≥rica.\n\nPor esta raz√≥n, adem√°s de inspeccionar el tipo de datos en R, es importante revisar el significado y el uso previsto de cada variable dentro del contexto del an√°lisis.",
    "crumbs": [
      "Unidad 1",
      "An√°lisis exploratorio de datos"
    ]
  },
  {
    "objectID": "unidad_1/analisis_exploratorio.html#detectar-observaciones-incompletas",
    "href": "unidad_1/analisis_exploratorio.html#detectar-observaciones-incompletas",
    "title": "An√°lisis exploratorio de datos",
    "section": "Detectar observaciones incompletas",
    "text": "Detectar observaciones incompletas\nLos valores perdidos o faltantes (conocidos como missing en ingl√©s), representados en R por el valor especial NA, constituyen un desaf√≠o importante en el an√°lisis de datos. Su presencia puede afectar la calidad del an√°lisis y condicionar las decisiones estad√≠sticas posteriores.\nExisten numerosos enfoques para el tratamiento de valores faltantes, incluyendo t√©cnicas de imputaci√≥n y modelado espec√≠fico. Sin embargo, en este curso nos enfocaremos exclusivamente en c√≥mo detectar, contabilizar y, en algunos casos, excluir valores faltantes utilizando funciones del lenguaje R.\nUna forma sencilla de detectar valores faltantes es mediante la funci√≥n count() del paquete dplyr. Al aplicarla a una variable, la salida incluye una fila adicional que informa cu√°ntos valores NA hay:\n\ndatos |&gt; \n  count(trabaja)\n\n# A tibble: 3 √ó 2\n  trabaja     n\n  &lt;lgl&gt;   &lt;int&gt;\n1 FALSE      26\n2 TRUE       39\n3 NA          9\n\n\nUna alternativa m√°s completa es la funci√≥n find_na() del paquete dlookr (Ryu 2024):\n\nfind_na(datos, rate = T)\n\n     id    sexo    edad    peso   talla trabaja   fecha \n  0.000   4.054   0.000   0.000   0.000  12.162   0.000 \n\n\nEsta funci√≥n se puede aplicar al conjunto de datos completo y devuelve, para cada variable, la cantidad y el porcentaje de valores NA. Por ejemplo, podr√≠amos observar que la variable sexo tiene alrededor de un 4‚ÄØ% de valores faltantes, y la variable trabaja, algo m√°s del 12‚ÄØ%.\nEstos porcentajes pueden ayudarnos a decidir si una variable debe incluirse en un an√°lisis o si es conveniente excluir ciertas observaciones con datos incompletos, siempre que los NA sean el resultado de una ausencia real de informaci√≥n.\nEl mismo paquete trae una funci√≥n gr√°fica llamada plot_na_pareto(), que genera un gr√°fico de barras ordenados por frecuencia de valores faltantes:\n\nplot_na_pareto(datos, only_na = T)\n\n\n\n\n\n\n\nFinalmente, para un diagn√≥stico m√°s integral de la calidad de las variables, puede utilizarse la funci√≥n diagnose():\n\ndiagnose(datos)\n\n# A tibble: 7 √ó 6\n  variables types     missing_count missing_percent unique_count unique_rate\n  &lt;chr&gt;     &lt;chr&gt;             &lt;int&gt;           &lt;dbl&gt;        &lt;int&gt;       &lt;dbl&gt;\n1 id        numeric               0            0              74      1     \n2 sexo      character             3            4.05            3      0.0405\n3 edad      numeric               0            0              45      0.608 \n4 peso      numeric               0            0              56      0.757 \n5 talla     numeric               0            0              38      0.514 \n6 trabaja   logical               9           12.2             3      0.0405\n7 fecha     Date                  0            0              11      0.149 \n\n\nEsta funci√≥n ofrece un resumen detallado que incluye el tipo de variable, la cantidad de valores faltantes, la proporci√≥n de valores √∫nicos, entre otros indicadores de utilidad para la exploraci√≥n inicial.",
    "crumbs": [
      "Unidad 1",
      "An√°lisis exploratorio de datos"
    ]
  },
  {
    "objectID": "unidad_1/analisis_exploratorio.html#conocer-la-distribuci√≥n-de-las-variables-de-inter√©s",
    "href": "unidad_1/analisis_exploratorio.html#conocer-la-distribuci√≥n-de-las-variables-de-inter√©s",
    "title": "An√°lisis exploratorio de datos",
    "section": "Conocer la distribuci√≥n de las variables de inter√©s",
    "text": "Conocer la distribuci√≥n de las variables de inter√©s\nResumir variables cuantitativas\nLa instalaci√≥n b√°sica de R tiene incorporadas m√∫ltiples funciones estad√≠sticas que permiten calcular medidas resumen para variables cuantitativas. Estas funciones pueden integrarse a la funci√≥n summarise() de tidyverse.\nMedidas de tendencia central\nLas medidas de tendencia central forman parte del grupo de medidas de posici√≥n o localizaci√≥n, pero su objetivo principal es resumir la informaci√≥n en torno a un valor que representa el ‚Äúcentro‚Äù de la distribuci√≥n. Es decir, un valor respecto al cual tienden a agruparse los dem√°s valores.\nPodemos obtener la media y la mediana de nuestros datos con el siguiente c√≥digo:\n\ndatos |&gt;\n  summarise(\n    # Media\n    media = mean(edad),\n    # Mediana\n    mediana = median(edad)\n  )\n\n# A tibble: 1 √ó 2\n  media mediana\n  &lt;dbl&gt;   &lt;dbl&gt;\n1  48.1    52.5\n\n\nEn cambio, R base no incluye una funci√≥n espec√≠fica para calcular la moda. Para obtenerla, debemos escribir una funci√≥n propia o utilizar alg√∫n paquete adicional que la implemente (por ejemplo, modeest::mlv()).\nMedidas de posici√≥n\nLas medidas de posici√≥n dividen los datos en grupos con igual n√∫mero de observaciones. Entre las m√°s utilizadas se encuentran los cuartiles y percentiles.\nLa funci√≥n quantile() del paquete base stats permite calcular cuartiles u otros percentiles. Por ejemplo, para calcular los cuartiles Q1 y Q3, indicamos en el argumento probs los valores 0.25 y 0.75:\n\ndatos |&gt;\n  summarise(\n    # Primer cuartil\n    cuartil1 = quantile(edad, probs = 0.25),\n    # Tercer cuartil\n    cuartil3 = quantile(edad, probs = 0.75)\n  )\n\n# A tibble: 1 √ó 2\n  cuartil1 cuartil3\n     &lt;dbl&gt;    &lt;dbl&gt;\n1       28       64\n\n\nPara obtener el m√≠nimo y m√°ximo de estos valores num√©ricos usamos el siguiente c√≥digo:\n\ndatos |&gt;\n  summarise(\n    # M√≠nimo\n    minimo = min(edad),\n    # M√°ximo\n    maximo = max(edad)\n  )\n\n# A tibble: 1 √ó 2\n  minimo maximo\n   &lt;dbl&gt;  &lt;dbl&gt;\n1     13     86\n\n\nMedidas de dispersi√≥n\nLas medidas de dispersi√≥n nos permiten conocer cu√°n dispersos o variables son los valores dentro del conjunto de datos.\nEntre las m√°s cl√°sicas se encuentran la varianza y el desv√≠o est√°ndar, que se calculan f√°cilmente con las funciones var() y sd():\n\ndatos |&gt;\n  summarise(\n    # Varianza\n    varianza = var(edad),\n    # Desv√≠o est√°ndar\n    desvio = sd(edad)\n  )\n\n# A tibble: 1 √ó 2\n  varianza desvio\n     &lt;dbl&gt;  &lt;dbl&gt;\n1     405.   20.1\n\n\nTambi√©n puede ser √∫til calcular el rango, que se obtiene como la diferencia entre el valor m√°ximo y el m√≠nimo, y el rango intercuart√≠lico (RIC), mediante IQR():\n\ndatos |&gt;\n  summarise(\n    # Rango\n    rango = max(edad) - min(edad),\n    # Rango intercuart√≠lico\n    ric = IQR(edad)\n  )\n\n# A tibble: 1 √ó 2\n  rango   ric\n  &lt;dbl&gt; &lt;dbl&gt;\n1    73    36\n\n\nEl paquete dlookr ofrece la funci√≥n describe() para generar un resumen completo de las variables num√©ricas:\n\ndescribe(datos, -id)\n\n# A tibble: 3 √ó 26\n  described_variables     n    na  mean    sd se_mean   IQR skewness kurtosis\n  &lt;chr&gt;               &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n1 edad                   74     0  48.1  20.1    2.34  36     -0.211    -1.11\n2 peso                   74     0 358.  323.    37.6  626.     0.451    -1.41\n3 talla                  74     0 363.  505.    58.7   12.8    2.19      2.90\n# ‚Ñπ 17 more variables: p00 &lt;dbl&gt;, p01 &lt;dbl&gt;, p05 &lt;dbl&gt;, p10 &lt;dbl&gt;, p20 &lt;dbl&gt;,\n#   p25 &lt;dbl&gt;, p30 &lt;dbl&gt;, p40 &lt;dbl&gt;, p50 &lt;dbl&gt;, p60 &lt;dbl&gt;, p70 &lt;dbl&gt;,\n#   p75 &lt;dbl&gt;, p80 &lt;dbl&gt;, p90 &lt;dbl&gt;, p95 &lt;dbl&gt;, p99 &lt;dbl&gt;, p100 &lt;dbl&gt;\n\n\nEsta funci√≥n puede aplicarse directamente sobre todo el conjunto de datos. Si bien selecciona autom√°ticamente las variables num√©ricas, en este caso estamos excluyendo expl√≠citamente la variable id, ya que un identificador no tiene inter√©s estad√≠stico.\nEl resumen que devuelve incluye:\n\nna: cantidad de observaciones con datos y con NA.\nmean: media aritm√©tica.\nsd: desv√≠o est√°ndar de la media.\nse_mean: error est√°ndar de la media.\nIQR: rango intercuart√≠lico.\nMedidas de forma como la simetr√≠a (skewness) y la curtosis (kurtosis).\nPercentiles, incluyendo la mediana (P50) y los cuartiles (P25 y P75).\nResumir variables cualitativas\nLas variables cualitativas o categ√≥ricas pueden encontrarse en R bajo los tipos de dato character o factor. En ocasiones ser√° necesario convertirlas a factor, ya que este tipo permite aplicar ciertos procedimientos espec√≠ficos para variables categ√≥ricas.\nFrecuencias\nPodemos resumir individualmente variables cualitativas mediante las frecuencias absolutas y relativas de sus categor√≠as. La funci√≥n count() de dplyr nos muestra el conteo absoluto:\n\ndatos |&gt; \n  count(sexo)\n\n# A tibble: 3 √ó 2\n  sexo      n\n  &lt;chr&gt; &lt;int&gt;\n1 F        27\n2 M        44\n3 &lt;NA&gt;      3\n\n\nEn la salida se incluir√°n, adem√°s de las categor√≠as presentes, las observaciones con valores faltantes (NA).\nLa inclusi√≥n o no de los valores faltantes depender√° del prop√≥sito del an√°lisis. Para excluirlos, podemos utilizar drop_na():\n\ndatos |&gt; \n  count(sexo) |&gt; \n  # Saltea los valores NA\n  drop_na()  \n\n# A tibble: 2 √ó 2\n  sexo      n\n  &lt;chr&gt; &lt;int&gt;\n1 F        27\n2 M        44\n\n\nPara obtener frecuencias relativas en porcentaje:\n\ndatos |&gt;  \n  count(sexo) |&gt;  \n  # Saltea los valores NA\n  drop_na() |&gt; \n  # Transforma a porcentajes\n  mutate(porc = 100 * n / sum(n))\n\n# A tibble: 2 √ó 3\n  sexo      n  porc\n  &lt;chr&gt; &lt;int&gt; &lt;dbl&gt;\n1 F        27  38.0\n2 M        44  62.0\n\n\nRedondeamos el valor del porcentaje con round():\n\ndatos |&gt;  \n  count(sexo) |&gt;  \n  # Saltea los valores NA\n  drop_na() |&gt; \n  # Transforma a porcentajes y redondea decimales\n  mutate(\n    porc = 100 * n / sum(n),\n    porc = round(porc, digits = 2)\n  )\n\n# A tibble: 2 √ó 3\n  sexo      n  porc\n  &lt;chr&gt; &lt;int&gt; &lt;dbl&gt;\n1 F        27  38.0\n2 M        44  62.0\n\n\nEl paquete janitor (Firke 2024) ofrece una alternativa m√°s completa mediante la funci√≥n tabyl():\n\ndatos |&gt;\n  tabyl(sexo)\n\n sexo  n    percent valid_percent\n    F 27 0.36486486     0.3802817\n    M 44 0.59459459     0.6197183\n &lt;NA&gt;  3 0.04054054            NA\n\n\nEsta funci√≥n muestra tanto frecuencias absolutas como relativas, incluyendo y excluyendo los valores NA (porcentaje sobre el total de valores v√°lidos).\nPodemos mejorar la presentaci√≥n combinando otras funciones del paquete:\n\ndatos |&gt;  \n  # Exclu√≠mos valores NA\n  tabyl(sexo, show_na = F) |&gt; \n  # A√±adimos totales por fila\n  adorn_totals(where = \"row\") |&gt;  \n  # Redondea porcentajes a 2 decimales\n  adorn_pct_formatting(digits = 2) \n\n  sexo  n percent\n     F 27  38.03%\n     M 44  61.97%\n Total 71 100.00%\n\n\nTablas de contingencia\nLa forma m√°s adecuada de describir la relaci√≥n entre dos variables cualitativas es a trav√©s de una tabla de contingencia, en la cual:\n\nLas filas representan las categor√≠as de una variable.\nLas columnas representan las categor√≠as de otra variable.\nLas celdas muestran el n√∫mero de observaciones correspondientes a cada combinaci√≥n de categor√≠as.\n\nLa funci√≥n tabyl() tambi√©n permite crear este tipo de tablas. A continuaci√≥n, un ejemplo entre sexo y trabaja (aunque trabaja sea l√≥gica, puede tratarse como categ√≥rica):\n\ndatos |&gt;  \n  tabyl(sexo, trabaja) \n\n sexo FALSE TRUE NA_\n    F     8   15   4\n    M    17   22   5\n &lt;NA&gt;     1    2   0\n\n\nRecordemos que el orden dentro de los par√©ntesis de la funci√≥n es igual al de los √≠ndices, el primer argumento es la variable que aparecer√° en las filas y el segundo la variable de las columnas. Por ese motivo, en la tabla de contingencia absoluta tenemos sexo en las filas y trabaja en las columnas.\nSe puede mejorar la tabla excluyendo los valores NA y agregando totales por fila:\n\ndatos |&gt;  \n  # Exclu√≠mos valores NA\n  tabyl(sexo, trabaja, show_na = F) |&gt; \n  # A√±adimos totales por fila\n  adorn_totals(where = \"row\")\n\n  sexo FALSE TRUE\n     F     8   15\n     M    17   22\n Total    25   37\n\n\nPara calcular frecuencias relativas porcentuales por columna usamos el siguiente c√≥digo:\n\ndatos |&gt;  \n  # Exclu√≠mos valores NA\n  tabyl(sexo, trabaja, show_na = F) |&gt; \n  # A√±adimos totales\n  adorn_totals(where = \"row\") |&gt; \n  # A√±adimos porcentajes por columna\n  adorn_percentages(denominator = \"col\") |&gt; \n  # Redondea porcentajes a 2 decimales\n  adorn_pct_formatting(digits = 2) \n\n  sexo   FALSE    TRUE\n     F  32.00%  40.54%\n     M  68.00%  59.46%\n Total 100.00% 100.00%\n\n\nCalculamos frecuencias relativas porcentuales por fila:\n\ndatos |&gt;  \n  # Exclu√≠mos valores NA\n  tabyl(sexo, trabaja, show_na = F) |&gt; \n  # A√±adimos totales por columna\n  adorn_totals(where = \"col\") |&gt; \n  # A√±adimos porcentajes por fila\n  adorn_percentages(denominator = \"row\") |&gt; \n  # Redondea porcentajes a 2 decimales\n  adorn_pct_formatting(digits = 2)\n\n sexo  FALSE   TRUE   Total\n    F 34.78% 65.22% 100.00%\n    M 43.59% 56.41% 100.00%\n\n\nCambiando el argumento denominator por \"all\" se calculan frecuencias relativas al total:\n\ndatos |&gt;  \n  # Exclu√≠mos valores NA\n  tabyl(sexo, trabaja, show_na = F) |&gt; \n  # A√±adimos totales por columna\n  adorn_totals(where = \"col\") |&gt; \n  # A√±adimos porcentajes al total\n  adorn_percentages(denominator = \"all\") |&gt; \n  # Redondea porcentajes a 2 decimales\n  adorn_pct_formatting(digits = 2)\n\n sexo  FALSE   TRUE  Total\n    F 12.90% 24.19% 37.10%\n    M 27.42% 35.48% 62.90%\n\n\nExplorar variables mediante gr√°ficos\nUno de los aportes m√°s importantes de John Tukey al an√°lisis de datos es la incorporaci√≥n de los gr√°ficos como herramienta exploratoria. A trav√©s de representaciones visuales podemos detectar r√°pidamente patrones, anomal√≠as, valores extremos, asimetr√≠as o relaciones entre variables.\nEn R, los gr√°ficos m√°s √∫tiles para explorar la distribuci√≥n univariada de las variables son:\n\nPara variables cualitativas: gr√°ficos de barras\nPara variables cuantitativas: histogramas, gr√°ficos de densidad, boxplots y violin plots\n\nCuando queremos explorar la relaci√≥n entre dos o m√°s variables, los tipos de gr√°ficos m√°s comunes incluyen:\n\nDiagramas de dispersi√≥n (puntos)\nGr√°ficos de l√≠neas\nGr√°ficos de mosaico para variables categ√≥ricas cruzadas\n\n\n\nEl lenguaje R soporta una serie de sistemas gr√°ficos asociados a paquetes como graphics, lattice, ggplot2, etc. que sirven de base incluso para otros paquetes con funciones m√°s espec√≠ficas. Actualmente el est√°ndar gr√°fico en R es ggplot2.\nEn el documento dedicado a tidyverse ya explicamos c√≥mo funciona ggplot2. Aqu√≠ nos concentraremos √∫nicamente en aplicar distintos elementos geom√©tricos (geoms) para representar las variables seg√∫n su tipo.\nBarras (univariado)\nEl gr√°fico de barras permite visualizar la frecuencia de las categor√≠as de una variable cualitativa:\n\ndatos |&gt; \n  # Omitimos los NA de sexo\n  drop_na(sexo) |&gt; \n  # Generamos histograma\n  ggplot(aes(x = sexo, fill = sexo)) + \n  geom_bar() + \n  scale_fill_manual(values = c(\"palevioletred4\", \"orange\")) +\n  theme_minimal()\n\n\n\n\n\n\n\nBarras (bivariado)\nCuando cruzamos dos variables categ√≥ricas, podemos representar la relaci√≥n entre ambas modificando el argumento position de geom_bar().\nEl argumento position = \"stack\" nos muestra los valores absolutos acumulados:\n\ndatos |&gt; \n  # Omitimos los NA de sexo y trabaja\n  drop_na(sexo, trabaja) |&gt; \n  # Generamos gr√°fico de barras\n  ggplot(aes(x = sexo, fill = trabaja)) + \n  geom_bar(position = \"stack\") + \n  scale_fill_brewer(palette = \"Set1\") +\n  theme_minimal()\n\n\n\n\n\n\n\nPor otro lado, el argumento position = ‚Äúdodge‚Äù muestra las barras lado a lado, permitiendo comparar proporciones entre grupos:\n\ndatos |&gt; \n  # Omitimos los NA de sexo y trabaja\n  drop_na(sexo, trabaja) |&gt; \n  # Generamos gr√°fico de barras\n  ggplot(aes(x = sexo, fill = trabaja)) + \n  geom_bar(position = \"dodge\") + \n  scale_fill_brewer(palette = \"Set1\") +\n  theme_minimal()\n\n\n\n\n\n\n\nFinalmente, position = \"fill\" convierte las alturas en proporciones sobre el total por grupo:\n\ndatos |&gt; \n  # Omitimos los NA de sexo y trabaja\n  drop_na(sexo, trabaja) |&gt; \n  # Generamos gr√°fico de barras\n  ggplot(aes(x = sexo, fill = trabaja)) + \n  geom_bar(position = \"fill\") + \n  scale_fill_brewer(palette = \"Set1\") +\n  theme_minimal()\n\n\n\n\n\n\n\nHistograma\nRepresenta la frecuencia de valores en intervalos definidos. √ötil para observar la forma general de la distribuci√≥n:\n\ndatos |&gt; \n  # Genera histograma\n  ggplot(aes(x = edad)) +\n  geom_histogram(binwidth = 10,\n                 fill = \"royalblue1\",\n                 color = \"white\"\n                )\n\n\n\n\n\n\n\nDensidad\nEs una estimaci√≥n suave de la distribuci√≥n de frecuencias:\n\ndatos |&gt; \n  ggplot(aes(x = edad)) + \n  geom_density(fill = \"thistle1\")  \n\n\n\n\n\n\n\nBoxplot\nMuestra el rango intercuart√≠lico, la mediana y los valores at√≠picos. Ideal para detectar asimetr√≠as y outliers:\n\ndatos |&gt; \n  # Genera boxplot\n  ggplot(aes(x = edad)) + \n  geom_boxplot(fill = \"seagreen4\")  \n\n\n\n\n\n\n\nViolinplot\nCombina el boxplot con una curva de densidad reflejada. Permite visualizar tanto la forma de la distribuci√≥n como los cuantiles:\n\ndatos |&gt; \n  # Omitimos los NA de sexo\n  drop_na(sexo) |&gt; \n  # Genera violinplot\n  ggplot(aes(x = edad, y = sexo, fill = sexo)) + \n  geom_violin() +\n  scale_fill_brewer(palette = \"Set2\") +\n  theme_light()\n\n\n\n\n\n\n\nQ-Q Plot\nLos gr√°ficos Q-Q (cuantil-cuantil) permiten evaluar visualmente si una variable sigue una distribuci√≥n te√≥rica, como la normal. Suelen usarse como m√©todo gr√°fico para analizar ‚Äúnormalidad‚Äù, es decir cuanto se asemeja la distribuci√≥n de la variable a la distribuci√≥n normal o gaussiana.\nLa funci√≥n plot_normality() de dlookr muestra un diagn√≥stico gr√°fico de normalidad de una variable usando histogramas y Q-Q plot. Adem√°s muestra otros histogramas con conversiones de datos (logar√≠tmico y ra√≠z cuadrada por defecto, pero tambi√©n ‚ÄúBox-Cox‚Äù y otras):\n\n# Sobre la variable edad\ndatos |&gt; \n  plot_normality(edad)\n\n\n\n\n\n\n# Sobre la variable peso\ndatos |&gt; \n  plot_normality(peso)\n\n\n\n\n\n\n\nPodemos decir que la variable peso se ajusta mejor a una distribuci√≥n normal, ya que los puntos del Q-Q plot se alinean m√°s cercanamente a la diagonal te√≥rica.\n\nNota: Este an√°lisis gr√°fico de normalidad suele complementarse con pruebas estad√≠sticas espec√≠ficas, que abordaremos en la Unidad 2.",
    "crumbs": [
      "Unidad 1",
      "An√°lisis exploratorio de datos"
    ]
  },
  {
    "objectID": "unidad_1/analisis_exploratorio.html#detecci√≥n-de-valores-at√≠picos",
    "href": "unidad_1/analisis_exploratorio.html#detecci√≥n-de-valores-at√≠picos",
    "title": "An√°lisis exploratorio de datos",
    "section": "Detecci√≥n de valores at√≠picos",
    "text": "Detecci√≥n de valores at√≠picos\nUn valor at√≠pico (outlier) es una observaci√≥n que se encuentra num√©ricamente alejada del resto de los datos. Su presencia puede tener diferentes causas, y su tratamiento depender√° del contexto:\n\nErrores de carga o procedimiento: deben corregirse si se detectan.\nValores extremos plausibles: pueden ser v√°lidos, pero conviene evaluarlos en detalle.\nEventos extraordinarios o causas desconocidas: si no se pueden justificar, suelen excluirse del an√°lisis.\n\nEstos valores pueden afectar sensiblemente ciertos estad√≠sticos como la media, distorsionando su interpretaci√≥n.\nUna forma gr√°fica com√∫n de detectar valores at√≠picos es mediante los boxplots. Los puntos situados fuera de los ‚Äúbigotes‚Äù representan posibles outliers.\nA continuaci√≥n, se presenta un ejemplo con la variable peso, donde se observa un valor extremo en el l√≠mite superior de la distribuci√≥n (punto rojo):\n\ndatos |&gt; \n  ggplot(aes(x = peso)) + \n  geom_boxplot(fill = \"darkkhaki\", \n               outlier.color = \"red\"\n              )  \n\n\n\n\n\n\n\nEste valor coincide con el m√°ximo observado:\n\nmax(datos$peso)\n\n[1] 1105\n\n\nEl paquete dlookr incluye la funci√≥n diagnose_outlier() para la detecci√≥n automatizada de valores at√≠picos en todas las variables num√©ricas de un conjunto de datos:\n\ndiagnose_outlier(datos)\n\n# A tibble: 4 √ó 6\n  variables outliers_cnt outliers_ratio outliers_mean with_mean without_mean\n  &lt;chr&gt;            &lt;int&gt;          &lt;dbl&gt;         &lt;dbl&gt;     &lt;dbl&gt;        &lt;dbl&gt;\n1 id                   0            0             NaN      37.5         37.5\n2 edad                 0            0             NaN      48.1         48.1\n3 peso                 0            0             NaN     358.         358. \n4 talla               10           13.5          1630     363.         165. \n\n\nEsta funci√≥n devuelve una tabla que incluye, para cada variable: cantidad y proporci√≥n de outliers detectados, media de la variable incluyendo los outliers, media de la variable excluyendo los outliers. En funci√≥n de estos dos estad√≠sticos se puede comparar el efecto de los valores at√≠picos en la media.\nEl paquete skimr (Waring et¬†al. 2022) permite obtener un resumen estad√≠stico compacto y amigable de un conjunto de datos mediante la funci√≥n skim():\n\nskim(datos)\n\n\nData summary\n\n\nName\ndatos\n\n\nNumber of rows\n74\n\n\nNumber of columns\n7\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n1\n\n\nDate\n1\n\n\nlogical\n1\n\n\nnumeric\n4\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\nsexo\n3\n0.96\n1\n1\n0\n2\n0\n\n\nVariable type: Date\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\nfecha\n0\n1\n2020-10-20\n2020-12-15\n2020-11-11\n11\n\n\nVariable type: logical\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\ncount\n\n\ntrabaja\n9\n0.88\n0.6\nTRU: 39, FAL: 26\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\nid\n0\n1\n37.50\n21.51\n1\n19.25\n37.5\n55.75\n74\n‚ñá‚ñá‚ñá‚ñá‚ñá\n\n\nedad\n0\n1\n48.07\n20.12\n13\n28.00\n52.5\n64.00\n86\n‚ñá‚ñÉ‚ñá‚ñá‚ñÉ\n\n\npeso\n0\n1\n358.05\n323.31\n42\n75.00\n91.5\n700.50\n1105\n‚ñá‚ñÅ‚ñÇ‚ñÉ‚ñÅ\n\n\ntalla\n0\n1\n363.09\n504.93\n148\n161.00\n166.0\n173.75\n1745\n‚ñá‚ñÅ‚ñÅ‚ñÅ‚ñÅ\n\n\n\n\n\nAdem√°s, puede integrarse f√°cilmente con la gram√°tica tidyverse. Por ejemplo, podemos explorar estad√≠sticas descriptivas de variables num√©ricas agrupadas por sexo:\n\ndatos |&gt; \n  # Excluye NAs de sexo\n  drop_na(sexo) |&gt;\n  # Agrupa por sexo\n  group_by(sexo) |&gt;\n  # Solo variables num√©ricas - id\n  select(where(is.numeric), -id) |&gt; \n  # Explora outliers\n  skim()\n\n\nData summary\n\n\nName\nselect(‚Ä¶)\n\n\nNumber of rows\n71\n\n\nNumber of columns\n4\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n3\n\n\n________________________\n\n\n\nGroup variables\nsexo\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nsexo\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\nedad\nF\n0\n1\n41.89\n19.64\n15\n26.00\n39.0\n54.50\n83\n‚ñá‚ñÉ‚ñÖ‚ñÉ‚ñÇ\n\n\nedad\nM\n0\n1\n51.59\n19.56\n13\n40.75\n55.5\n64.75\n86\n‚ñÖ‚ñÇ‚ñÖ‚ñá‚ñÇ\n\n\npeso\nF\n0\n1\n426.78\n300.85\n42\n70.50\n516.0\n677.00\n856\n‚ñá‚ñÅ‚ñÉ‚ñÉ‚ñÜ\n\n\npeso\nM\n0\n1\n306.95\n331.27\n64\n78.00\n86.5\n647.00\n1105\n‚ñá‚ñÅ‚ñÅ‚ñÇ‚ñÅ\n\n\ntalla\nF\n0\n1\n421.74\n562.57\n148\n155.50\n161.0\n167.50\n1625\n‚ñá‚ñÅ‚ñÅ‚ñÅ‚ñÇ\n\n\ntalla\nM\n0\n1\n340.77\n485.79\n158\n164.00\n168.5\n177.25\n1745\n‚ñá‚ñÅ‚ñÅ‚ñÅ‚ñÅ\n\n\n\n\n\nEn este ejemplo, mostramos resultados de variables num√©ricas menos de id agrupados por sexo (sin considerar valores NA en las categor√≠as de sexo).",
    "crumbs": [
      "Unidad 1",
      "An√°lisis exploratorio de datos"
    ]
  },
  {
    "objectID": "unidad_1/hoja_estilo.html",
    "href": "unidad_1/hoja_estilo.html",
    "title": "Hoja de Estilo del lenguaje R",
    "section": "",
    "text": "R es bastante indulgente con la forma en que escribimos c√≥digo, a diferencia de otros lenguajes como Python, donde un espacio mal puesto puede arruinar el script. Sin embargo, adoptar una gu√≠a de estilo mejora la legibilidad, facilita la colaboraci√≥n y reduce errores.\nLas siguientes l√≠neas de c√≥digo producen el mismo resultado, pero no todas son igual de claras:\n\n# Opci√≥n 1\nmpg |&gt; \n  filter(cty &gt; 10, class == \"compact\")\n\n# Opci√≥n 2\nmpg |&gt; filter(cty &gt; 10, class == \"compact\")\n\n# Opci√≥n 3\nmpg |&gt; \n  filter(cty &gt; 10, \n         class == \"compact\")\n\n# Opci√≥n 4\nmpg |&gt; filter(cty&gt;10, class==\"compact\")\n\n# Opci√≥n 5\nfilter(mpg,cty&gt;10,class==\"compact\")\n\n# Opci√≥n 6\nmpg |&gt; \nfilter(cty &gt; 10, \n                        class == \"compact\")\n\n# Opci√≥n 7\nfilter ( mpg,cty&gt;10,     class==\"compact\" )\n\nLas tres primeras versiones son m√°s legibles. El resto, aunque v√°lidas, son dif√≠ciles de seguir, especialmente en trabajos colaborativos o materiales docentes.",
    "crumbs": [
      "Unidad 1",
      "Hoja de Estilo del lenguaje R"
    ]
  },
  {
    "objectID": "unidad_1/hoja_estilo.html#convenciones-de-estilo-r",
    "href": "unidad_1/hoja_estilo.html#convenciones-de-estilo-r",
    "title": "Hoja de Estilo del lenguaje R",
    "section": "",
    "text": "R es bastante indulgente con la forma en que escribimos c√≥digo, a diferencia de otros lenguajes como Python, donde un espacio mal puesto puede arruinar el script. Sin embargo, adoptar una gu√≠a de estilo mejora la legibilidad, facilita la colaboraci√≥n y reduce errores.\nLas siguientes l√≠neas de c√≥digo producen el mismo resultado, pero no todas son igual de claras:\n\n# Opci√≥n 1\nmpg |&gt; \n  filter(cty &gt; 10, class == \"compact\")\n\n# Opci√≥n 2\nmpg |&gt; filter(cty &gt; 10, class == \"compact\")\n\n# Opci√≥n 3\nmpg |&gt; \n  filter(cty &gt; 10, \n         class == \"compact\")\n\n# Opci√≥n 4\nmpg |&gt; filter(cty&gt;10, class==\"compact\")\n\n# Opci√≥n 5\nfilter(mpg,cty&gt;10,class==\"compact\")\n\n# Opci√≥n 6\nmpg |&gt; \nfilter(cty &gt; 10, \n                        class == \"compact\")\n\n# Opci√≥n 7\nfilter ( mpg,cty&gt;10,     class==\"compact\" )\n\nLas tres primeras versiones son m√°s legibles. El resto, aunque v√°lidas, son dif√≠ciles de seguir, especialmente en trabajos colaborativos o materiales docentes.",
    "crumbs": [
      "Unidad 1",
      "Hoja de Estilo del lenguaje R"
    ]
  },
  {
    "objectID": "unidad_1/hoja_estilo.html#gu√≠a-de-estilo-de-tidyverse",
    "href": "unidad_1/hoja_estilo.html#gu√≠a-de-estilo-de-tidyverse",
    "title": "Hoja de Estilo del lenguaje R",
    "section": "Gu√≠a de estilo de tidyverse",
    "text": "Gu√≠a de estilo de tidyverse\nPara ayudar a mejorar la legibilidad y facilitar el compartir c√≥digo con otros, el equipo de Tidyverse public√≥ una gu√≠a concisa con ejemplos claros de buenas y malas formas de escribir c√≥digo, nombres de variables, sangr√≠a, l√≠neas largas, y m√°s:\nüîó style.tidyverse.org\nAdem√°s, RStudio incluye herramientas para aplicar estas convenciones autom√°ticamente. Por ejemplo, seleccionando el c√≥digo y presionando Ctrl + i (Windows) se puede reidentar el texto. No siempre es perfecto, pero es realmente √∫til para lograr la sangr√≠a correcta sin tener que presionar manualmente espacio muchas veces.\nEspaciado\nColocar espacios despu√©s de las comas:\n‚úîÔ∏è Correcto\n\nfilter(mpg, cty &gt; 10)\n\n‚úñÔ∏è Incorrecto\n\nfilter(mpg , cty &gt; 10)\n\nfilter(mpg ,cty &gt; 10)\n\nfilter(mpg,cty &gt; 10)\n\nColocar espacios despu√©s de comas y alrededor de operadores (+, -, &gt;, =, etc.) mejora la legibilidad. Tambi√©n se deben evitar espacios innecesarios dentro de par√©ntesis:\n‚úîÔ∏è Correcto\n\nfilter(mpg, cty &gt; 10)\n\n‚úñÔ∏è Incorrecto\n\nfilter(mpg, cty&gt;10)\n\nfilter(mpg, cty&gt; 10)\n\nfilter(mpg, cty &gt;10)\n\nNo colocar espacios alrededor de par√©ntesis que sean parte de funciones:\n‚úîÔ∏è Correcto\n\nfilter(mpg, cty &gt; 10)\n\n‚úñÔ∏è Incorrecto\n\nfilter (mpg, cty &gt; 10)\n\nfilter ( mpg, cty &gt; 10)\n\nfilter( mpg, cty &gt; 10 )\n\nL√≠neas largas\nEn general, es una buena pr√°ctica no tener l√≠neas de c√≥digo muy largas. Se recomienda limitar las l√≠neas a 80 caracteres. Para visualizarlo, en RStudio vamos a Tools &gt; Global Options &gt; Code &gt; Displayy seleccionamos la casilla Show margin.\nSe sugiere agregar saltos de l√≠nea dentro de las l√≠neas de c√≥digo m√°s largas, los mismos deben colocarse luego de las comas y los argumentos se deben alinear dentro de la funci√≥n:\n‚úîÔ∏è Correcto\n\nfilter(mpg, cty &gt; 10, class == \"compact\")\n\n\nfilter(mpg, cty &gt; 10, \n       class == \"compact\")\n\n\nfilter(mpg,\n       cty &gt; 10,\n       class == \"compact\")\n\nfilter(mpg, \n       cty &gt; 10, \n       class %in% c(\"compact\", \"pickup\", \"midsize\", \"subcompact\", \n                    \"suv\", \"2seater\", \"minivan\"))\n\n‚úñÔ∏è Incorrecto\n\nfilter(mpg, cty &gt; 10, class %in% c(\"compact\", \"pickup\", \"midsize\", \"subcompact\", \"suv\", \"2seater\", \"minivan\"))\n\nTuber√≠as y capas ggplot2\n\nColocar cada paso de la tuber√≠a (%&gt;% √≥ |&gt;) en una l√≠nea separada, con sangr√≠a de dos espacios debajo del operador:\n‚úîÔ∏è Correcto\n\nmpg |&gt; \n  filter(cty &gt; 10) |&gt; \n  group_by(class) |&gt; \n  summarize(avg_hwy = mean(hwy))\n\n‚úñÔ∏è Incorrecto\n\n# Mal\nmpg |&gt; filter(cty &gt; 10) |&gt; group_by(class) |&gt; \n  summarize(avg_hwy = mean(hwy))\n\n# Muy mal\nmpg |&gt; filter(cty &gt; 10) |&gt; group_by(class) |&gt; summarize(avg_hwy = mean(hwy))\n\n# Tan mal que no funciona\nmpg |&gt; \n  filter(cty &gt; 10)\n  |&gt; group_by(class)\n  |&gt; summarize(avg_hwy = mean(hwy))\n\nLo mismo aplica para las capas de gr√°ficos de ggplot2, usando el conector + al final de la l√≠nea y debajo sangr√≠a de dos espacios:\n‚úîÔ∏è Correcto\n\nggplot(mpg, aes(x = cty, y = hwy, color = class)) +\n  geom_point() +\n  geom_smooth() +\n  theme_bw()\n\n# Mal\nggplot(mpg, aes(x = cty, y = hwy, color = class)) +\n  geom_point() + geom_smooth() +\n  theme_bw()\n\n# Muy mal\nggplot(mpg, aes(x = cty, y = hwy, color = class)) + geom_point() + geom_smooth() + theme_bw()\n\n# Tan mal que no funciona\nggplot(mpg, aes(x = cty, y = hwy, color = class))\n  + geom_point()\n  + geom_smooth() \n  + theme_bw()\n\n‚úñÔ∏è Incorrecto\n\n# Mal\nggplot(mpg, aes(x = cty, y = hwy, color = class)) +\n  geom_point() + geom_smooth() +\n  theme_bw()\n\n# Muy mal\nggplot(mpg, aes(x = cty, y = hwy, color = class)) + geom_point() + geom_smooth() + theme_bw()\n\n# Tan mal que no funciona\nggplot(mpg, aes(x = cty, y = hwy, color = class))\n  + geom_point()\n  + geom_smooth() \n  + theme_bw()\n\nComentarios\nLos comentarios deben comenzar con # seguido de un espacio:\n‚úîÔ∏è Correcto\n\n# Bien\n\n‚úñÔ∏è Incorrecto\n\n#Mal\n\n    #Mal\n\nSi el comentario es corto, se puede incluir en la misma l√≠nea, separado por al menos dos espacios para mejorar la legibilidad:\n\nmpg |&gt; \n  filter(cty &gt; 10) |&gt;  # filtro filas donde cty es 10 o m√°s\n  group_by(class) |&gt;  # estratifica por class\n  summarize(avg_hwy = mean(hwy))  # resume la media de hwy por cada grupo\n\nSe puede agregar espacios adicionales para alinear los comentarios en l√≠nea, si lo deseamos:\n\nmpg |&gt; \n  filter(cty &gt; 10) |&gt;             # filtro filas donde cty es 10 o m√°s\n  group_by(class) |&gt;              # estratifica por class\n  summarize(avg_hwy = mean(hwy))  # resume la media de hwy por cada grupo\n\nSi el comentario es muy largo, podemos dividirlo en varias l√≠neas. RStudio incluye una herramienta √∫til para comentarios largos: Code &gt; Reflow Comment los ajusta autom√°ticamente al ancho deseado.",
    "crumbs": [
      "Unidad 1",
      "Hoja de Estilo del lenguaje R"
    ]
  },
  {
    "objectID": "unidad_1/intro_tidyverse.html#introducci√≥n",
    "href": "unidad_1/intro_tidyverse.html#introducci√≥n",
    "title": "Introducci√≥n a tidyverse",
    "section": "Introducci√≥n",
    "text": "Introducci√≥n\nTidyverse (Wickham et¬†al. 2019) es el nombre que recibe el conjunto de paquetes desarrollados y/o promovidos por Hadley Wickham (jefe cient√≠fico en Posit/RStudio) y su equipo, orientado al trabajo de ciencia de datos con R. Estos paquetes est√°n dise√±ados para integrarse de manera coherente, compartiendo una misma filosof√≠a de dise√±o conocida como The tidy tools manifesto.\nLos cuatro principios b√°sicos sobre los que se construye tidyverse son:\n\nReutilizaci√≥n de estructuras de datos\nResoluci√≥n de problemas complejos combinando varias piezas sencillas\nUso de programaci√≥n funcional\nDise√±o orientado a las personas\n\nLos paquetes incluidos cubren todas las etapas del an√°lisis de datos dentro de R: importaci√≥n y ordenamiento de los datos (tidy data), transformaci√≥n, visualizaci√≥n, modelado y la posterior comunicaci√≥n de resultados.\nLa palabra tidy se traduce como ‚Äúordenado‚Äù, y hace referencia a una estructura espec√≠fica que deben cumplir los datos:\n\nCada variable es una columna de la tabla de datos.\nCada observaci√≥n es una fila de la tabla de datos.\nCada tabla responde a una unidad de observaci√≥n o an√°lisis.\n\n\n\n\n\nAdem√°s de los paquetes principales, al instalar tidyverse se incluyen otros que permiten trabajar con fechas, cadenas de caracteres o factores, tambi√©n siguiendo los mismos principios.\nUno de los objetivos de los desarrolladores fue dotar a la sintaxis de estos paquetes de una gram√°tica clara: funciones cuyos nombres y argumentos permiten construir ‚Äúfrases‚Äù que sean sem√°nticamente comprensibles. Un ejemplo de esto se ve en el paquete dplyr, donde la mayor√≠a de las funciones son verbos en ingl√©s como filter(), mutate(), summarise(), lo que facilita su lectura y comprensi√≥n.\nEl paquete tidyverse (versi√≥n 2.0.0) puede instalarse desde el repositorio oficial CRAN mediante el men√∫ Packages de RStudio, o ejecutando el siguiente c√≥digo:\n\ninstall.packages(\"tidyverse\")\n\nUna vez instalado, se activa mediante:\n\nlibrary(tidyverse)\n\nAl activarlo, se muestra un mensaje con la versi√≥n instalada, la lista de paquetes que se cargan autom√°ticamente y posibles conflictos de nombres entre funciones. Esto es habitual cuando se utilizan m√∫ltiples paquetes, ya que algunas funciones pueden llamarse igual. Por ejemplo, la funci√≥n filter() existe tanto en el paquete stats como en dplyr. Al cargar tidyverse, R avisa de esta superposici√≥n:\n‚úñÔ∏èdplyr::filter() masks stats::filter()\nCuando necesitamos asegurarnos de que estamos usando la funci√≥n de un paquete espec√≠fico, se recomienda usar la notaci√≥n ::, por ejemplo:\n\n# Funci√≥n filter() del paquete stats\nstats::filter()\n\n# Funci√≥n filter() del paquete tidyverse\ndplyr::filter()\n\nUna estrategia √∫til cuando trabajamos con varios paquetes es cargar tidyverse al final de la lista de paquetes, para que sus funciones sobrescriban las de otros paquetes si fuese necesario:\n\nlibrary(stats)\nlibrary(tidyverse)\n\nLos paquetes que se instalan con la versi√≥n actual de tidyverse pueden consultarse ejecutando:\n\ntidyverse_packages()\n\n [1] \"broom\"         \"conflicted\"    \"cli\"           \"dbplyr\"       \n [5] \"dplyr\"         \"dtplyr\"        \"forcats\"       \"ggplot2\"      \n [9] \"googledrive\"   \"googlesheets4\" \"haven\"         \"hms\"          \n[13] \"httr\"          \"jsonlite\"      \"lubridate\"     \"magrittr\"     \n[17] \"modelr\"        \"pillar\"        \"purrr\"         \"ragg\"         \n[21] \"readr\"         \"readxl\"        \"reprex\"        \"rlang\"        \n[25] \"rstudioapi\"    \"rvest\"         \"stringr\"       \"tibble\"       \n[29] \"tidyr\"         \"xml2\"          \"tidyverse\"    \n\n\nAdem√°s, existen muchos otros paquetes que siguen la misma filosof√≠a pero no est√°n incluidos por defecto. En esos casos, deben instalarse y activarse individualmente.\n\n\n\n\n\n\nPara profundizar el uso de tidyverse, se recomienda consultar las siguientes fuentes:\n\nSitio oficial: https://www.tidyverse.org/\nLibro R para Ciencia de Datos: r4ds o la nueva versi√≥n r4ds 2e (por ahora solo disponible en ingl√©s).\nEpiRhandbook en espa√±ol",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a tidyverse"
    ]
  },
  {
    "objectID": "unidad_1/intro_tidyverse.html#dataframes-con-tibble",
    "href": "unidad_1/intro_tidyverse.html#dataframes-con-tibble",
    "title": "Introducci√≥n a tidyverse",
    "section": "Dataframes con tibble\n",
    "text": "Dataframes con tibble\n\n\n\n\n\nUno de los paquetes que forman parte del n√∫cleo b√°sico de tidyverse es tibble (M√ºller y Wickham 2023), que introduce una versi√≥n moderna del objeto data.frame. Todas las funciones que generan tablas de datos en tidyverse devuelven objetos tibble (tbl_df), los cuales son m√°s eficientes y amigables para el flujo de trabajo.\nLas principales ventajas de trabajar con tibble son:\n\nImpresi√≥n en consola m√°s legible y controlada (muestran un n√∫mero limitado de filas y columnas).\nNo cambian autom√°ticamente el tipo de datos.\nPermiten nombres de columnas con espacios o caracteres especiales si se encierran entre comillas invertidas ` (aunque no se recomienda).\n\nPara crear un objeto tibble manualmente usamos el siguiente c√≥digo:\n\ndatos &lt;- tibble(\n  nombre = c(\"Ana\", \"Luis\", \"Mar√≠a\"),\n  edad = c(34, 28, 45),\n  altura = c(1.65, 1.80, 1.70)\n)",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a tidyverse"
    ]
  },
  {
    "objectID": "unidad_1/intro_tidyverse.html#tuber√≠as-con-magrittr",
    "href": "unidad_1/intro_tidyverse.html#tuber√≠as-con-magrittr",
    "title": "Introducci√≥n a tidyverse",
    "section": "Tuber√≠as con magrittr\n",
    "text": "Tuber√≠as con magrittr\n\n\n\n\n\nUna de las incorporaciones m√°s √∫tiles y transversales del ecosistema tidyverse es el uso de ‚Äútuber√≠as‚Äù o pipe operators. Una tuber√≠a conecta un bloque de c√≥digo con otro, permitiendo encadenar operaciones de manera legible. El operador %&gt;%, proveniente del paquete magrittr (Bache y Wickham 2022), transforma llamadas de funciones anidadas (con m√∫ltiples par√©ntesis) en una secuencia de pasos m√°s simple de leer y escribir.\nA partir de la versi√≥n 4.1.0 de R, tambi√©n se incorpor√≥ una tuber√≠a nativa (|&gt;), con un comportamiento muy similar. Ambas opciones son v√°lidas y su uso es pr√°cticamente equivalente.\nEste enfoque refleja el principio de que cada funci√≥n representa un paso en una secuencia l√≥gica de transformaci√≥n de datos. La forma de trabajar se puede ver en el siguiente esquema general:\n\n\n\n\nA continuaci√≥n, mostramos un ejemplo comparativo de c√≥mo cambia la sintaxis usando el dataset incorporado en R mtcars, que contiene datos sobre autos:\n\nhead(sqrt(mtcars)) \n\n                       mpg      cyl     disp        hp     drat       wt\nMazda RX4         4.582576 2.449490 12.64911 10.488088 1.974842 1.618641\nMazda RX4 Wag     4.582576 2.449490 12.64911 10.488088 1.974842 1.695582\nDatsun 710        4.774935 2.000000 10.39230  9.643651 1.962142 1.523155\nHornet 4 Drive    4.626013 2.449490 16.06238 10.488088 1.754993 1.793042\nHornet Sportabout 4.324350 2.828427 18.97367 13.228757 1.774824 1.854724\nValiant           4.254409 2.449490 15.00000 10.246951 1.661325 1.860108\n                      qsec vs am     gear     carb\nMazda RX4         4.057093  0  1 2.000000 2.000000\nMazda RX4 Wag     4.125530  0  1 2.000000 2.000000\nDatsun 710        4.313931  1  1 2.000000 1.000000\nHornet 4 Drive    4.409082  1  0 1.732051 1.000000\nHornet Sportabout 4.125530  0  0 1.732051 1.414214\nValiant           4.496665  1  0 1.732051 1.000000\n\n\nEn la l√≠nea de c√≥digo anterior estamos pidiendo mostrar la cabecera (6 primeras observaciones de la tabla de datos) de la ra√≠z cuadrada de los valores de la tabla mtcars, en formato del lenguaje cl√°sico (anidado).\nAhora activamos magrittr y ejecutamos la l√≠nea anterior en formato tuber√≠a:\n\n# Activa paquete\nlibrary(magrittr) \n\n# Formato tuber√≠a\nmtcars %&gt;%\n  sqrt() %&gt;%\n  head()\n\n                       mpg      cyl     disp        hp     drat       wt\nMazda RX4         4.582576 2.449490 12.64911 10.488088 1.974842 1.618641\nMazda RX4 Wag     4.582576 2.449490 12.64911 10.488088 1.974842 1.695582\nDatsun 710        4.774935 2.000000 10.39230  9.643651 1.962142 1.523155\nHornet 4 Drive    4.626013 2.449490 16.06238 10.488088 1.754993 1.793042\nHornet Sportabout 4.324350 2.828427 18.97367 13.228757 1.774824 1.854724\nValiant           4.254409 2.449490 15.00000 10.246951 1.661325 1.860108\n                      qsec vs am     gear     carb\nMazda RX4         4.057093  0  1 2.000000 2.000000\nMazda RX4 Wag     4.125530  0  1 2.000000 2.000000\nDatsun 710        4.313931  1  1 2.000000 1.000000\nHornet 4 Drive    4.409082  1  0 1.732051 1.000000\nHornet Sportabout 4.125530  0  0 1.732051 1.414214\nValiant           4.496665  1  0 1.732051 1.000000\n\n\nPodemos hacer lo mismo con la tuber√≠a nativa de R sin activar ning√∫n paquete (revisar que est√© activada desde Tools &gt; Global Options):\n\n# Tuber√≠a nativa\nmtcars |&gt; \n  sqrt() |&gt; \n  head()\n\n                       mpg      cyl     disp        hp     drat       wt\nMazda RX4         4.582576 2.449490 12.64911 10.488088 1.974842 1.618641\nMazda RX4 Wag     4.582576 2.449490 12.64911 10.488088 1.974842 1.695582\nDatsun 710        4.774935 2.000000 10.39230  9.643651 1.962142 1.523155\nHornet 4 Drive    4.626013 2.449490 16.06238 10.488088 1.754993 1.793042\nHornet Sportabout 4.324350 2.828427 18.97367 13.228757 1.774824 1.854724\nValiant           4.254409 2.449490 15.00000 10.246951 1.661325 1.860108\n                      qsec vs am     gear     carb\nMazda RX4         4.057093  0  1 2.000000 2.000000\nMazda RX4 Wag     4.125530  0  1 2.000000 2.000000\nDatsun 710        4.313931  1  1 2.000000 1.000000\nHornet 4 Drive    4.409082  1  0 1.732051 1.000000\nHornet Sportabout 4.125530  0  0 1.732051 1.414214\nValiant           4.496665  1  0 1.732051 1.000000\n\n\nLas tuber√≠as le dan mucha mas claridad al c√≥digo separandolo en partes, como si fuesen oraciones de un p√°rrafo.",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a tidyverse"
    ]
  },
  {
    "objectID": "unidad_1/intro_tidyverse.html#lectura-y-escritura-de-datos",
    "href": "unidad_1/intro_tidyverse.html#lectura-y-escritura-de-datos",
    "title": "Introducci√≥n a tidyverse",
    "section": "Lectura y escritura de datos",
    "text": "Lectura y escritura de datos\nArchivos de texto plano con readr\n\n\n\n\n\nEl paquete readr (Wickham, Hester, y Bryan 2024) contiene funciones similares a las de la familia read.table() de R base, pero desarrollados bajo el ecosistema tidyverse.\nLos archivos de texto plano (ASCII u otras codificaciones) son universalmente utilizados por la mayor√≠a de los gestores de bases de datos y planillas de c√°lculo. Generalmente se encuentran con extensiones .txt o .csv (por comma-separated values) y son el tipo de archivo de datos m√°s habitual en R.\nEstos datos planos tienen dos caracter√≠sticas principales:\n\nLa cabecera (en ingl√©s header).\nEl car√°cter o s√≠mbolo separador que indica la separaci√≥n de columnas: pueden estar separadas por comas, punto y coma, tabulaci√≥n, etc.\n\nLa presencia o no de una cabecera se maneja con los argumentos col_names y skip:\n\ncol_names = TRUE indica que la primera fila contiene los nombres de las columnas (cabecera).\ncol_names = FALSE indica que no hay cabecera y las columnas se nombran autom√°ticamente (X1, X2, etc).\nskip = 0 (valor por defecto) lee los datos desde la primera fila, pero si hay encabezados complejos (por ejemplo, t√≠tulos y subt√≠tulos ), se puede indicar cu√°ntas filas deben omitirse. Ejemplo: skip = 5 omite las primeras 5 filas del archivo.\n\nOtro aspecto a considerar es el car√°cter separador utilizado para indicar la separaci√≥n entre columnas. Los separadores m√°s comunes son:\n\ncoma (,)\npunto y coma (;)\ntabulaci√≥n (TAB)\nespacio (\" \")\nbarra vertical o pipe (|)\n\nFunciones de lectura\nAlgunas de las funciones del paquete asumen un separador particular. Por caso read_csv() lee separados por coma y read_tsv() separado por tabulaciones, pero la funci√≥n read_delim() permite que definamos el separador a trav√©s del argumento delim.\nEn forma detallada el paquete readr soporta siete formatos de archivo a partir de siete funciones:\n\n\nread_csv(): archivos separados por comas (CSV).\n\nread_tsv(): archivos separados por tabulaciones.\n\nread_delim(): archivos separados con delimitadores generales.\n\nread_fwf(): archivos con columnas de ancho fijo.\n\nread_table(): archivos formato tabla con columnas separadas por espacios.\n\nread_log(): archivos log web.\n\nEn comparaci√≥n con las funciones R base, las funciones de readr:\n\nUsan un esquema de nombres consistente de par√°metros.\nSon m√°s r√°pidas.\nAnalizan eficientemente los formatos de datos comunes (especialmente fechas y horas).\nMuestra una barra de progreso para archivos grandes.\nVienen incluidas dentro de tidyverse pero tambi√©n pueden usarse de forma independiente:\n\n\nlibrary(readr)\n\nA modo de ejemplo, leeremos un archivo sin cabecera separado por comas bajo el nombre datos:\n\ndatos &lt;- read_csv(\"datos/ejemplo-datos.csv\", \n                  col_names = F)\ndatos\n\n# A tibble: 4 √ó 5\n     X1 X2       X3       X4    X5        \n  &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt; &lt;date&gt;    \n1     9 Leone    Fernando M     1958-12-24\n2    26 Garcia   Esteban  M     1954-01-21\n3    35 Salamone Nicolas  M     1993-06-27\n4    48 Gonzalez Viviana  F     1965-06-21\n\n\nLeemos el mismo archivo con cabecera y separado por punto y comas, bajo el nombre info:\n\ninfo &lt;- read_csv2(\"datos/ejemplo-datos-header.csv\",\n                  col_names = T)\ninfo\n\n# A tibble: 4 √ó 5\n   Iden Apellido Nombre   Sexo  FNac      \n  &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt; &lt;date&gt;    \n1     9 Leone    Fernando M     1958-12-24\n2    26 Garcia   Laura    M     1954-01-21\n3    35 Salamone Nicolas  M     1993-06-27\n4    48 Gonzalez Viviana  F     1965-06-21\n\n\nEn estos ejemplos:\n\nread_csv() espera comas como separador\nread_csv2() espera punto y coma como separador\n\nAl leer un archivo, readr intenta adivinar autom√°ticamente el tipo de dato de cada columna (parse). Si no hay cabecera, los nombres de columna ser√°n X1, X2, etc.\nPodemos inspeccionar la estructura de un dataframe con glimpse():\n\nglimpse(info)\n\nRows: 4\nColumns: 5\n$ Iden     &lt;dbl&gt; 9, 26, 35, 48\n$ Apellido &lt;chr&gt; \"Leone\", \"Garcia\", \"Salamone\", \"Gonzalez\"\n$ Nombre   &lt;chr&gt; \"Fernando\", \"Laura\", \"Nicolas\", \"Viviana\"\n$ Sexo     &lt;chr&gt; \"M\", \"M\", \"M\", \"F\"\n$ FNac     &lt;date&gt; 1958-12-24, 1954-01-21, 1993-06-27, 1965-06-21\n\n\nLos tipos de datos posibles son:\n\ncharacter (&lt;chr&gt;)\ninteger, double o numeric (&lt;int&gt;, &lt;dbl&gt;)\nlogical (&lt;lgl&gt;)\ndate, datetime, etc.\n\nPor ejemplo, columnas con enteros pueden aparecer como &lt;dbl&gt; si se interpretan como double, y las fechas como &lt;date&gt;.\nAgregamos unos argumentos m√°s y ejemplificamos la sintaxis con read_delim() para leer un archivo con cabecera compleja (la tabla comienza en la fila 9) separado por caracteres | (pipes).\n\nread_delim(\"ejemplo-datos-header-skip.txt\", \n           col_names = T, \n           skip = 8, \n           delim = \"|\")\n\n\nImportante: No olvides asignar la lectura a un nombre para guardar el dataframe dentro del entorno de trabajo (por ejemplo: datos &lt;-).\n\nFunciones de escritura\nEl paquete tambi√©n incluye funciones para escribir archivos de texto plano, con formatos espejo de las funciones de lectura m√°s comunes:\n\n\nwrite_csv(): escribe archivos separados por comas\n\nwrite_csv2(): escribe archivos separados por punto y comas\n\nwrite_tsv(): escribe archivos separados por tabulaciones\n\nwrite_delim(): escribe archivos separados con delimitadores definidos por el usuario\n\nLos argumentos son generales y para el caso del √∫ltimo m√°s extensos, dado que hay que definir cual es el separador que deseamos en el archivo. Podemos consultarlos con el siguiente c√≥digo:\n\nargs(write_delim)\n\nfunction (x, file, delim = \" \", na = \"NA\", append = FALSE, col_names = !append, \n    quote = c(\"needed\", \"all\", \"none\"), escape = c(\"double\", \n        \"backslash\", \"none\"), eol = \"\\n\", num_threads = readr_threads(), \n    progress = show_progress(), path = deprecated(), quote_escape = deprecated()) \nNULL\n\n\nPor ejemplo para exportar un conjunto de datos en texto plano al que denominaremos ‚Äúejemplo.csv‚Äú con separador punto y coma y cabecera incluida podemos hacer:\n\nwrite_delim(x = datos, file = \"ejemplo.csv\", delim = \";\")\n\no m√°s sencillo, usando la funci√≥n espec√≠fica write_csv2():\n\nwrite_csv2(datos, \"ejemplo.csv\") # define cabecera y separador ;\n\nLectura de hojas de c√°lculo con readxl\n\n\n\n\n\nUno de los formatos m√°s comunes para almacenar datos son las hojas de c√°lculo, en particular las creadas con Microsoft Excel. El paquete readxl (Wickham y Bryan 2025), parte del ecosistema tidyverse, permite leer este tipo de archivos.\nreadxl es compatible con hojas de c√°lculo de Excel 97-2003, con extensi√≥n .xls, y con versiones m√°s recientes, con extensi√≥n .xlsx.\nUna primera funci√≥n √∫til es excel_sheets(), que permite conocer y listar los nombres de las hojas contenidas en un archivo Excel (tambi√©n llamado libro o workbook).\nPor ejemplo, supongamos que tenemos un archivo denominado ‚Äúdatos.xlsx‚Äú y queremos saber por cuantas hojas est√° compuesto y que nombre tienen:\n\nlibrary(readxl) # hay que activarlo independientemente de tidyverse\n\nexcel_sheets(\"datos/datos.xlsx\")\n\n[1] \"diabetes\"   \"vigilancia\" \"mortalidad\"\n\n\nEsto devuelve, por ejemplo, tres hojas: \"diabetes\", \"vigilancia\" y \"mortalidad\".\nPara leer una de estas hojas utilizamos la funci√≥n read_excel(), cuyos argumentos principales son:\n\nargs(read_excel)\n\nfunction (path, sheet = NULL, range = NULL, col_names = TRUE, \n    col_types = NULL, na = \"\", trim_ws = TRUE, skip = 0, n_max = Inf, \n    guess_max = min(1000, n_max), progress = readxl_progress(), \n    .name_repair = \"unique\") \nNULL\n\n\nEntre los m√°s relevantes encontramos:\n\npath: nombre del archivo y su ubicaci√≥n (entre comillas)\nsheet: nombre de la hoja o su n√∫mero de orden\ncol_names: si es TRUE, toma la primera fila como nombres de las columnas\nskip: permite saltear un n√∫mero determinado de filas antes de comenzar la lectura\n\nAl ejecutar read_excel(), internamente se utiliza la funci√≥n excel_format() para detectar si el archivo es .xls o .xlsx, y luego se aplica la funci√≥n espec√≠fica para cada caso: read_xls() o read_xlsx(). Estas funciones tambi√©n pueden usarse directamente si se desea.\nSupongamos ahora que queremos leer la hoja llamada \"diabetes\":\n\ndiabetes &lt;- read_excel(path = \"datos/datos.xlsx\", \n                       sheet = \"diabetes\",\n                       col_names = T)\n\n# mostramos las 6 primeras observaciones\nhead(diabetes)\n\n# A tibble: 6 √ó 8\n    A1C  hba1 GLUCB   SOG Tol_Glucosa    DM    SM  HOMA\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  6.17   7.9   101   122 IFG             0     1  4.04\n2  5.58   7.2   103   100 IFG             0     0  5.03\n3  5.38   7.1   103    90 IFG             0     1  2.92\n4  5.38   6.6   109    96 IFG             0     1  4.79\n5  5.19   6.3   107    69 IFG             0     1  3.06\n6  4.89   6      NA   117 IFG             0     0  5.77\n\n\nObservemos que en los argumentos escribimos el nombre del archivo que se encuentra en nuestro proyecto y por lo tanto en nuestra carpeta activa, el nombre de la hoja y nos aseguramos que la primer fila representa a la cabecera de la tabla (sus nombres de variables).\nComo readxl forma parte del ecosistema tidyverse el formato de salida es un tibble. En este caso de 23 observaciones por 8 variables.\nAhora leamos la segunda hoja de nombre \"vigilancia\":\n\nvigilancia &lt;- read_excel(path = \"datos/datos.xlsx\", \n                         sheet = 2, \n                         col_names = F)\n\n# mostramos las 6 primeras observaciones\nhead(vigilancia)\n\n# A tibble: 6 √ó 9\n   ...1 ...2        ...3      ...4  ...5  ...6  ...7 ...8  ...9                 \n  &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;                \n1   875 09/28/2015  2015 544080000     1    31     1 F     VIGILANCIA EN SALUD ‚Ä¶\n2   875 42317       2015 544080000     1    35     1 F     VIGILANCIA EN SALUD ‚Ä¶\n3   875 42317       2015 544080000     1    47     1 F     VIGILANCIA EN SALUD ‚Ä¶\n4   307 09/26/2015  2015 544005273     1    23     1 M     VIGILANCIA INTEGRADA‚Ä¶\n5   307 09/24/2015  2015 544005273     1    19     1 M     VIGILANCIA INTEGRADA‚Ä¶\n6   875 09/28/2015  2015 544080000     1    63     1 F     VIGILANCIA EN SALUD ‚Ä¶\n\n\nEn este caso, en lugar del nombre de la hoja usamos un 2 que es su ubicaci√≥n y especificamos col_names = FALSE porque el conjunto de datos no tiene cabecera. readxl asignar√° nombres gen√©ricos como ...1, ...2, etc.\nFinalmente leamos la √∫ltima hoja disponible del archivo:\n\nmortalidad &lt;- read_excel(path = \"datos/datos.xlsx\", \n                         sheet = \"mortalidad\",\n                         col_names = T, \n                         skip = 1)\n\n# mostramos las 6 primeras observaciones\nhead(mortalidad) \n\n# A tibble: 5 √ó 10\n  grupo_edad grupo.I.1.1 grupo.II.1.1 grupo.III.1.1 grupo.I.2.1 grupo.II.2.1\n  &lt;chr&gt;            &lt;dbl&gt;        &lt;dbl&gt;         &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;\n1 30-44               41          202           222         539         1438\n2 45-59               99         1071           181         759         6210\n3 60-69              114         1782           119         985         9238\n4 70-79              221         2336           119        1571        12369\n5 80+                362         2492            81        2523        14642\n# ‚Ñπ 4 more variables: grupo.III.2.1 &lt;dbl&gt;, grupo.I.3.1 &lt;dbl&gt;,\n#   grupo.II.3.1 &lt;dbl&gt;, grupo.III.3.1 &lt;dbl&gt;\n\n\nLo novedoso de esta lectura es el argumento skip = 1 que debimos incorporar dado que, en este caso, la hoja de Excel comienza con una l√≠nea de t√≠tulo que no pertenece al conjunto de datos. Tambi√©n que el argumento sheet permite el nombre de la hoja elegida entre comillas.\nAdem√°s de los argumentos generales de read_xl(), podemos mencionar estos otros:\n\nn_max: n√∫mero m√°ximo de filas a leer.\nrange: rango de celdas a importar (como en Excel, por ejemplo \"B3:D87\").\ncol_types: define el tipo de datos de cada columna. Valores posibles: \"numeric\", \"logical\", \"text\", \"date\", \"skip\" (no leer la columna), \"guess\" (modo predeterminado: la funci√≥n decide autom√°ticamente el tipo).\nna: car√°cter o vector de caracteres que se deben interpretar como valores perdidos (NA). Por defecto, las celdas vac√≠as se interpretan as√≠.",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a tidyverse"
    ]
  },
  {
    "objectID": "unidad_1/intro_tidyverse.html#gesti√≥n-de-datos-con-dplyr",
    "href": "unidad_1/intro_tidyverse.html#gesti√≥n-de-datos-con-dplyr",
    "title": "Introducci√≥n a tidyverse",
    "section": "Gesti√≥n de datos con dplyr\n",
    "text": "Gesti√≥n de datos con dplyr\n\n\n\n\n\nEl paquete dplyr (Wickham et¬†al. 2023) fue desarrollado por Hadley Wickham como una versi√≥n optimizada del paquete plyr (Wickham 2011).\nSu principal contribuci√≥n es ofrecer una gram√°tica para la manipulaci√≥n de datos, basada en funciones que act√∫an como verbos, lo que facilita la lectura y comprensi√≥n del c√≥digo.\nLas funciones clave del paquete permiten realizar las siguientes acciones (verbos):\n\n\nselect(): selecciona un conjunto de columnas (variables)\n\nrename(): renombra variables en un conjunto de datos\n\nfilter(): selecciona un conjunto de filas (observaciones) seg√∫n una o varias condiciones l√≥gicas\n\narrange(): reordena las filas de un conjunto de datos\n\nmutate(): a√±ade nuevas variables/columnas o transforma variables existentes\n\nsummarise()/summarize(): genera res√∫menes estad√≠sticos de diferentes variables en el conjunto de datos\n\ngroup_by(): agrupa las observaciones en funci√≥n de una o m√°s variables, lo que permite realizar operaciones por grupo\n\ncount(): contabiliza valores que se repiten, generando una tabla de frecuencias\n\nAdem√°s, al ser parte del ecosistema tidyverse, dplyr integra al operador %&gt;% (pipe) formando una √∫nica secuencia de procesamiento o pipeline.\nArgumentos comunes en las funciones dplyr\n\nTodas las funciones, b√°sicamente, tienen en com√∫n una serie de argumentos.\n\nEl primer argumento es el nombre del conjunto de datos (objeto donde esta nuestra tabla de datos).\nLos otros argumentos describen que hacer con el conjunto de datos especificado en el primer argumento, podemos referirnos a las columnas en el objeto directamente sin utilizar el operador $, es decir s√≥lo con el nombre de la columna/variable.\nEl valor de retorno es un nuevo conjunto de datos.\nLos conjuntos de datos deben estar bien organizados/estructurados, es decir debe existir una observaci√≥n por columna y, cada columna representar una variable, medida o caracter√≠stica de esa observaci√≥n. Es decir, debe cumplir con tidy data.\nActivaci√≥n del paquete\ndplyr est√° inclu√≠do en el n√∫cleo base de tidyverse, por lo que se encuentra disponible si tenemos activado a este √∫ltimo.\nTambi√©n se puede activar en forma independiente:\n\nlibrary(dplyr)\n\nConjunto de datos para ejemplo\nPara visualizar y comprender el funcionamiento de estos ‚Äúverbos‚Äù de manipulaci√≥n, resulta muy √∫til contar con ejemplos concretos. Por eso, en esta unidad trabajaremos con un conjunto de datos que nos permitir√° practicar el uso de las funciones del paquete:\n‚¨áÔ∏è Descargar datos en formato ZIP\nTambi√©n pod√©s acceder a este archivo desde el enlace disponible en la barra superior de esta p√°gina.\nUno de los archivos incluidos, ‚Äúnoti-vih.csv‚Äù, contiene registros de notificaciones de VIH por jurisdicci√≥n en Argentina correspondientes a los a√±os 2015 y 2016.\n\n# asignamos la lectura a datos\ndatos &lt;- read_csv(\"datos/noti-vih.csv\") \n\n# mostramos las 6 primeras observaciones\nhead(datos)\n\n# A tibble: 6 √ó 4\n  jurisdiccion   a√±o casos      pob\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n1 Buenos Aires  2015  1513 16626374\n2 Buenos Aires  2016   957 16789474\n3 CABA          2015   901  3054237\n4 CABA          2016   427  3050000\n5 Catamarca     2015    69   396552\n6 Catamarca     2016    51   401575\n\n\nFunci√≥n select()\n\nLa funci√≥n select() permite elegir columnas espec√≠ficas de un conjunto de datos, devolviendo una versi√≥n ‚Äúrecortada por columnas‚Äù del mismo.\nA continuaci√≥n, exploramos algunas formas √∫tiles de seleccionar variables:\nSeleccionar todas las variables excepto pob:\n\ndatos |&gt; \n  select(-pob)\n\n# A tibble: 48 √ó 3\n   jurisdiccion   a√±o casos\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;\n 1 Buenos Aires  2015  1513\n 2 Buenos Aires  2016   957\n 3 CABA          2015   901\n 4 CABA          2016   427\n 5 Catamarca     2015    69\n 6 Catamarca     2016    51\n 7 Chaco         2015    15\n 8 Chaco         2016     9\n 9 Chubut        2015   110\n10 Chubut        2016    89\n# ‚Ñπ 38 more rows\n\n\nOtra forma para el mismo resultado anterior (mediante el operador rango :):\n\ndatos |&gt; \n  select(jurisdiccion:casos)\n\n# A tibble: 48 √ó 3\n   jurisdiccion   a√±o casos\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;\n 1 Buenos Aires  2015  1513\n 2 Buenos Aires  2016   957\n 3 CABA          2015   901\n 4 CABA          2016   427\n 5 Catamarca     2015    69\n 6 Catamarca     2016    51\n 7 Chaco         2015    15\n 8 Chaco         2016     9\n 9 Chubut        2015   110\n10 Chubut        2016    89\n# ‚Ñπ 38 more rows\n\n\nSeleccionar solamente las variables jurisdiccion y casos:\n\ndatos |&gt; \n  select(jurisdiccion, casos)\n\n# A tibble: 48 √ó 2\n   jurisdiccion casos\n   &lt;chr&gt;        &lt;dbl&gt;\n 1 Buenos Aires  1513\n 2 Buenos Aires   957\n 3 CABA           901\n 4 CABA           427\n 5 Catamarca       69\n 6 Catamarca       51\n 7 Chaco           15\n 8 Chaco            9\n 9 Chubut         110\n10 Chubut          89\n# ‚Ñπ 38 more rows\n\n\nLo mismo que el ejemplo anterior, pero usando la posici√≥n de las columnas:\n\ndatos |&gt; \n  select(1, 3)\n\n# A tibble: 48 √ó 2\n   jurisdiccion casos\n   &lt;chr&gt;        &lt;dbl&gt;\n 1 Buenos Aires  1513\n 2 Buenos Aires   957\n 3 CABA           901\n 4 CABA           427\n 5 Catamarca       69\n 6 Catamarca       51\n 7 Chaco           15\n 8 Chaco            9\n 9 Chubut         110\n10 Chubut          89\n# ‚Ñπ 38 more rows\n\n\nMover la variable a√±o al inicio y mantener todas las dem√°s:\n\ndatos |&gt; \n  select(\"a√±o\", everything())\n\n# A tibble: 48 √ó 4\n     a√±o jurisdiccion casos      pob\n   &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;\n 1  2015 Buenos Aires  1513 16626374\n 2  2016 Buenos Aires   957 16789474\n 3  2015 CABA           901  3054237\n 4  2016 CABA           427  3050000\n 5  2015 Catamarca       69   396552\n 6  2016 Catamarca       51   401575\n 7  2015 Chaco           15  1153846\n 8  2016 Chaco            9  1125000\n 9  2015 Chubut         110   567010\n10  2016 Chubut          89   577922\n# ‚Ñπ 38 more rows\n\n\nOtros posibles argumentos son:\n\nstarts_with(): selecciona todas las columnas que comiencen con el patr√≥n indicado.\nends_with(): selecciona todas las columnas que terminen con el patr√≥n indicado.\ncontains(): selecciona las columnas que posean el patr√≥n indicado.\nmatches(): similar a contains(), pero permite poner una expresi√≥n regular.\nall_of(): selecciona las variables pasadas en un vector (todos los nombres deben estar presentes o devuelve un error).\nany_of(): idem anterior excepto que no se genera ning√∫n error para los nombres que no existen.\nnum_range(): selecciona variables con nombre combinados con caracteres y n√∫meros (ejemplo: num_range(\"x\", 1:3) selecciona las variables x1, x2 y x3.\nwhere(): aplica una funci√≥n a todas las variables y selecciona aquellas para las cuales la funci√≥n regresa TRUE (por ejemplo: is.numeric() para seleccionar todas las variables num√©ricas).\nFunci√≥n rename()\n\nLa funci√≥n rename() puede considerarse una extensi√≥n de select(). Si bien select() tambi√©n permite renombrar variables, no resulta muy √∫til para este fin, ya que descarta todas las variables que no se mencionan expl√≠citamente.\nEn cambio, rename() permite cambiar el nombre de una o m√°s variables sin eliminar las dem√°s. Solo se modifican los nombres indicados, y el resto del conjunto de datos permanece sin cambios.\nEjemplo: renombrar la variable pob como poblaci√≥n:\n\ndatos |&gt;\n  rename(\"poblaci√≥n\" = pob)\n\n# A tibble: 48 √ó 4\n   jurisdiccion   a√±o casos poblaci√≥n\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;\n 1 Buenos Aires  2015  1513  16626374\n 2 Buenos Aires  2016   957  16789474\n 3 CABA          2015   901   3054237\n 4 CABA          2016   427   3050000\n 5 Catamarca     2015    69    396552\n 6 Catamarca     2016    51    401575\n 7 Chaco         2015    15   1153846\n 8 Chaco         2016     9   1125000\n 9 Chubut        2015   110    567010\n10 Chubut        2016    89    577922\n# ‚Ñπ 38 more rows\n\n\nFunci√≥n filter()\n\nLa funci√≥n filter() permite seleccionar filas de un conjunto de datos, produciendo un subconjunto de observaciones.\nVeamos un ejemplo sencillo con nuestros datos:\n\ndatos |&gt;\n  filter(jurisdiccion == \"Tucuman\")\n\n# A tibble: 2 √ó 4\n  jurisdiccion   a√±o casos     pob\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n1 Tucuman       2015   258 1592593\n2 Tucuman       2016   246 1618421\n\n\nUtiliza los mismos operadores de comparaci√≥n propios del lenguaje R:\n\n\n\n\nOperador\nDescripci√≥n\n\n\n\n&lt;\nMenor que\n\n\n&gt;\nMenor que\n\n\n&lt;=\nMenor o igual que\n\n\n&gt;=\nMayor o igual que\n\n\n==\nIgual que\n\n\n!=\nNo igual que\n\n\n%in%\nEs parte de\n\n\nis.na()\nEs un valor ausente\n\n\n!is.na()\nNo es un valor ausente\n\n\n\n\n\nLo mismo con los operadores l√≥gicos que se utilizan como conectores entre las expresiones:\n\n\n\n\nOperador\nDescripci√≥n\n\n\n\n&\nAND booleano\n\n\n|\nOR booleano\n\n\nxor()\nOR exclusivo\n\n\n!\nNOT\n\n\nany()\ncualquier TRUE\n\n\nall()\ntodos TRUE\n\n\n\n\n\nCuando usamos m√∫ltiples argumentos separados por coma dentro de filter(), estas se combinan con un operador AND impl√≠cito, es decir, cada expresi√≥n debe ser verdadera para que la fila sea incluida en la salida.\nPor ejemplo, filtramos las observaciones que cumplan que casos sea mayor a 100 y que pob sea menor a 1.000.000:\n\ndatos |&gt;\n  filter(casos &gt; 100, pob &lt; 1000000)\n\n# A tibble: 7 √ó 4\n  jurisdiccion   a√±o casos    pob\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1 Chubut        2015   110 567010\n2 Jujuy         2015   160 727273\n3 Jujuy         2016   133 734807\n4 Neuquen       2015   109 619318\n5 Neuquen       2016   101 627329\n6 Rio Negro     2015   112 700000\n7 Rio Negro     2016   105 709459\n\n\nPara combinar condiciones dentro de una misma variable usamos el operador OR (|) o, de forma m√°s pr√°ctica, %in%:\n\n# Con OR\ndatos |&gt;\n  filter(jurisdiccion == \"Buenos Aires\" | jurisdiccion == \"La Pampa\")\n\n# A tibble: 4 √ó 4\n  jurisdiccion   a√±o casos      pob\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n1 Buenos Aires  2015  1513 16626374\n2 Buenos Aires  2016   957 16789474\n3 La Pampa      2015    57   343373\n4 La Pampa      2016    67   345361\n\n# Con %in%\ndatos |&gt;\n  filter(jurisdiccion %in% c(\"Buenos Aires\", \"La Pampa\"))\n\n# A tibble: 4 √ó 4\n  jurisdiccion   a√±o casos      pob\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n1 Buenos Aires  2015  1513 16626374\n2 Buenos Aires  2016   957 16789474\n3 La Pampa      2015    57   343373\n4 La Pampa      2016    67   345361\n\n\nEn el siguiente ejemplo, filtramos observaciones del a√±o 2016 con m√°s de 200 casos. El uso de & es equivalente al uso de coma:\n\ndatos |&gt;\n  filter(a√±o == \"2016\" & casos &gt; 200)\n\n# A tibble: 6 √ó 4\n  jurisdiccion   a√±o casos      pob\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n1 Buenos Aires  2016   957 16789474\n2 CABA          2016   427  3050000\n3 Cordoba       2016   368  3607843\n4 Mendoza       2016   254  1909774\n5 Salta         2016   230  1352941\n6 Tucuman       2016   246  1618421\n\n\nPor √∫ltimo, podemos usar xor() para seleccionar observaciones que cumplan solo una de las condiciones, pero no ambas. Por ejemplo, el siguiente filtro selecciona registros donde el a√±o sea 2016 √≥ los casos sean mayores a 200, pero no ambos al mismo tiempo (es decir que no se den ambos en TRUE):\n\ndatos |&gt; \n  filter(xor(a√±o == \"2016\", casos &gt; 200))\n\n# A tibble: 25 √ó 4\n   jurisdiccion   a√±o casos      pob\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n 1 Buenos Aires  2015  1513 16626374\n 2 CABA          2015   901  3054237\n 3 Catamarca     2016    51   401575\n 4 Chaco         2016     9  1125000\n 5 Chubut        2016    89   577922\n 6 Cordoba       2015   468  3572519\n 7 Corrientes    2016    99  1076087\n 8 Entre Rios    2016   109  1329268\n 9 Formosa       2016    60   582524\n10 Jujuy         2016   133   734807\n# ‚Ñπ 15 more rows\n\n\nFunci√≥n arrange()\n\nLa funci√≥n arrange() se utiliza para ordenar las filas de un conjunto de datos de acuerdo a una o varias columnas/variables. Por defecto, el ordenamiento es ascendente alfanum√©rico.\nOrdenamos la tabla por la variable pob (forma ascendente predeterminada):\n\ndatos |&gt;\n  arrange(pob)\n\n# A tibble: 48 √ó 4\n   jurisdiccion       a√±o casos    pob\n   &lt;chr&gt;            &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n 1 Tierra del Fuego  2015    36 152542\n 2 Tierra del Fuego  2016    34 156682\n 3 Santa Cruz        2015    65 320197\n 4 Santa Cruz        2016    59 329609\n 5 La Pampa          2015    57 343373\n 6 La Pampa          2016    67 345361\n 7 La Rioja          2015    41 369369\n 8 La Rioja          2016     6 375000\n 9 Catamarca         2015    69 396552\n10 Catamarca         2016    51 401575\n# ‚Ñπ 38 more rows\n\n\nPara ordenar en forma descendente podemos utilizar desc() dentro de los argumentos de arrange():\n\ndatos |&gt;\n  arrange(desc(pob))\n\n# A tibble: 48 √ó 4\n   jurisdiccion   a√±o casos      pob\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n 1 Buenos Aires  2016   957 16789474\n 2 Buenos Aires  2015  1513 16626374\n 3 Cordoba       2016   368  3607843\n 4 Cordoba       2015   468  3572519\n 5 Santa Fe      2016   170  3400000\n 6 Santa Fe      2015   301  3382022\n 7 CABA          2015   901  3054237\n 8 CABA          2016   427  3050000\n 9 Mendoza       2016   254  1909774\n10 Mendoza       2015   316  1880952\n# ‚Ñπ 38 more rows\n\n\nPodemos combinar ordenamientos. Por ejemplo, en forma alfab√©tica ascendente para jusrisdiccion y luego num√©rica descendente para casos:\n\ndatos |&gt;\n  arrange(jurisdiccion, desc(casos))\n\n# A tibble: 48 √ó 4\n   jurisdiccion   a√±o casos      pob\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n 1 Buenos Aires  2015  1513 16626374\n 2 Buenos Aires  2016   957 16789474\n 3 CABA          2015   901  3054237\n 4 CABA          2016   427  3050000\n 5 Catamarca     2015    69   396552\n 6 Catamarca     2016    51   401575\n 7 Chaco         2015    15  1153846\n 8 Chaco         2016     9  1125000\n 9 Chubut        2015   110   567010\n10 Chubut        2016    89   577922\n# ‚Ñπ 38 more rows\n\n\nFunci√≥n mutate()\n\nEsta funci√≥n nos permite transformar variables dentro de un conjunto de datos. A menudo tendremos la necesidad de modificar variables existentes o crear nuevas variables a partir de las ya disponibles. La funci√≥n mutate() nos ofrece una forma clara y eficiente de realizar este tipo de operaciones.\nPor ejemplo, podr√≠amos querer calcular tasas crudas para cada jurisdicci√≥n y a√±o, en funci√≥n del n√∫mero de casos y de la poblaci√≥n total:\n\ndatos |&gt;\n  mutate(\n    tasa = casos/pob*100000\n  )\n\n# A tibble: 48 √ó 5\n   jurisdiccion   a√±o casos      pob  tasa\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1 Buenos Aires  2015  1513 16626374  9.10\n 2 Buenos Aires  2016   957 16789474  5.70\n 3 CABA          2015   901  3054237 29.5 \n 4 CABA          2016   427  3050000 14   \n 5 Catamarca     2015    69   396552 17.4 \n 6 Catamarca     2016    51   401575 12.7 \n 7 Chaco         2015    15  1153846  1.30\n 8 Chaco         2016     9  1125000  0.8 \n 9 Chubut        2015   110   567010 19.4 \n10 Chubut        2016    89   577922 15.4 \n# ‚Ñπ 38 more rows\n\n\nEn este caso, mutate() calcula la tasa cruda por 100.000 habitantes e incorpora una nueva variable (tasa) con los resultados correspondientes a cada observaci√≥n.\nTambi√©n se pueden construir m√∫ltiples variables en la misma expresi√≥n, solamente separadas por comas:\n\ndatos |&gt;\n  mutate(\n    tasaxcien_mil = casos/pob*100000,\n    tasaxdiez_mil = casos/pob*10000\n  )\n\n# A tibble: 48 √ó 6\n   jurisdiccion   a√±o casos      pob tasaxcien_mil tasaxdiez_mil\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n 1 Buenos Aires  2015  1513 16626374          9.10         0.910\n 2 Buenos Aires  2016   957 16789474          5.70         0.570\n 3 CABA          2015   901  3054237         29.5          2.95 \n 4 CABA          2016   427  3050000         14            1.4  \n 5 Catamarca     2015    69   396552         17.4          1.74 \n 6 Catamarca     2016    51   401575         12.7          1.27 \n 7 Chaco         2015    15  1153846          1.30         0.130\n 8 Chaco         2016     9  1125000          0.8          0.08 \n 9 Chubut        2015   110   567010         19.4          1.94 \n10 Chubut        2016    89   577922         15.4          1.54 \n# ‚Ñπ 38 more rows\n\n\nSi deseamos que estas nuevas variables se incorporen de forma permanente al conjunto de datos (y no solo se muestren en la consola), debemos utilizar el operador de asignaci√≥n &lt;-:\n\ndatos &lt;- datos |&gt;\n  mutate(\n    tasaxcien_mil = casos/pob*100000,\n    tasaxdiez_mil = casos/pob*10000\n  )\n\nUn aspecto fundamental es que las funciones utilizadas dentro de mutate() deben estar vectorizadas: deben aceptar un vector de entrada y devolver otro vector del mismo tama√±o como salida.\nExisten muchas funciones que se pueden utilizar dentro de mutate(). A continuaci√≥n se presentan algunas √∫tiles:\n\nOperadores aritm√©ticos: +, -, *, /, ^.\nAritm√©tica modular: %/% (divisi√≥n entera) y %% (resto), donde x == y * (x %/% y) + (x %% y). Esta herramienta resulta √∫til para dividir n√∫meros enteros en porciones.\nFunciones matem√°ticas: log(), log2(), log10(), exp(), sqrt(), abs(), entre otras.\nValores acumulados: R ofrece funciones como cumsum(), cumprod(), cummin(), cummax() y dplyr incluye cummean() para promedios acumulados.\nClasificaci√≥n o ranking: funciones como min_rank() permiten asignar rangos (1¬∫, 2¬∫, etc.). Por defecto, los valores m√°s peque√±os reciben rangos m√°s bajos. Si se desea invertir el orden, puede utilizarse desc(x).\n\nFinalmente, si se utiliza en mutate() el mismo nombre de una variable que ya existe en la tabla, dicha variable ser√° sobrescrita (por ejemplo, al cambiarle el tipo de character a factor). Si se desea crear una variable nueva, se debe utilizar un nombre que no est√© previamente en el conjunto de datos.\nFunci√≥n summarise()\n\nLa funci√≥n summarise() o summarize() se utiliza para calcular res√∫menes estad√≠sticos a partir de una o m√°s variables de un conjunto de datos.\nPor ejemplo, podemos calcular el promedio y el total de casos:\n\ndatos |&gt;\n  summarise(\n    promedio_casos = mean(casos), \n    casos_totales = sum(casos)\n  )\n\n# A tibble: 1 √ó 2\n  promedio_casos casos_totales\n           &lt;dbl&gt;         &lt;dbl&gt;\n1           192.          9211\n\n\nSu uso es muy interesante cuando la combinamos con group_by() (funci√≥n que detallaremos luego). Esta situaci√≥n permite estratificar los resultados por grupos espec√≠ficos.\nPor ejemplo, podemos agrupar el por a√±o y simult√°neamente aplicar el mismo summarise() anterior:\n\ndatos |&gt; \n  group_by(a√±o) |&gt; \n  summarise(\n    promedio_casos = mean(casos), \n    casos_totales = sum(casos)\n  )\n\n# A tibble: 2 √ó 3\n    a√±o promedio_casos casos_totales\n  &lt;dbl&gt;          &lt;dbl&gt;         &lt;dbl&gt;\n1  2015           224.          5369\n2  2016           160.          3842\n\n\nEl resultado es una tabla con dos filas, una para cada grupo (a√±o 2015 y a√±o 2016) con los valores promedio y casos totales respectivos.\nAlgunas de las funciones del R base que se pueden utilizar dentro de los argumentos de esta funci√≥n son:\n\n\nmin(): m√≠nimo\n\nmax(): m√°ximo\n\nmean(): media\n\nmedian(): mediana\n\nvar(): varianza\n\nsd(): desv√≠o\n\nsum(): sumatoria\n\nOtras funciones que se pueden incorporar las provee el mismo paquete dplyr, por ejemplo:\n\n\nfirst(): primer valor en el vector.\n\nlast(): √∫ltimo valor en el vector.\n\nn(): n√∫mero de valores en el vector.\n\nn_distinct(): n√∫meros de valores distintos en el vector.\nFunci√≥n group_by()\n\nComo mencionamos anteriormente, la funci√≥n group_by() resulta especialmente √∫til cuando se utiliza en combinaci√≥n con summarise(), dado que agrupa un conjunto de filas seleccionado seg√∫n los valores de una o m√°s columnas antes de aplicar funciones de resumen.\nAl aplicar group_by(), el conjunto de datos se estructura internamente en subgrupos definidos por las variables indicadas. Las funciones que se apliquen a continuaci√≥n (por ejemplo, summarise() o mutate()) se ejecutar√°n dentro de cada grupo de forma independiente.\nPor ejemplo, podemos calcular las tasas crudas por 100.000 habitantes para cada combinaci√≥n de jurisdicci√≥n y a√±o:\n\ndatos |&gt;\n  group_by(jurisdiccion, a√±o) |&gt; \n  summarise(tasa = casos/pob*100000)\n\n# A tibble: 48 √ó 3\n# Groups:   jurisdiccion [24]\n   jurisdiccion   a√±o  tasa\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;\n 1 Buenos Aires  2015  9.10\n 2 Buenos Aires  2016  5.70\n 3 CABA          2015 29.5 \n 4 CABA          2016 14   \n 5 Catamarca     2015 17.4 \n 6 Catamarca     2016 12.7 \n 7 Chaco         2015  1.30\n 8 Chaco         2016  0.8 \n 9 Chubut        2015 19.4 \n10 Chubut        2016 15.4 \n# ‚Ñπ 38 more rows\n\n\nEn la mayor√≠a de estos ejemplos, la salida es directa, es decir, no construimos nuevos objetos. Sin embargo, en muchas situaciones vamos a necesitar conservar los resultados obtenidos, asign√°ndolos a un nuevo objeto.\nAdem√°s, si en alg√∫n momento aplicamos group_by() y luego queremos continuar trabajando con los datos sin agrupamientos, podemos utilizar la funci√≥n ungroup(), que elimina la estructura de agrupamiento:\n\ndatos |&gt; \n  group_by(jurisdiccion, a√±o) |&gt; \n  summarise(tasa = casos / pob * 100000) |&gt; \n  ungroup()\n\n# A tibble: 48 √ó 3\n   jurisdiccion   a√±o  tasa\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;\n 1 Buenos Aires  2015  9.10\n 2 Buenos Aires  2016  5.70\n 3 CABA          2015 29.5 \n 4 CABA          2016 14   \n 5 Catamarca     2015 17.4 \n 6 Catamarca     2016 12.7 \n 7 Chaco         2015  1.30\n 8 Chaco         2016  0.8 \n 9 Chubut        2015 19.4 \n10 Chubut        2016 15.4 \n# ‚Ñπ 38 more rows\n\n\nEsto resulta √∫til cuando queremos realizar otras operaciones posteriores que no dependen de los grupos definidos previamente.\nCombinaciones\nEn los ejemplos anteriores vimos c√≥mo se van integrando algunas de las funciones mediante el uso del operador de tuber√≠a %&gt;% o |&gt;. La idea detr√°s de esta ‚Äúgram√°tica de los datos‚Äù que propone el paquete dplyr es poder encadenar acciones de forma legible y l√≥gica, construyendo oraciones m√°s complejas paso a paso.\nVeamos un ejemplo que integra muchas de las funciones vistas hasta ahora:\n\nObtener una nueva tabla con las tasas crudas de casos notificados de VIH, por a√±o y jurisdicci√≥n, mayores a 20 por 100.000 habitantes, ordenadas de mayor a menor.\n\n\ndatos |&gt;                                  # siempre partimos de los datos\n  group_by(a√±o, jurisdiccion) |&gt;          # agrupamos\n  summarise(tasa = casos/pob*100000) |&gt;   # resumimos\n  filter(tasa &gt; 20) |&gt;                    # filtramos\n  arrange(desc(tasa))                     # ordenamos   \n\n# A tibble: 5 √ó 3\n# Groups:   a√±o [2]\n    a√±o jurisdiccion      tasa\n  &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt;\n1  2015 CABA              29.5\n2  2015 Tierra del Fuego  23.6\n3  2015 Jujuy             22.0\n4  2016 Tierra del Fuego  21.7\n5  2015 Santa Cruz        20.3\n\n\nUna buena pr√°ctica para construir este tipo de c√≥digo es escribir cada paso de la operaci√≥n en una l√≠nea separada. Esto no solo mejora la legibilidad, sino que facilita la identificaci√≥n de errores o la modificaci√≥n de pasos espec√≠ficos.\nEste ejemplo muestra claramente el poder y la claridad que se logran al combinar funciones como group_by(), summarise(), filter() y arrange() en una misma operaci√≥n fluida y coherente.\nFunci√≥n count()\n\nEsta funci√≥n permite contar r√°pidamente los valores √∫nicos de una o m√°s variables en un conjunto de datos. Es especialmente √∫til para crear tablas de frecuencias absolutas, que posteriormente pueden ser usadas para calcular frecuencias relativas.\nUn ejemplo b√°sico de su uso es contar las observaciones por cada valor √∫nico de la variable jurisdiccion en el conjunto de datos:\n\ndatos |&gt;\n  count(jurisdiccion)\n\n# A tibble: 24 √ó 2\n   jurisdiccion     n\n   &lt;chr&gt;        &lt;int&gt;\n 1 Buenos Aires     2\n 2 CABA             2\n 3 Catamarca        2\n 4 Chaco            2\n 5 Chubut           2\n 6 Cordoba          2\n 7 Corrientes       2\n 8 Entre Rios       2\n 9 Formosa          2\n10 Jujuy            2\n# ‚Ñπ 14 more rows\n\n\nTiene un par de argumentos opcionales:\n\nname: Define el nombre de la columna que contendr√° el conteo. Por defecto, esta columna se llama n.\nsort: Ordena la tabla de frecuencias de mayor a menor (por defecto, no realiza ninguna ordenaci√≥n).\nwt: Permite incorporar una variable que funcione como ponderaci√≥n (o factor de expansi√≥n) para el c√°lculo de la frecuencia.",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a tidyverse"
    ]
  },
  {
    "objectID": "unidad_1/intro_tidyverse.html#gr√°ficos-estad√≠sticos-con-ggplot2",
    "href": "unidad_1/intro_tidyverse.html#gr√°ficos-estad√≠sticos-con-ggplot2",
    "title": "Introducci√≥n a tidyverse",
    "section": "Gr√°ficos estad√≠sticos con ggplot2\n",
    "text": "Gr√°ficos estad√≠sticos con ggplot2\n\n\n\n\n\nEl paquete ggplot2 (Wickham 2016) se autodefine como una librer√≠a para ‚Äúcrear elegantes visualizaciones de datos utilizando una gram√°tica de gr√°ficos‚Äù. Proporciona una forma intuitiva de construir gr√°ficos basada en The Grammar of Graphics a trav√©s de un sistema basado en tres componentes b√°sicos:\n\ndatos\ncoordenadas\nobjetos geom√©tricos\n\nLa estructura para construir un gr√°fico es la siguiente:\n\n\n\n\nAnatom√≠a de gr√°ficos con ggplot2\n\nLa estructura b√°sica para construir un gr√°fico con ggplot2 se organiza a partir de una gram√°tica de gr√°ficos, que se puede entender a trav√©s de sus componentes fundamentales:\n\n\n\n\n\n\ndata: el conjunto de datos que vamos a graficar, que debe contener toda la informaci√≥n necesaria para crear el gr√°fico.\n\naes(): el mapeo est√©tico (aesthetic mapping) es donde se declaran las variables que se van a mapear en el gr√°fico (por ejemplo, qu√© variable va en el eje X, en el eje Y, o c√≥mo se asignan los colores).\n\ngeoms: representaciones gr√°ficas de los datos, como puntos, l√≠neas, barras, cajas, entre otros. Son los ‚Äúobjetos geom√©tricos‚Äù que realmente dibujan el gr√°fico.\n\nstats: Transformaciones estad√≠sticas que se realizan sobre los datos, como el c√°lculo de medias, medias m√≥viles o regresiones, que ayudan a hacer un resumen de los datos para visualizarlos mejor.\n\nscales: se utilizan para colorear o escalar los datos seg√∫n distintas variables. Controlan los ejes y las leyendas.\n\ncoordinate systems: es el sistema de coordenadas para el mapeo del gr√°fico en un plano bidimensional.\n\nfacets: permiten dividir el conjunto de datos seg√∫n factores y crear gr√°ficos en paneles separados (vi√±etas), creando matrices gr√°ficas.\n\ntheme: son conjuntos de caracter√≠sticas gr√°ficas que permiten controlar la apariencia general de todos los elementos que no son datos, como el color del fondo, el tipo de fuente o los bordes.\n\nAntes de comenzar a mostrar c√≥mo se usan estos componentes en un gr√°fico, leemos la base de datos de ejemplo ‚Äúfacultad.csv‚Äù, que contiene datos ficticios sobre ingresantes a una facultad (por ejemplo, sexo, edad, talla y peso). Usaremos este conjunto de datos para ilustrar los ejemplos gr√°ficos:\n\n# Cargar datos\nfacultad &lt;- read_csv(\"datos/facultad.csv\")\n\n# Mostramos las 6 primeras observaciones\nhead(facultad) \n\n# A tibble: 6 √ó 18\n     hc sexo   edad ant_diabetes ant_tbc ant_cancer ant_obesidad ant_ecv ant_ht\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;        &lt;chr&gt;   &lt;chr&gt; \n1 26880 M        17 NO           NO      NO         SI           NO      SI    \n2 26775 M        18 SI           NO      NO         NO           NO      NO    \n3 26877 M        18 SI           NO      SI         NO           NO      SI    \n4 26776 M        18 NO           NO      NO         SI           SI      NO    \n5 26718 M        18 NO           NO      NO         NO           NO      SI    \n6 26738 M        18 NO           NO      NO         NO           NO      SI    \n# ‚Ñπ 9 more variables: ant_col &lt;chr&gt;, fuma &lt;chr&gt;, edadini &lt;dbl&gt;, cantidad &lt;dbl&gt;,\n#   col &lt;dbl&gt;, peso &lt;dbl&gt;, talla &lt;dbl&gt;, sist &lt;dbl&gt;, diast &lt;dbl&gt;\n\n\nMapeo est√©tico con aes() y capas geom√©tricas (geom_)\nDec√≠amos que la funci√≥n aes() hace referencia al contenido est√©tico del gr√°fico. Es decir, le brinda indicaciones a ggplot2 sobre c√≥mo dibujar los distintos elementos del gr√°fico: l√≠neas, formas, colores y tama√±os.\nEs importante notar que aes() crea una nueva capa vinculada a las variables que se desean mapear, y tambi√©n agrega autom√°ticamente leyendas cuando corresponde. Al incorporar aes() dentro del llamado a ggplot(), estamos compartiendo la informaci√≥n est√©tica con todas las capas del gr√°fico. Si deseamos que esa informaci√≥n s√≥lo est√© en una de las capas, debemos usar aes() en la capa correspondiente.\nVeamos c√≥mo funciona y cu√°les son sus implicancias:\n\nfacultad |&gt;\n  # solo la capa est√©tica aes()\n  ggplot(aes(x = talla, y = peso)) \n\n\n\n\n\n\n\nEste c√≥digo genera un gr√°fico vac√≠o que contiene √∫nicamente los ejes especificados (peso y talla), pero a√∫n no muestra los datos. Para visualizar los puntos, debemos agregar una capa geom√©trica usando geom_point() y enlazarla con el s√≠mbolo +:\n\nfacultad |&gt;\n  # mapeo est√©tico\n  ggplot(aes(x = talla, y = peso))  + \n  \n  # agregamos la capa geom√©trica de puntos\n  geom_point()                    \n\n\n\n\n\n\n\nPodemos diferenciar los puntos seg√∫n sexo incorporando la variable sexo como argumento del color dentro de aes():\n\nfacultad |&gt;\n  # mapeo est√©tico\n  ggplot(aes(x = talla, y = peso, color = sexo))  + \n  \n  # agregamos la capa geom√©trica de puntos\n  geom_point()  \n\n\n\n\n\n\n\nTambi√©n es posible superponer otras capas geom√©tricas. Por ejemplo, podemos agregar rectas de regresi√≥n para cada grupo seg√∫n sexo:\n\nfacultad |&gt;\n  # mapeo est√©tico\n  ggplot(aes(x = talla, y = peso, color = sexo))  + \n  \n  # agregamos la capa geom√©trica de puntos\n  geom_point()  +\n  \n  # agregamos una segunda capa geom√©trica para la recta de regresi√≥n\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\nLa funci√≥n geom_smooth() permite aplicar distintos m√©todos de suavizado o ajuste. En este caso usamos \"lm\" para mostrar la recta de regresi√≥n lineal entre talla y peso, junto con sus intervalos de confianza.\nA continuaci√≥n, veremos las diferencias entre incluir aes() en ggplot() (aplicando el mapeo a todo el gr√°fico) o colocarlo solo dentro de alguna capa geom√©trica espec√≠fica:\n\nfacultad |&gt;\n  # mapeo est√©tico\n  ggplot(aes(x = talla, y = peso))  + \n  \n  # agregamos la capa geom√©trica de puntos coloreada por sexo\n  geom_point(aes(color = sexo))  +\n  \n  # agregamos una segunda capa geom√©trica para la recta de regresi√≥n\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\nEn este ejemplo, el color solo se especifica dentro de geom_point(), por lo que los puntos se dibujan diferenciados por sexo, pero no afecta a la capa de geom_smooth() produciendo solo una l√≠nea de regresi√≥n para el conjunto de puntos.\nEste comportamiento brinda gran flexibilidad en la construcci√≥n de gr√°ficos, permitiendo definir qu√© capas deben responder a qu√© mapeos est√©ticos.\nAlgunas otras funciones de geom_ son:\n\ngeom_line(): gr√°fico de l√≠neas.\ngeom_boxplot(): gr√°fico de caja y bigotes (boxplot).\ngeom_histogram(): histograma.\ngeom_density(): curva de densidad.\ngeom_bar(): gr√°fico de barras.\n\nTodas estas funciones pueden aplicarse sobre los mismos datos, y su uso depende del objetivo del an√°lisis.\nA continuaci√≥n, algunos ejemplos para visualizar la relaci√≥n entre sexo y talla utilizando distintas capas geom√©tricas:\n\n# Gr√°fico de puntos\nfacultad |&gt;\n  ggplot(aes(x = sexo, y = talla, color = sexo)) + \n  # capa geom√©trica de puntos\n  geom_point()\n\n\n\n\n\n\n# Boxplot\nfacultad |&gt;\n  ggplot(aes(x = sexo, y = talla, color = sexo)) + \n  # capa geom√©trica de boxplot\n  geom_boxplot()            \n\n\n\n\n\n\n# Entramado de puntos\nfacultad |&gt;\n  ggplot(aes(x = sexo, y = talla, color = sexo)) + \n  # capa geom√©trica jitter (entramado de puntos)\n  geom_jitter() \n\n\n\n\n\n\n# Gr√°fico de viol√≠n\nfacultad |&gt;\n  ggplot(aes(x = sexo, y = talla, color = sexo)) + \n  # capa geom√©trica de violin\n  geom_violin()\n\n\n\n\n\n\n\nObservemos que en el √∫ltimo gr√°fico se us√≥ el argumento fill en lugar de color. Mientras color define el contorno de l√≠neas, curvas o puntos, fill define el relleno de objetos geom√©tricos, como los pol√≠gonos en gr√°ficos de viol√≠n o barras.\nPersonalizaci√≥n de escalas con scale_\n\nEl sistema de escalas en ggplot2 permite ajustar m√∫ltiples aspectos visuales de un gr√°fico. Podemos modificar colores de contorno y relleno, invertir ejes, cambiar tama√±os, tipos de l√≠nea, entre muchas otras opciones.\nTodas las funciones relacionadas con escalas comienzan con el prefijo scale_, seguido del atributo que queremos modificar (por ejemplo, scale_fill_ para cambiar el color de relleno).\nA continuaci√≥n, mostramos algunos ejemplos aplicados sobre el conjunto de datos facultad:\n\nfacultad |&gt;\n  ggplot(aes(x = sexo, y = talla, fill = sexo)) + \n  \n  # capa geom√©trica boxplot\n  geom_boxplot() +\n  \n  # paleta de naranjas\n  scale_fill_brewer(palette = \"Oranges\")\n\n\n\n\n\n\n\nEn este ejemplo aplicamos una capa scale_fill_brewer() con la paleta de colores \"Oranges\" que se vincula con el argumento fill de aes() y definen los colores del boxplot.\nOtra alternativa es aplicar una escala de grises mediante scale_fill_grey():\n\nfacultad |&gt;\n  ggplot(aes(x = sexo, y = talla, fill = sexo)) + \n  \n  # capa geom√©trica boxplot\n  geom_boxplot() +\n  \n  # paleta en escala de grises\n  scale_fill_grey(start = 0.4, end = 0.8)\n\n\n\n\n\n\n\n\nRecomendamos trabajar con paletas de colores accesibles para personas con daltonismo y otras discapacidades visuales, como las incluidas en las dependencias RColorBrewer(Neuwirth 2022) y viridisLite, as√≠ como en paquetes espec√≠ficos con paletas colorblind-friendly, como scico (Pedersen y Crameri 2023).\n\nTambi√©n podemos modificar las escalas de los ejes. Por ejemplo, invertir el eje X con scale_x_reverse():\n\nfacultad |&gt;\n  ggplot(aes(x = talla, y = peso, fill = sexo)) + \n  \n  # capa geom√©trica de puntos\n  geom_point() +\n  \n  # invierte el eje x\n  scale_x_reverse()\n\n\n\n\n\n\n\nLa inclusi√≥n de scale_x_reverse() provoca la variable talla se muestre en orden descendente, de mayor a menor.\nPor √∫ltimo, podemos personalizar los cortes del eje Y utilizando scale_y_continuous(). Por ejemplo, en el boxplot pintado en escala de grises, definimos que el eje Y comienza en 130cm y termina en 200cm, con cortes cada 5cm y etiquetas cada 10cm:\n\nfacultad |&gt;\n  ggplot(aes(x = sexo, y = talla, fill = sexo)) + \n  \n  # capa geom√©trica boxplot\n  geom_boxplot() +\n  \n  # paleta en escala de grises\n  scale_fill_grey(start = 0.4, end = 0.8)   +\n  \n  # puntos de corte del eje Y\n  scale_y_continuous(limits = c(130, 200),       # l√≠mites\n                     breaks = seq(130, 200, 10)) # nro de etiquetas\n\n\n\n\n\n\n\nTransformaciones estad√≠sticas con stat_\n\nAlgunos gr√°ficos en ggplot2 no requieren transformaciones estad√≠sticas, como los gr√°ficos de dispersi√≥n. Sin embargo, otros tipos ‚Äîcomo boxplots, histogramas o l√≠neas de tendencia‚Äî s√≠ aplican transformaciones estad√≠sticas predeterminadas que pueden ser modificadas o personalizadas.\nEstas transformaciones pueden formar parte de las funciones geom√©tricas, como ocurre en los histogramas, o agregarse como capas independientes mediante funciones stat_.\nPor ejemplo, en los histogramas podemos definir la cantidad de intervalos (o ‚Äúclases‚Äù) a trav√©s del argumento bins, que forma parte de geom_histogram():\n\nfacultad |&gt;\n  ggplot(aes(edad)) +\n  \n  # capa geom√©trica histograma\n  geom_histogram(bins = nclass.Sturges(facultad$edad), \n                 fill = \"Blue\")\n\n\n\n\n\n\n\nEn este caso, utilizamos la regla de Sturges ‚Äîa trav√©s de la funci√≥n nclass.Sturges()‚Äî para determinar autom√°ticamente la cantidad de clases para la variable edad.\nTambi√©n podemos superponer al gr√°fico transformaciones estad√≠sticas como capas adicionales. Por ejemplo, si deseamos agregar la media de talla en cada grupo de sexo sobre un boxplot, utilizamos stat_summary():\n\nfacultad |&gt;\n  ggplot(aes(x = sexo, y = talla, fill = sexo)) + \n  \n  # capa geom√©trica boxplot\n  geom_boxplot() +\n  \n  # paleta de tonos verdes\n  scale_fill_brewer(palette = \"Greens\") +\n  \n  # a√±ade capa summary\n  stat_summary(fun = mean, \n               color = \"darkred\", \n               geom = \"point\", \n               shape = 18, \n               size = 3)\n\n\n\n\n\n\n\nLa funci√≥n stat_summary() permite aplicar funciones estad√≠sticas como mean, median, sd, entre otras, y representar el resultado con un objeto geom√©trico, en este caso geom = \"point\". En el gr√°fico, la media de talla se muestra con un punto rojo oscuro (color = \"darkred\"), de forma romboidal (shape = 18) y tama√±o ampliado (size = 3).\nFacetado con facet_\n\nEl facetado permite dividir un gr√°fico en m√∫ltiples paneles o vi√±etas seg√∫n los niveles de una o m√°s variables categ√≥ricas. Esto resulta especialmente √∫til cuando se desea comparar patrones entre grupos sin sobrecargar un √∫nico gr√°fico con demasiada informaci√≥n.\nggplot2 ofrece dos funciones principales para realizar esta tarea:\n\nfacet_wrap(): separa los datos seg√∫n una √∫nica variable categ√≥rica, generando una serie de paneles dispuestos de forma autom√°tica en filas y columnas.\nfacet_grid(): permite crear una matriz de paneles cruzando dos variables categ√≥ricas, una para las filas y otra para las columnas.\n\nRetomemos el gr√°fico de dispersi√≥n entre talla y peso, y generemos paneles separados para cada nivel de la variable sexo con facet_wrap():\n\nfacultad |&gt;\n  \n  ggplot(aes(x = talla, y = peso, color = sexo)) +\n  \n  # capa geom√©trica de puntos\n  geom_point() +\n  \n  # separa en paneles por sexo\n  facet_wrap(~ sexo)\n\n\n\n\n\n\n\nUsaremos facet_grid() para crear una matriz de histogramas producto del cruce de las variables fuma y sexo. Dentro de la cuadr√≠cula graficaremos histogramas de la variable peso coloreados por sexo:\n\nfacultad |&gt;\n  ggplot(aes(y = peso, fill = sexo)) +\n  \n  # capa geom√©trica histograma\n  geom_histogram(bins = nclass.Sturges(facultad$peso)) +\n  \n  # paleta de colores\n  scale_fill_brewer(palette = \"Set1\") +\n  \n  # separa en paneles por sexo y fuma\n  facet_grid(sexo ~ fuma)\n\n\n\n\n\n\n\nComo se puede ver en estos ejemplos, estamos integrando varias de las funciones vistas: mapeo est√©tico, capas geom√©tricas, escalas, y ahora tambi√©n el facetado.\nEl n√∫mero de combinaciones posibles es enorme, dada la variedad de funciones y argumentos que ofrece ggplot2. Sin embargo, el objetivo de este material es comprender los principios fundamentales sobre los que se construye esta ‚Äúgram√°tica de los gr√°ficos‚Äù, propuesta por los autores del paquete.\nSistema de coordenadas con coord_\n\nEn algunas ocasiones, puede ser √∫til modificar el sistema de coordenadas predeterminado del gr√°fico. Por ejemplo, para invertir los ejes y presentar un gr√°fico de barras en disposici√≥n horizontal:\n\nfacultad |&gt;\n  \n  ggplot(aes(sexo, fill = sexo)) +\n  \n  # capa geom√©trica barras\n  geom_bar() +\n  \n  # paleta de colores\n  scale_fill_brewer(palette = \"Set2\") +\n  \n  # invierte disposici√≥n de ejes\n  coord_flip()   \n\n\n\n\n\n\n\nTemas con theme()\n\nggplot2 incluye un conjunto de temas gr√°ficos predefinidos que permiten modificar el aspecto general del gr√°fico. El tema por defecto es theme_gray(), pero puede cambiarse agregando una capa theme_*() dentro del gr√°fico.\nRepetimos el gr√°fico anterior, esta vez utilizando el tema blanco y negro (theme_bw()):\n\nfacultad |&gt;\n  \n  ggplot(aes(sexo, fill = sexo)) +\n  \n  # capa geom√©trica barras\n  geom_bar() +\n  \n  # paleta de colores\n  scale_fill_brewer(palette = \"Set2\") +\n  \n  # invierte disposici√≥n de ejes\n  coord_flip() +\n  \n  # tema en blanco y negro\n  theme_bw()\n\n\n\n\n\n\n\nTambi√©n podemos aplicar un tema de fondo oscuro con theme_dark():\n\nfacultad |&gt;\n  \n  ggplot(aes(sexo, fill = sexo)) +\n  \n  # capa geom√©trica barras\n  geom_bar() +\n  \n  # paleta de colores\n  scale_fill_brewer(palette = \"Set2\") +\n  \n  # invierte disposici√≥n de ejes\n  coord_flip() +\n  \n  # tema con fondo oscuro\n  theme_dark()\n\n\n\n\n\n\n\nA continuaci√≥n se muestra un cuadro con los principales temas disponibles en ggplot2 y sus caracter√≠sticas visuales:\n\n\n\n\nAdem√°s del aspecto general del gr√°fico, es posible agregar t√≠tulos, subt√≠tulos y etiquetas de ejes con la funci√≥n labs(). Por ejemplo:\n\nlabs(\n  x = \"Etiqueta X\", \n  y = \"Etiqueta Y\", \n  title = \"T√≠tulo del gr√°fico\", \n  subtitle = \"Subt√≠tulo del gr√°fico\"\n)\n\nTambi√©n se pueden ajustar detalles del texto, como tipo de fuente o tama√±o, mediante la funci√≥n theme():\n\nfacultad |&gt;\n  ggplot(aes(sexo, fill = sexo)) +\n  # capa geom√©trica barras\n  geom_bar() +\n  # paleta de colores\n  scale_fill_brewer(palette = \"Set2\") +\n  # invierte disposici√≥n de ejes\n  coord_flip() +\n  # cambia etiquetas de los ejes\n  labs(y = \"Cantidad\", \n       title = \"Distribuci√≥n de sexo\") +\n  # modifica el estilo de fuente del t√≠tulo\n  theme(plot.title = element_text(face = \"italic\", \n                                  size = 16)) \n\n\n\n\n\n\n\nPaquete esquisse\n\n\n\n\n\nEl paqueteesquisse (Meyer y Perrier 2025) es una extensi√≥n de ggplot2 que permite crear gr√°ficos de manera interactiva, mediante una interfaz gr√°fica intuitiva basada en el sistema de arrastrar y soltar (drag & drop).\nCon esquisse es posible:\n\nExplorar visualmente los datos seg√∫n su tipo.\nAsignar variables a diferentes est√©ticas del gr√°fico (ejes, color, tama√±o, etc.).\nExportar los resultados en distintos formatos.\nRecuperar el c√≥digo R que genera el gr√°fico, facilitando su reproducci√≥n y modificaci√≥n.\n\nEl paquete se instala mediante el men√∫ Packages de RStudio o ejecutando:\n\ninstall.packages(\"esquisse\")\n\nLuego se puede acceder a la aplicaci√≥n por medio del acceso Addins:\n\n\n\n\no ejecutando en consola:\n\nesquisser()\n\nTambi√©n se puede agregar el nombre de la tabla de datos dentro de los par√©ntesis\n\nesquisser(datos)\n\nPara m√°s detalles, se puede consultar la vi√±eta del paquete disponible en CRAN o en su repositorio de GitHub.\nOtras extensiones de ggplot2\nUna de las grandes fortalezas de ggplot2 es su ecosistema de extensiones. Hasta el momento, existen m√°s de 140 paquetes desarrollados para ampliar sus funcionalidades, muchos de ellos dise√±ados para facilitar tareas espec√≠ficas o agregar nuevas capas, geometr√≠as, temas, escalas o herramientas interactivas.\nAlgunas de las extensiones que utilizaremos durante el curso son:\n\npatchwork(Pedersen 2024): permite combinar m√∫ltiples gr√°ficos de ggplot2 en una misma figura de forma sencilla y controlada.\nGGally(Schloerke et¬†al. 2024): extiende ggplot2 con funciones para crear matrices de gr√°ficos (como ggpairs()), √∫tiles para an√°lisis exploratorio multivariado.\nggpubr(Kassambara 2023): facilita la creaci√≥n de gr√°ficos listos para publicar, con funciones simplificadas para agregar t√≠tulos, etiquetas, comparaciones estad√≠sticas y anotaciones.\nsee(L√ºdecke et¬†al. 2021): ofrece temas, paletas de colores y escalas compatibles con personas con daltonismo, adem√°s de geometr√≠as personalizadas.\nsurvminer(Kassambara, Kosinski, y Biecek 2024): dise√±ado para la visualizaci√≥n de an√°lisis de supervivencia (como curvas de Kaplan-Meier) utilizando ggplot2.\nggfortify(Tang, Horikoshi, y Li 2016): permite graficar objetos estad√≠sticos como modelos lineales, PCA o series temporales sin necesidad de escribir c√≥digo ggplot2 desde cero.\n\nEstas extensiones permiten ampliar la flexibilidad y expresividad gr√°fica de ggplot2 sin perder la estructura gramatical que lo caracteriza.",
    "crumbs": [
      "Unidad 1",
      "Introducci√≥n a tidyverse"
    ]
  }
]